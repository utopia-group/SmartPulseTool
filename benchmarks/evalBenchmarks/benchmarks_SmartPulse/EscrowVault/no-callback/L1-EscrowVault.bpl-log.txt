This is Ultimate 0.1.24-9993c5c-m
[2020-05-31 01:03:30,430 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-31 01:03:30,431 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-31 01:03:30,441 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-31 01:03:30,441 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-31 01:03:30,442 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-31 01:03:30,444 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-31 01:03:30,445 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-31 01:03:30,447 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-31 01:03:30,448 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-31 01:03:30,449 INFO  L177        SettingsManager]: Büchi Program Product provides no preferences, ignoring...
[2020-05-31 01:03:30,450 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-31 01:03:30,451 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-31 01:03:30,452 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-31 01:03:30,454 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-31 01:03:30,455 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-31 01:03:30,456 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-31 01:03:30,457 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-31 01:03:30,459 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-31 01:03:30,460 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-31 01:03:30,461 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-31 01:03:30,462 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-31 01:03:30,464 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-31 01:03:30,465 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-31 01:03:30,465 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-31 01:03:30,466 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-31 01:03:30,466 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-31 01:03:30,467 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-31 01:03:30,467 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-31 01:03:30,468 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-31 01:03:30,468 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-31 01:03:30,469 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-31 01:03:30,470 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-31 01:03:30,471 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-31 01:03:30,472 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-31 01:03:30,473 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-31 01:03:30,473 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-31 01:03:30,474 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-31 01:03:30,474 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-31 01:03:30,474 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-31 01:03:30,475 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-31 01:03:30,476 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-31 01:03:30,477 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-31 01:03:30,487 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-31 01:03:30,487 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-31 01:03:30,488 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-31 01:03:30,488 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-31 01:03:30,488 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-31 01:03:30,488 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-31 01:03:30,488 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-31 01:03:30,489 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-31 01:03:30,489 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-31 01:03:30,489 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-31 01:03:30,490 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-31 01:03:30,490 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-31 01:03:30,509 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-31 01:03:30,520 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-31 01:03:30,522 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-31 01:03:30,523 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-31 01:03:30,523 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-31 01:03:30,524 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/EscrowVault/no-callback/L1-EscrowVault.bpl
[2020-05-31 01:03:30,525 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/EscrowVault/no-callback/L1-EscrowVault.bpl'
[2020-05-31 01:03:30,571 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-31 01:03:30,573 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-31 01:03:30,574 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-31 01:03:30,574 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-31 01:03:30,574 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-31 01:03:30,587 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,588 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,608 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,609 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,621 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,627 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,630 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,637 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-31 01:03:30,637 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-31 01:03:30,637 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-31 01:03:30,639 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-31 01:03:30,641 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/1) ...
[2020-05-31 01:03:30,651 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-31 01:03:30,656 INFO  L979   opiaSpecLangObserver]: Successfully lexed: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-31 01:03:30,661 INFO  L981   opiaSpecLangObserver]: Successfully parsed: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-31 01:03:30,663 INFO  L599   opiaSpecLangObserver]: Parsed investor_s256==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s256,<IMPLEMENTATION_INPARAM,deposit_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-31 01:03:30,665 INFO  L599   opiaSpecLangObserver]: Parsed ( to==user && amount==fsum_deposit_EscrowVault_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[user,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_EscrowVault_2_0,GLOBAL]]]
[2020-05-31 01:03:30,666 INFO  L968   opiaSpecLangObserver]: Compiling: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-31 01:03:30,666 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_enableRefunds_EscrowVault0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-31 01:03:30,666 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-31 01:03:30,667 INFO  L979   opiaSpecLangObserver]: Successfully lexed: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-31 01:03:30,667 INFO  L981   opiaSpecLangObserver]: Successfully parsed: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-31 01:03:30,669 INFO  L599   opiaSpecLangObserver]: Parsed investor_s256==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s256,<IMPLEMENTATION_INPARAM,deposit_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-31 01:03:30,670 INFO  L599   opiaSpecLangObserver]: Parsed investor_s431==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s431,<IMPLEMENTATION_INPARAM,refund_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-31 01:03:30,670 INFO  L968   opiaSpecLangObserver]: Compiling: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-31 01:03:30,670 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_EscrowVault0) ) && ( <>AP(success_refund_EscrowVault0) ) )
Executed UtopiaSpecLang
[2020-05-31 01:03:30,676 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 31.05 01:03:30 PropertyContainer
[2020-05-31 01:03:30,676 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-31 01:03:30,676 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-31 01:03:30,676 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-31 01:03:30,677 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-31 01:03:30,677 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/2) ...
[2020-05-31 01:03:30,677 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-31 01:03:30,678 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-31 01:03:30,687 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 31.05 01:03:30" (2/2) ...
[2020-05-31 01:03:30,687 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-31 01:03:30,688 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-31 01:03:30,688 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-31 01:03:30,688 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-31 01:03:30,689 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/2) ...
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-31 01:03:30,730 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure mul_SafeMath__success
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure div_SafeMath__success
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-31 01:03:30,730 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-31 01:03:30,731 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable_NoBaseCtor__success
[2020-05-31 01:03:30,731 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable
[2020-05-31 01:03:30,731 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable
[2020-05-31 01:03:30,731 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable
[2020-05-31 01:03:30,731 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault_NoBaseCtor__success
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault
[2020-05-31 01:03:30,732 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault
[2020-05-31 01:03:30,732 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault
[2020-05-31 01:03:30,732 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault
[2020-05-31 01:03:30,732 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault
[2020-05-31 01:03:30,732 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault
[2020-05-31 01:03:30,732 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault
[2020-05-31 01:03:30,733 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault
[2020-05-31 01:03:30,733 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault
[2020-05-31 01:03:30,733 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault
[2020-05-31 01:03:30,733 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault
[2020-05-31 01:03:30,733 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault
[2020-05-31 01:03:30,733 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-31 01:03:30,733 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-31 01:03:30,733 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__success
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Ownable
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Ownable
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_EscrowVault
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-31 01:03:30,734 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure mul_SafeMath__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure div_SafeMath__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable_NoBaseCtor__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable__success
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable__success
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault_NoBaseCtor__fail
[2020-05-31 01:03:30,735 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault__success
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault__fail
[2020-05-31 01:03:30,736 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault__success
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault__fail
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault__success
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault__fail
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-31 01:03:30,737 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__fail
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul_SafeMath__fail
[2020-05-31 01:03:30,738 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul_SafeMath__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure div_SafeMath__fail
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure div_SafeMath__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable_NoBaseCtor__fail
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable_NoBaseCtor__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable__fail
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable__success
[2020-05-31 01:03:30,739 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable__success
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault_NoBaseCtor__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault_NoBaseCtor__success
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault__success
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault__success
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault__success
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault__fail
[2020-05-31 01:03:30,740 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault__success
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault__fail
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault__success
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault__fail
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault__success
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault__fail
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault__success
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault__fail
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault__success
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-31 01:03:30,741 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__fail
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__success
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-31 01:03:30,742 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-31 01:03:30,743 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Ownable
[2020-05-31 01:03:30,743 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Ownable
[2020-05-31 01:03:30,743 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_EscrowVault
[2020-05-31 01:03:30,743 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-31 01:03:30,743 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-31 01:03:30,743 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-31 01:03:30,789 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-31 01:03:30,789 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-31 01:03:30,876 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-31 01:03:30,891 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-31 01:03:31,057 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-31 01:03:31,088 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-31 01:03:31,088 INFO  L286             CfgBuilder]: Removed 3 assue(true) statements.
[2020-05-31 01:03:31,090 INFO  L202        PluginConnector]: Adding new model L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 31.05 01:03:31 BoogieIcfgContainer
[2020-05-31 01:03:31,091 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 31.05 01:03:30" (2/2) ...
[2020-05-31 01:03:31,091 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-31 01:03:31,092 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@696abe79 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 31.05 01:03:31, skipping insertion in model container
[2020-05-31 01:03:31,092 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-31 01:03:31,092 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-31 01:03:31,092 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-31 01:03:31,093 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-31 01:03:31,094 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/3) ...
[2020-05-31 01:03:31,094 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@7bb8abfb and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 31.05 01:03:31, skipping insertion in model container
[2020-05-31 01:03:31,094 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 31.05 01:03:30" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-31 01:03:31,139 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 31.05 01:03:31 NWAContainer
[2020-05-31 01:03:31,139 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-31 01:03:31,139 INFO  L113        PluginConnector]: ------------------------Büchi Program Product----------------------------
[2020-05-31 01:03:31,139 INFO  L271        PluginConnector]: Initializing Büchi Program Product...
[2020-05-31 01:03:31,140 INFO  L276        PluginConnector]: Büchi Program Product initialized
[2020-05-31 01:03:31,140 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 31.05 01:03:31" (3/4) ...
[2020-05-31 01:03:31,141 INFO  L205        PluginConnector]: Invalid model from Büchi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@426478d5 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 31.05 01:03:31, skipping insertion in model container
[2020-05-31 01:03:31,141 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 31.05 01:03:31" (4/4) ...
[2020-05-31 01:03:31,144 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-31 01:03:31,146 INFO  L110   BuchiProductObserver]: Initial RCFG 888 locations, 1095 edges
[2020-05-31 01:03:31,146 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-31 01:03:31,155 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-31 01:03:34,826 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-31 01:03:34,839 INFO  L110   BuchiProductObserver]: BuchiProgram size 8239 locations, 31628 edges
[2020-05-31 01:03:34,839 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 31.05 01:03:34 BoogieIcfgContainer
[2020-05-31 01:03:34,840 INFO  L132        PluginConnector]: ------------------------ END Büchi Program Product----------------------------
[2020-05-31 01:03:34,840 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-31 01:03:34,840 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-31 01:03:34,841 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-31 01:03:34,842 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 31.05 01:03:34" (1/1) ...
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,983 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,985 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,985 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,985 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,985 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,986 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,986 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,987 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,988 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:34,993 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-31 01:03:35,017 INFO  L313           BlockEncoder]: Initial Icfg 8239 locations, 31628 edges
[2020-05-31 01:03:35,018 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-31 01:03:35,018 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-31 01:03:35,018 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-31 01:03:35,019 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-31 01:03:35,042 INFO  L70    emoveInfeasibleEdges]: Removed 413 edges and 36 locations because of local infeasibility
[2020-05-31 01:03:35,057 INFO  L70        RemoveSinkStates]: Removed 18 edges and 4 locations by removing sink states
[2020-05-31 01:03:35,083 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-31 01:03:35,091 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-31 01:03:35,099 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-31 01:03:35,099 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-31 01:03:35,106 INFO  L313           BlockEncoder]: Encoded RCFG 8119 locations, 30946 edges
[2020-05-31 01:03:35,107 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 31.05 01:03:35 BasicIcfg
[2020-05-31 01:03:35,107 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-31 01:03:35,107 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-31 01:03:35,107 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-31 01:03:35,109 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-31 01:03:35,109 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,109 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 31.05 01:03:30" (1/6) ...
[2020-05-31 01:03:35,110 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@5b820785 and model type L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 31.05 01:03:35, skipping insertion in model container
[2020-05-31 01:03:35,111 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,111 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 31.05 01:03:30" (2/6) ...
[2020-05-31 01:03:35,111 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@5b820785 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 31.05 01:03:35, skipping insertion in model container
[2020-05-31 01:03:35,111 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,111 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 31.05 01:03:31" (3/6) ...
[2020-05-31 01:03:35,111 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@5b820785 and model type L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 31.05 01:03:35, skipping insertion in model container
[2020-05-31 01:03:35,111 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,111 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 31.05 01:03:31" (4/6) ...
[2020-05-31 01:03:35,111 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@5b820785 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 31.05 01:03:35, skipping insertion in model container
[2020-05-31 01:03:35,112 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,112 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 31.05 01:03:34" (5/6) ...
[2020-05-31 01:03:35,112 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@5b820785 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 31.05 01:03:35, skipping insertion in model container
[2020-05-31 01:03:35,112 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-31 01:03:35,112 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 31.05 01:03:35" (6/6) ...
[2020-05-31 01:03:35,113 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L1-EscrowVault.bpl_BEv2
[2020-05-31 01:03:35,142 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-31 01:03:35,142 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-31 01:03:35,142 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-31 01:03:35,142 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-31 01:03:35,142 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-31 01:03:35,143 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-31 01:03:35,143 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-31 01:03:35,143 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-31 01:03:35,143 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-31 01:03:35,216 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8119 states.
[2020-05-31 01:03:35,338 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:35,338 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:35,338 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:35,350 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:35,350 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:35,350 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-31 01:03:35,350 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8119 states.
[2020-05-31 01:03:35,420 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:35,420 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:35,420 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:35,422 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:35,422 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2250]              assume null == 0;
[L2251]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2251]  RET         call this := FreshRefGenerator__success();
[L2252]              assume now >= 0;
[L2253]              assume DType[this] == EscrowVault;
[L2254]              gas := gas - 53000;
[L2255]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2255]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]              assume !revert && gas >= 0;

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND TRUE   choice == 8
[L2168]              gas := gas - 21000;
[L2169]  COND FALSE  !(gas >= 0)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:35,438 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:35,438 INFO  L82        PathProgramCache]: Analyzing trace with hash 1961586707, now seen corresponding path program 1 times
[2020-05-31 01:03:35,442 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:35,459 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:35,586 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-31 01:03:35,588 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:35,588 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:35,592 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:36,130 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:36,131 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:36,133 INFO  L87              Difference]: Start difference. First operand 8119 states. Second operand 3 states.
[2020-05-31 01:03:36,927 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:36,927 INFO  L93              Difference]: Finished difference Result 6755 states and 16125 transitions.
[2020-05-31 01:03:36,927 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:36,928 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6755 states and 16125 transitions.
[2020-05-31 01:03:36,983 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:37,057 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6755 states to 6755 states and 16125 transitions.
[2020-05-31 01:03:37,058 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-31 01:03:37,063 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 542
[2020-05-31 01:03:37,063 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6755 states and 16125 transitions.
[2020-05-31 01:03:37,092 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:37,092 INFO  L728         BuchiCegarLoop]: Abstraction has 6755 states and 16125 transitions.
[2020-05-31 01:03:37,114 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6755 states and 16125 transitions.
[2020-05-31 01:03:37,250 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6755 to 6755.
[2020-05-31 01:03:37,251 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6755 states.
[2020-05-31 01:03:37,273 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6755 states to 6755 states and 16125 transitions.
[2020-05-31 01:03:37,275 INFO  L751         BuchiCegarLoop]: Abstraction has 6755 states and 16125 transitions.
[2020-05-31 01:03:37,275 INFO  L631         BuchiCegarLoop]: Abstraction has 6755 states and 16125 transitions.
[2020-05-31 01:03:37,275 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-31 01:03:37,275 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6755 states and 16125 transitions.
[2020-05-31 01:03:37,296 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:37,296 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:37,296 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:37,298 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:37,298 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2250]              assume null == 0;
[L2251]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2251]  RET         call this := FreshRefGenerator__success();
[L2252]              assume now >= 0;
[L2253]              assume DType[this] == EscrowVault;
[L2254]              gas := gas - 53000;
[L2255]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2255]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]              assume !revert && gas >= 0;
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND TRUE   choice == 2
[L2222]              gas := gas - 21000;
[L2223]  COND TRUE   gas >= 0
[L2225]              assume msgvalue_MSG == 0;
[L2226]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2226]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND TRUE   choice == 2
[L2222]              gas := gas - 21000;
[L2223]  COND TRUE   gas >= 0
[L2225]              assume msgvalue_MSG == 0;
[L2226]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2226]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:37,302 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:37,302 INFO  L82        PathProgramCache]: Analyzing trace with hash -1578200937, now seen corresponding path program 1 times
[2020-05-31 01:03:37,302 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:37,309 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:37,322 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-31 01:03:37,322 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:37,322 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:37,323 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:37,324 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:37,324 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:37,324 INFO  L87              Difference]: Start difference. First operand 6755 states and 16125 transitions. cyclomatic complexity: 9378 Second operand 3 states.
[2020-05-31 01:03:37,638 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:37,638 INFO  L93              Difference]: Finished difference Result 6481 states and 10659 transitions.
[2020-05-31 01:03:37,638 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:37,639 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6481 states and 10659 transitions.
[2020-05-31 01:03:37,659 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:37,692 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6481 states to 6481 states and 10659 transitions.
[2020-05-31 01:03:37,692 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 542
[2020-05-31 01:03:37,693 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 542
[2020-05-31 01:03:37,694 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6481 states and 10659 transitions.
[2020-05-31 01:03:37,704 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:37,705 INFO  L728         BuchiCegarLoop]: Abstraction has 6481 states and 10659 transitions.
[2020-05-31 01:03:37,715 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6481 states and 10659 transitions.
[2020-05-31 01:03:37,798 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6481 to 6481.
[2020-05-31 01:03:37,798 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6481 states.
[2020-05-31 01:03:37,810 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6481 states to 6481 states and 10659 transitions.
[2020-05-31 01:03:37,810 INFO  L751         BuchiCegarLoop]: Abstraction has 6481 states and 10659 transitions.
[2020-05-31 01:03:37,810 INFO  L631         BuchiCegarLoop]: Abstraction has 6481 states and 10659 transitions.
[2020-05-31 01:03:37,811 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-31 01:03:37,811 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6481 states and 10659 transitions.
[2020-05-31 01:03:37,826 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:37,826 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:37,826 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:37,828 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:37,828 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2250]              assume null == 0;
[L2251]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2251]  RET         call this := FreshRefGenerator__success();
[L2252]              assume now >= 0;
[L2253]              assume DType[this] == EscrowVault;
[L2254]              gas := gas - 53000;
[L2255]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2255]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]              assume !revert && gas >= 0;
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND TRUE   choice == 2
[L2222]              gas := gas - 21000;
[L2223]  COND TRUE   gas >= 0
[L2225]              assume msgvalue_MSG == 0;
[L2226]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2226]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:37,832 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:37,832 INFO  L82        PathProgramCache]: Analyzing trace with hash -1711456380, now seen corresponding path program 1 times
[2020-05-31 01:03:37,833 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:37,841 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:37,865 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-31 01:03:37,865 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:37,866 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:37,866 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:37,866 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:37,866 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:37,867 INFO  L87              Difference]: Start difference. First operand 6481 states and 10659 transitions. cyclomatic complexity: 4186 Second operand 3 states.
[2020-05-31 01:03:38,182 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:38,182 INFO  L93              Difference]: Finished difference Result 6344 states and 7270 transitions.
[2020-05-31 01:03:38,182 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:38,182 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6344 states and 7270 transitions.
[2020-05-31 01:03:38,209 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:38,242 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6344 states to 6344 states and 7270 transitions.
[2020-05-31 01:03:38,242 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 542
[2020-05-31 01:03:38,243 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 542
[2020-05-31 01:03:38,243 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6344 states and 7270 transitions.
[2020-05-31 01:03:38,252 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:38,252 INFO  L728         BuchiCegarLoop]: Abstraction has 6344 states and 7270 transitions.
[2020-05-31 01:03:38,264 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6344 states and 7270 transitions.
[2020-05-31 01:03:38,350 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6344 to 6344.
[2020-05-31 01:03:38,350 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6344 states.
[2020-05-31 01:03:38,360 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6344 states to 6344 states and 7270 transitions.
[2020-05-31 01:03:38,361 INFO  L751         BuchiCegarLoop]: Abstraction has 6344 states and 7270 transitions.
[2020-05-31 01:03:38,361 INFO  L631         BuchiCegarLoop]: Abstraction has 6344 states and 7270 transitions.
[2020-05-31 01:03:38,361 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-31 01:03:38,361 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6344 states and 7270 transitions.
[2020-05-31 01:03:38,372 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:38,373 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:38,373 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:38,375 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:38,375 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2250]              assume null == 0;
[L2251]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2251]  RET         call this := FreshRefGenerator__success();
[L2252]              assume now >= 0;
[L2253]              assume DType[this] == EscrowVault;
[L2254]              gas := gas - 53000;
[L2255]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2255]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]              assume !revert && gas >= 0;
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND TRUE   choice == 2
[L2222]              gas := gas - 21000;
[L2223]  COND TRUE   gas >= 0
[L2225]              assume msgvalue_MSG == 0;
[L2226]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2226]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND TRUE   choice == 7
[L2177]              gas := gas - 21000;
[L2178]  COND TRUE   gas >= 0
[L2180]              assume msgvalue_MSG >= 0;
[L2181]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND TRUE   revert
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2181]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:38,382 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:38,382 INFO  L82        PathProgramCache]: Analyzing trace with hash -2109862668, now seen corresponding path program 1 times
[2020-05-31 01:03:38,383 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:38,390 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:38,417 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-31 01:03:38,418 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:38,418 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:38,418 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:38,418 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:38,418 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:38,418 INFO  L87              Difference]: Start difference. First operand 6344 states and 7270 transitions. cyclomatic complexity: 934 Second operand 3 states.
[2020-05-31 01:03:38,568 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:38,569 INFO  L93              Difference]: Finished difference Result 7994 states and 9281 transitions.
[2020-05-31 01:03:38,569 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:38,569 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7994 states and 9281 transitions.
[2020-05-31 01:03:38,589 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:38,619 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7994 states to 7994 states and 9281 transitions.
[2020-05-31 01:03:38,619 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 667
[2020-05-31 01:03:38,620 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 667
[2020-05-31 01:03:38,620 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7994 states and 9281 transitions.
[2020-05-31 01:03:38,626 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:38,626 INFO  L728         BuchiCegarLoop]: Abstraction has 7994 states and 9281 transitions.
[2020-05-31 01:03:38,636 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7994 states and 9281 transitions.
[2020-05-31 01:03:38,710 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7994 to 7399.
[2020-05-31 01:03:38,710 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7399 states.
[2020-05-31 01:03:38,718 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7399 states to 7399 states and 8525 transitions.
[2020-05-31 01:03:38,719 INFO  L751         BuchiCegarLoop]: Abstraction has 7399 states and 8525 transitions.
[2020-05-31 01:03:38,719 INFO  L631         BuchiCegarLoop]: Abstraction has 7399 states and 8525 transitions.
[2020-05-31 01:03:38,719 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-31 01:03:38,719 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7399 states and 8525 transitions.
[2020-05-31 01:03:38,729 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:38,729 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:38,729 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:38,731 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:38,731 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2250]              assume null == 0;
[L2251]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2251]  RET         call this := FreshRefGenerator__success();
[L2252]              assume now >= 0;
[L2253]              assume DType[this] == EscrowVault;
[L2254]              gas := gas - 53000;
[L2255]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND FALSE  !(revert)
[L1299]  CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]              assume msgsender_MSG != null;
[L1225]              Balance[this] := 0;
[L1226]  CALL        call __var_4 := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L1226]  RET         call __var_4 := FreshRefGenerator__success();
[L1227]  COND FALSE  !(revert)
[L1232]              deposited_EscrowVault[this] := __var_4;
[L1233]              M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]              sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]              beneficiary_EscrowVault[this] := null;
[L1236]              superOwner_EscrowVault[this] := null;
[L1237]              __var_2 := null;
[L1238]  COND TRUE   !(_beneficiary_s224 != null)
[L1240]              revert := true;
[L1299]  RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2255]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]              assume !revert && gas >= 0;
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND TRUE   choice == 2
[L2222]              gas := gas - 21000;
[L2223]  COND TRUE   gas >= 0
[L2225]              assume msgvalue_MSG == 0;
[L2226]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND FALSE  !(revert)
[L1717]              gas := gas - 367;
[L1718]  COND TRUE   !(state_EscrowVault[this] == 0)
[L1720]              revert := true;
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2226]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND TRUE   choice == 7
[L2177]              gas := gas - 21000;
[L2178]  COND TRUE   gas >= 0
[L2180]              assume msgvalue_MSG >= 0;
[L2181]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND FALSE  !(revert)
[L1363]              gas := gas - 733;
[L1364]  COND TRUE   !(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2)
[L1366]              revert := true;
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2181]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND TRUE   choice == 1
[L2231]              gas := gas - 21000;
[L2232]  COND TRUE   gas >= 0
[L2234]              assume msgvalue_MSG == 0;
[L2235]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2235]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:38,733 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:38,734 INFO  L82        PathProgramCache]: Analyzing trace with hash 154340695, now seen corresponding path program 1 times
[2020-05-31 01:03:38,734 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:38,744 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:38,776 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:38,776 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:38,776 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:38,777 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:38,777 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:38,777 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:38,777 INFO  L87              Difference]: Start difference. First operand 7399 states and 8525 transitions. cyclomatic complexity: 1134 Second operand 3 states.
[2020-05-31 01:03:38,891 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:38,891 INFO  L93              Difference]: Finished difference Result 8512 states and 9789 transitions.
[2020-05-31 01:03:38,891 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:38,891 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8512 states and 9789 transitions.
[2020-05-31 01:03:38,910 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-05-31 01:03:38,934 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8512 states to 7952 states and 9115 transitions.
[2020-05-31 01:03:38,934 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 637
[2020-05-31 01:03:38,935 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 642
[2020-05-31 01:03:38,935 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7952 states and 9115 transitions.
[2020-05-31 01:03:38,940 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:38,940 INFO  L728         BuchiCegarLoop]: Abstraction has 7952 states and 9115 transitions.
[2020-05-31 01:03:38,949 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7952 states and 9115 transitions.
[2020-05-31 01:03:39,006 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7952 to 6808.
[2020-05-31 01:03:39,006 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6808 states.
[2020-05-31 01:03:39,014 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6808 states to 6808 states and 7640 transitions.
[2020-05-31 01:03:39,014 INFO  L751         BuchiCegarLoop]: Abstraction has 6808 states and 7640 transitions.
[2020-05-31 01:03:39,014 INFO  L631         BuchiCegarLoop]: Abstraction has 6808 states and 7640 transitions.
[2020-05-31 01:03:39,014 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-31 01:03:39,014 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6808 states and 7640 transitions.
[2020-05-31 01:03:39,022 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:39,022 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:39,022 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:39,024 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:39,024 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND FALSE  !(Balance[from] >= amount)
[L1997]                    success := false;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND FALSE  !(Balance[from] >= amount)
[L1997]                    success := false;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:39,028 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:39,028 INFO  L82        PathProgramCache]: Analyzing trace with hash 1746397549, now seen corresponding path program 1 times
[2020-05-31 01:03:39,028 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:39,048 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:39,111 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:39,111 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:39,111 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:03:39,112 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:39,112 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:03:39,112 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:03:39,112 INFO  L87              Difference]: Start difference. First operand 6808 states and 7640 transitions. cyclomatic complexity: 840 Second operand 3 states.
[2020-05-31 01:03:39,175 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:39,176 INFO  L93              Difference]: Finished difference Result 6840 states and 7672 transitions.
[2020-05-31 01:03:39,176 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:03:39,176 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6840 states and 7672 transitions.
[2020-05-31 01:03:39,192 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:39,213 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6840 states to 6840 states and 7672 transitions.
[2020-05-31 01:03:39,213 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 573
[2020-05-31 01:03:39,214 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 573
[2020-05-31 01:03:39,214 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6840 states and 7672 transitions.
[2020-05-31 01:03:39,219 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:39,220 INFO  L728         BuchiCegarLoop]: Abstraction has 6840 states and 7672 transitions.
[2020-05-31 01:03:39,227 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6840 states and 7672 transitions.
[2020-05-31 01:03:39,280 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6840 to 6832.
[2020-05-31 01:03:39,280 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6832 states.
[2020-05-31 01:03:39,287 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6832 states to 6832 states and 7664 transitions.
[2020-05-31 01:03:39,287 INFO  L751         BuchiCegarLoop]: Abstraction has 6832 states and 7664 transitions.
[2020-05-31 01:03:39,287 INFO  L631         BuchiCegarLoop]: Abstraction has 6832 states and 7664 transitions.
[2020-05-31 01:03:39,287 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-31 01:03:39,287 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6832 states and 7664 transitions.
[2020-05-31 01:03:39,296 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:39,296 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:39,296 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:39,298 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:39,298 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND FALSE  !(Balance[from] >= amount)
[L1997]                    success := false;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND FALSE  !(Balance[from] >= amount)
[L1997]                    success := false;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:39,302 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:39,302 INFO  L82        PathProgramCache]: Analyzing trace with hash 1257278719, now seen corresponding path program 1 times
[2020-05-31 01:03:39,302 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:39,320 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:39,413 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:39,413 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:39,414 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-31 01:03:39,414 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:39,414 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-31 01:03:39,414 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-31 01:03:39,414 INFO  L87              Difference]: Start difference. First operand 6832 states and 7664 transitions. cyclomatic complexity: 840 Second operand 4 states.
[2020-05-31 01:03:39,505 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:39,505 INFO  L93              Difference]: Finished difference Result 6912 states and 7756 transitions.
[2020-05-31 01:03:39,505 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-31 01:03:39,506 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6912 states and 7756 transitions.
[2020-05-31 01:03:39,531 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:39,554 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6912 states to 6896 states and 7740 transitions.
[2020-05-31 01:03:39,554 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 580
[2020-05-31 01:03:39,555 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 580
[2020-05-31 01:03:39,555 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6896 states and 7740 transitions.
[2020-05-31 01:03:39,560 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:39,560 INFO  L728         BuchiCegarLoop]: Abstraction has 6896 states and 7740 transitions.
[2020-05-31 01:03:39,567 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6896 states and 7740 transitions.
[2020-05-31 01:03:39,611 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6896 to 6896.
[2020-05-31 01:03:39,611 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6896 states.
[2020-05-31 01:03:39,618 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6896 states to 6896 states and 7740 transitions.
[2020-05-31 01:03:39,618 INFO  L751         BuchiCegarLoop]: Abstraction has 6896 states and 7740 transitions.
[2020-05-31 01:03:39,618 INFO  L631         BuchiCegarLoop]: Abstraction has 6896 states and 7740 transitions.
[2020-05-31 01:03:39,618 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-31 01:03:39,618 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6896 states and 7740 transitions.
[2020-05-31 01:03:39,626 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:39,626 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:39,626 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:39,628 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:39,628 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:39,631 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:39,632 INFO  L82        PathProgramCache]: Analyzing trace with hash 402318330, now seen corresponding path program 1 times
[2020-05-31 01:03:39,632 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:39,645 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:39,790 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:39,791 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:39,791 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-31 01:03:39,791 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:39,791 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:03:39,792 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=28, Invalid=62, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:03:39,792 INFO  L87              Difference]: Start difference. First operand 6896 states and 7740 transitions. cyclomatic complexity: 852 Second operand 10 states.
[2020-05-31 01:03:42,639 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:42,639 INFO  L93              Difference]: Finished difference Result 8112 states and 8941 transitions.
[2020-05-31 01:03:42,639 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:03:42,639 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8112 states and 8941 transitions.
[2020-05-31 01:03:42,658 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-31 01:03:42,688 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8112 states to 7952 states and 8765 transitions.
[2020-05-31 01:03:42,688 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 684
[2020-05-31 01:03:42,689 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 684
[2020-05-31 01:03:42,689 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7952 states and 8765 transitions.
[2020-05-31 01:03:42,696 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:42,696 INFO  L728         BuchiCegarLoop]: Abstraction has 7952 states and 8765 transitions.
[2020-05-31 01:03:42,703 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7952 states and 8765 transitions.
[2020-05-31 01:03:42,749 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7952 to 6567.
[2020-05-31 01:03:42,749 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6567 states.
[2020-05-31 01:03:42,756 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6567 states to 6567 states and 7196 transitions.
[2020-05-31 01:03:42,756 INFO  L751         BuchiCegarLoop]: Abstraction has 6567 states and 7196 transitions.
[2020-05-31 01:03:42,756 INFO  L631         BuchiCegarLoop]: Abstraction has 6567 states and 7196 transitions.
[2020-05-31 01:03:42,756 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-31 01:03:42,756 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6567 states and 7196 transitions.
[2020-05-31 01:03:42,763 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-31 01:03:42,763 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:42,764 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:42,765 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:42,765 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:42,768 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:42,768 INFO  L82        PathProgramCache]: Analyzing trace with hash -765101558, now seen corresponding path program 1 times
[2020-05-31 01:03:42,769 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:42,782 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:42,887 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:42,888 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:42,888 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-31 01:03:42,888 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:42,888 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:03:42,888 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:03:42,889 INFO  L87              Difference]: Start difference. First operand 6567 states and 7196 transitions. cyclomatic complexity: 637 Second operand 10 states.
[2020-05-31 01:03:45,914 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:45,915 INFO  L93              Difference]: Finished difference Result 7518 states and 8349 transitions.
[2020-05-31 01:03:45,915 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:03:45,915 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7518 states and 8349 transitions.
[2020-05-31 01:03:45,933 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:45,950 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7518 states to 7462 states and 8285 transitions.
[2020-05-31 01:03:45,950 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 613
[2020-05-31 01:03:45,951 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 613
[2020-05-31 01:03:45,952 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7462 states and 8285 transitions.
[2020-05-31 01:03:45,958 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:45,959 INFO  L728         BuchiCegarLoop]: Abstraction has 7462 states and 8285 transitions.
[2020-05-31 01:03:45,965 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7462 states and 8285 transitions.
[2020-05-31 01:03:46,018 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7462 to 7414.
[2020-05-31 01:03:46,018 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7414 states.
[2020-05-31 01:03:46,026 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7414 states to 7414 states and 8207 transitions.
[2020-05-31 01:03:46,026 INFO  L751         BuchiCegarLoop]: Abstraction has 7414 states and 8207 transitions.
[2020-05-31 01:03:46,026 INFO  L631         BuchiCegarLoop]: Abstraction has 7414 states and 8207 transitions.
[2020-05-31 01:03:46,026 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-31 01:03:46,026 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7414 states and 8207 transitions.
[2020-05-31 01:03:46,034 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:46,034 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:46,034 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:46,036 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:46,036 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND TRUE   choice == 6
[L2186]                    gas := gas - 21000;
[L2187]        COND TRUE   gas >= 0
[L2189]                    assume msgvalue_MSG == 0;
[L2190]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2190]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND TRUE   choice == 6
[L2186]              gas := gas - 21000;
[L2187]  COND TRUE   gas >= 0
[L2189]              assume msgvalue_MSG == 0;
[L2190]  CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]               havoc __exception;
[L342]               revert := false;
[L343]   COND FALSE  !(__exception)
[L363]   CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]              gas := gas - 1932;
[L2021]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]  COND FALSE  !(revert)
[L1419]              gas := gas - 367;
[L1420]  COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]              gas := gas - 20337;
[L1427]              state_EscrowVault[this] := 2;
[L1428]              assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]   RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]               assume !revert && gas >= 0;
[L2190]  RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:46,040 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:46,040 INFO  L82        PathProgramCache]: Analyzing trace with hash 1614776942, now seen corresponding path program 1 times
[2020-05-31 01:03:46,040 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:46,051 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:46,118 INFO  L134       CoverageAnalysis]: Checked inductivity of 37 backedges. 2 proven. 25 refuted. 0 times theorem prover too weak. 10 trivial. 0 not checked.
[2020-05-31 01:03:46,118 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:03:46,118 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-31 01:03:46,119 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:46,119 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-31 01:03:46,119 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-31 01:03:46,119 INFO  L87              Difference]: Start difference. First operand 7414 states and 8207 transitions. cyclomatic complexity: 801 Second operand 11 states.
[2020-05-31 01:03:49,401 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:03:49,401 INFO  L93              Difference]: Finished difference Result 7442 states and 8255 transitions.
[2020-05-31 01:03:49,401 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:03:49,401 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7442 states and 8255 transitions.
[2020-05-31 01:03:49,416 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:49,430 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7442 states to 7442 states and 8255 transitions.
[2020-05-31 01:03:49,430 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 615
[2020-05-31 01:03:49,431 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 615
[2020-05-31 01:03:49,431 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7442 states and 8255 transitions.
[2020-05-31 01:03:49,435 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:03:49,435 INFO  L728         BuchiCegarLoop]: Abstraction has 7442 states and 8255 transitions.
[2020-05-31 01:03:49,440 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7442 states and 8255 transitions.
[2020-05-31 01:03:49,479 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7442 to 7406.
[2020-05-31 01:03:49,479 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7406 states.
[2020-05-31 01:03:49,486 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7406 states to 7406 states and 8191 transitions.
[2020-05-31 01:03:49,486 INFO  L751         BuchiCegarLoop]: Abstraction has 7406 states and 8191 transitions.
[2020-05-31 01:03:49,486 INFO  L631         BuchiCegarLoop]: Abstraction has 7406 states and 8191 transitions.
[2020-05-31 01:03:49,486 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-31 01:03:49,486 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7406 states and 8191 transitions.
[2020-05-31 01:03:49,493 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-31 01:03:49,493 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:03:49,494 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:03:49,494 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:03:49,494 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:03:49,497 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:03:49,498 INFO  L82        PathProgramCache]: Analyzing trace with hash -756144295, now seen corresponding path program 1 times
[2020-05-31 01:03:49,498 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:03:49,512 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:03:49,669 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:03:49,669 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:03:49,669 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [26] imperfect sequences [] total 26
[2020-05-31 01:03:49,669 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:03:49,669 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 27 interpolants.
[2020-05-31 01:03:49,670 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=68, Invalid=634, Unknown=0, NotChecked=0, Total=702
[2020-05-31 01:03:49,670 INFO  L87              Difference]: Start difference. First operand 7406 states and 8191 transitions. cyclomatic complexity: 793 Second operand 27 states.
[2020-05-31 01:04:07,225 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:04:07,225 INFO  L93              Difference]: Finished difference Result 15406 states and 17408 transitions.
[2020-05-31 01:04:07,225 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 44 states. 
[2020-05-31 01:04:07,225 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15406 states and 17408 transitions.
[2020-05-31 01:04:07,261 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:07,300 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15406 states to 15406 states and 17408 transitions.
[2020-05-31 01:04:07,301 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1298
[2020-05-31 01:04:07,301 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1298
[2020-05-31 01:04:07,301 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15406 states and 17408 transitions.
[2020-05-31 01:04:07,310 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:04:07,310 INFO  L728         BuchiCegarLoop]: Abstraction has 15406 states and 17408 transitions.
[2020-05-31 01:04:07,316 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15406 states and 17408 transitions.
[2020-05-31 01:04:07,428 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15406 to 15207.
[2020-05-31 01:04:07,428 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15207 states.
[2020-05-31 01:04:07,446 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15207 states to 15207 states and 17086 transitions.
[2020-05-31 01:04:07,446 INFO  L751         BuchiCegarLoop]: Abstraction has 15207 states and 17086 transitions.
[2020-05-31 01:04:07,446 INFO  L631         BuchiCegarLoop]: Abstraction has 15207 states and 17086 transitions.
[2020-05-31 01:04:07,446 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-31 01:04:07,446 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15207 states and 17086 transitions.
[2020-05-31 01:04:07,461 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:07,461 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:04:07,461 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:04:07,462 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:04:07,463 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:04:07,466 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:04:07,466 INFO  L82        PathProgramCache]: Analyzing trace with hash -813824868, now seen corresponding path program 1 times
[2020-05-31 01:04:07,466 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:04:07,482 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:04:07,918 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:04:07,918 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:04:07,918 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [42] imperfect sequences [] total 42
[2020-05-31 01:04:07,919 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:04:07,919 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-05-31 01:04:07,919 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=128, Invalid=1678, Unknown=0, NotChecked=0, Total=1806
[2020-05-31 01:04:07,920 INFO  L87              Difference]: Start difference. First operand 15207 states and 17086 transitions. cyclomatic complexity: 1895 Second operand 43 states.
[2020-05-31 01:04:42,366 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:04:42,366 INFO  L93              Difference]: Finished difference Result 20708 states and 23917 transitions.
[2020-05-31 01:04:42,366 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 82 states. 
[2020-05-31 01:04:42,366 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20708 states and 23917 transitions.
[2020-05-31 01:04:42,403 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:42,456 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20708 states to 20708 states and 23917 transitions.
[2020-05-31 01:04:42,456 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1415
[2020-05-31 01:04:42,457 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1415
[2020-05-31 01:04:42,457 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20708 states and 23917 transitions.
[2020-05-31 01:04:42,468 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:04:42,469 INFO  L728         BuchiCegarLoop]: Abstraction has 20708 states and 23917 transitions.
[2020-05-31 01:04:42,477 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20708 states and 23917 transitions.
[2020-05-31 01:04:42,603 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20708 to 19968.
[2020-05-31 01:04:42,603 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19968 states.
[2020-05-31 01:04:42,629 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19968 states to 19968 states and 22804 transitions.
[2020-05-31 01:04:42,630 INFO  L751         BuchiCegarLoop]: Abstraction has 19968 states and 22804 transitions.
[2020-05-31 01:04:42,630 INFO  L631         BuchiCegarLoop]: Abstraction has 19968 states and 22804 transitions.
[2020-05-31 01:04:42,630 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-31 01:04:42,630 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19968 states and 22804 transitions.
[2020-05-31 01:04:42,650 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:42,650 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:04:42,650 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:04:42,651 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:04:42,651 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND TRUE   __exception
[L269]                     __tmp__Balance := Balance;
[L270]                     __tmp__DType := DType;
[L271]                     __tmp__Alloc := Alloc;
[L272]                     __tmp__balance_ADDR := balance_ADDR;
[L273]                     __tmp__M_Ref_int_deposited0 := M_Ref_int_deposited0;
[L274]                     __tmp__sum_deposited0 := sum_deposited0;
[L275]                     __tmp__Length := Length;
[L276]                     __tmp__now := now;
[L277]                     __tmp__owner_Ownable := owner_Ownable;
[L278]                     __tmp__deposited_EscrowVault := deposited_EscrowVault;
[L279]                     __tmp__beneficiary_EscrowVault := beneficiary_EscrowVault;
[L280]                     __tmp__superOwner_EscrowVault := superOwner_EscrowVault;
[L281]                     __tmp__state_EscrowVault := state_EscrowVault;
[L282]         CALL        call EscrowVault_EscrowVault__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1268]        CALL        call Ownable_Ownable__fail(this, msgsender_MSG, msgvalue_MSG);
[L1101]        CALL        call Ownable_Ownable_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1081]                    assume msgsender_MSG != null;
[L1082]                    __tmp__Balance[this] := 0;
[L1083]                    __tmp__owner_Ownable[this] := null;
[L1084]                    __tmp__owner_Ownable[this] := msgsender_MSG;
[L1101]        RET         call Ownable_Ownable_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1102]        COND FALSE  !(revert)
[L1268]        RET         call Ownable_Ownable__fail(this, msgsender_MSG, msgvalue_MSG);
[L1269]        COND FALSE  !(revert)
[L1274]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1180]                    assume msgsender_MSG != null;
[L1181]                    __tmp__Balance[this] := 0;
[L1182]        CALL        call __var_4 := FreshRefGenerator__fail();
[L823]                     havoc newRef;
[L824]                     assume __tmp__Alloc[newRef] == false;
[L825]                     __tmp__Alloc[newRef] := true;
[L826]                     assume newRef != null;
[L1182]        RET         call __var_4 := FreshRefGenerator__fail();
[L1183]        COND FALSE  !(revert)
[L1188]                    __tmp__deposited_EscrowVault[this] := __var_4;
[L1189]                    __tmp__M_Ref_int_deposited0[__tmp__deposited_EscrowVault[this]] := zeroRefIntArr();
[L1190]                    __tmp__sum_deposited0[__tmp__deposited_EscrowVault[this]] := 0;
[L1191]                    __tmp__beneficiary_EscrowVault[this] := null;
[L1192]                    __tmp__superOwner_EscrowVault[this] := null;
[L1193]                    __var_2 := null;
[L1194]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1200]                    __var_3 := null;
[L1201]        COND FALSE  !(!(_superOwner_s224 != null))
[L1207]                    __tmp__beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1208]                    __tmp__superOwner_EscrowVault[this] := _superOwner_s224;
[L1209]                    __tmp__state_EscrowVault[this] := 0;
[L1274]        RET         call EscrowVault_EscrowVault_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1275]        COND FALSE  !(revert)
[L282]         RET         call EscrowVault_EscrowVault__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L283]                     assume revert || gas < 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:04:42,654 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:04:42,654 INFO  L82        PathProgramCache]: Analyzing trace with hash -471867943, now seen corresponding path program 1 times
[2020-05-31 01:04:42,655 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:04:42,662 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:04:42,696 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-31 01:04:42,696 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:04:42,696 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-31 01:04:42,696 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:04:42,696 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-31 01:04:42,696 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-31 01:04:42,697 INFO  L87              Difference]: Start difference. First operand 19968 states and 22804 transitions. cyclomatic complexity: 2878 Second operand 4 states.
[2020-05-31 01:04:43,026 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:04:43,026 INFO  L93              Difference]: Finished difference Result 27484 states and 35991 transitions.
[2020-05-31 01:04:43,026 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-31 01:04:43,026 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 27484 states and 35991 transitions.
[2020-05-31 01:04:43,111 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 48
[2020-05-31 01:04:43,237 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 27484 states to 27415 states and 35922 transitions.
[2020-05-31 01:04:43,238 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1670
[2020-05-31 01:04:43,239 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1670
[2020-05-31 01:04:43,239 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 27415 states and 35922 transitions.
[2020-05-31 01:04:43,266 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:04:43,266 INFO  L728         BuchiCegarLoop]: Abstraction has 27415 states and 35922 transitions.
[2020-05-31 01:04:43,281 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 27415 states and 35922 transitions.
[2020-05-31 01:04:43,484 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 27415 to 19907.
[2020-05-31 01:04:43,484 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19907 states.
[2020-05-31 01:04:43,513 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19907 states to 19907 states and 22744 transitions.
[2020-05-31 01:04:43,513 INFO  L751         BuchiCegarLoop]: Abstraction has 19907 states and 22744 transitions.
[2020-05-31 01:04:43,513 INFO  L631         BuchiCegarLoop]: Abstraction has 19907 states and 22744 transitions.
[2020-05-31 01:04:43,513 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-31 01:04:43,513 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19907 states and 22744 transitions.
[2020-05-31 01:04:43,535 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:43,535 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:04:43,535 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:04:43,537 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:04:43,537 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND TRUE   choice == 5
[L2195]                    gas := gas - 21000;
[L2196]        COND TRUE   gas >= 0
[L2198]                    assume msgvalue_MSG == 0;
[L2199]        CALL        call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L379]                     havoc __exception;
[L380]                     revert := false;
[L381]         COND FALSE  !(__exception)
[L401]         CALL        call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L1491]                    gas := gas - 276;
[L1492]        COND FALSE  !(!(msgsender_MSG == superOwner_EscrowVault[this]))
[L1498]                    gas := gas - 367;
[L1499]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1505]                    gas := gas - 468;
[L1506]                    assume _amount_s320 >= 0;
[L1507]                    __var_6 := this;
[L1508]                    assume Balance[this] >= 0;
[L1509]                    assume _amount_s320 >= 0;
[L1510]        COND FALSE  !(!(_amount_s320 <= Balance[this] && _amount_s320 > 0))
[L1516]                    gas := gas - 36029;
[L1517]                    __var_7 := gas;
[L1518]        COND FALSE  !(gas > 2300)
[L1523]                    __var_7 := __var_7 - gas;
[L1524]                    assume _amount_s320 >= 0;
[L1525]        CALL        call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1525]        RET         call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1526]        COND FALSE  !(!__var_8)
[L1532]                    gas := __var_7 + gas;
[L1533]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L401]         RET         call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L402]                     assume !revert && gas >= 0;
[L2199]        RET         call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:04:43,540 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:04:43,541 INFO  L82        PathProgramCache]: Analyzing trace with hash 1054200531, now seen corresponding path program 1 times
[2020-05-31 01:04:43,541 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:04:43,552 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:04:43,612 INFO  L134       CoverageAnalysis]: Checked inductivity of 30 backedges. 1 proven. 23 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:04:43,612 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:04:43,612 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [10] total 10
[2020-05-31 01:04:43,612 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:04:43,613 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:04:43,613 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:04:43,613 INFO  L87              Difference]: Start difference. First operand 19907 states and 22744 transitions. cyclomatic complexity: 2879 Second operand 10 states.
[2020-05-31 01:04:46,442 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:04:46,442 INFO  L93              Difference]: Finished difference Result 20203 states and 23495 transitions.
[2020-05-31 01:04:46,443 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-31 01:04:46,443 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20203 states and 23495 transitions.
[2020-05-31 01:04:46,494 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:46,553 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20203 states to 20203 states and 23495 transitions.
[2020-05-31 01:04:46,553 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1306
[2020-05-31 01:04:46,553 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1306
[2020-05-31 01:04:46,554 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20203 states and 23495 transitions.
[2020-05-31 01:04:46,567 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:04:46,567 INFO  L728         BuchiCegarLoop]: Abstraction has 20203 states and 23495 transitions.
[2020-05-31 01:04:46,576 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20203 states and 23495 transitions.
[2020-05-31 01:04:46,706 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20203 to 20031.
[2020-05-31 01:04:46,706 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20031 states.
[2020-05-31 01:04:46,737 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20031 states to 20031 states and 23226 transitions.
[2020-05-31 01:04:46,737 INFO  L751         BuchiCegarLoop]: Abstraction has 20031 states and 23226 transitions.
[2020-05-31 01:04:46,737 INFO  L631         BuchiCegarLoop]: Abstraction has 20031 states and 23226 transitions.
[2020-05-31 01:04:46,737 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-31 01:04:46,737 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20031 states and 23226 transitions.
[2020-05-31 01:04:46,759 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:04:46,759 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:04:46,759 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:04:46,761 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:04:46,761 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:04:46,764 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:04:46,765 INFO  L82        PathProgramCache]: Analyzing trace with hash -993702629, now seen corresponding path program 1 times
[2020-05-31 01:04:46,765 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:04:46,793 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:04:47,123 INFO  L134       CoverageAnalysis]: Checked inductivity of 88 backedges. 12 proven. 17 refuted. 0 times theorem prover too weak. 59 trivial. 0 not checked.
[2020-05-31 01:04:47,123 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:04:47,124 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [32] total 32
[2020-05-31 01:04:47,124 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:04:47,124 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 33 interpolants.
[2020-05-31 01:04:47,125 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=87, Invalid=969, Unknown=0, NotChecked=0, Total=1056
[2020-05-31 01:04:47,125 INFO  L87              Difference]: Start difference. First operand 20031 states and 23226 transitions. cyclomatic complexity: 3249 Second operand 33 states.
[2020-05-31 01:05:02,734 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:02,735 INFO  L93              Difference]: Finished difference Result 20327 states and 24099 transitions.
[2020-05-31 01:05:02,735 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 48 states. 
[2020-05-31 01:05:02,735 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20327 states and 24099 transitions.
[2020-05-31 01:05:02,788 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:02,852 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20327 states to 20327 states and 24099 transitions.
[2020-05-31 01:05:02,852 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1302
[2020-05-31 01:05:02,853 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1302
[2020-05-31 01:05:02,853 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20327 states and 24099 transitions.
[2020-05-31 01:05:02,867 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:02,867 INFO  L728         BuchiCegarLoop]: Abstraction has 20327 states and 24099 transitions.
[2020-05-31 01:05:02,876 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20327 states and 24099 transitions.
[2020-05-31 01:05:03,020 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20327 to 19648.
[2020-05-31 01:05:03,020 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19648 states.
[2020-05-31 01:05:03,051 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19648 states to 19648 states and 22595 transitions.
[2020-05-31 01:05:03,051 INFO  L751         BuchiCegarLoop]: Abstraction has 19648 states and 22595 transitions.
[2020-05-31 01:05:03,052 INFO  L631         BuchiCegarLoop]: Abstraction has 19648 states and 22595 transitions.
[2020-05-31 01:05:03,052 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-31 01:05:03,052 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19648 states and 22595 transitions.
[2020-05-31 01:05:03,074 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:03,075 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:03,075 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:03,076 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:03,076 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:03,079 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:03,079 INFO  L82        PathProgramCache]: Analyzing trace with hash -1483346418, now seen corresponding path program 1 times
[2020-05-31 01:05:03,079 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:03,089 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:03,135 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-31 01:05:03,135 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:05:03,135 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-31 01:05:03,136 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:03,136 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:05:03,136 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:05:03,136 INFO  L87              Difference]: Start difference. First operand 19648 states and 22595 transitions. cyclomatic complexity: 2994 Second operand 10 states.
[2020-05-31 01:05:05,413 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:05,413 INFO  L93              Difference]: Finished difference Result 19694 states and 22501 transitions.
[2020-05-31 01:05:05,413 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-31 01:05:05,414 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 19694 states and 22501 transitions.
[2020-05-31 01:05:05,450 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:05,501 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 19694 states to 19694 states and 22501 transitions.
[2020-05-31 01:05:05,501 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1300
[2020-05-31 01:05:05,502 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1300
[2020-05-31 01:05:05,502 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 19694 states and 22501 transitions.
[2020-05-31 01:05:05,514 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:05,514 INFO  L728         BuchiCegarLoop]: Abstraction has 19694 states and 22501 transitions.
[2020-05-31 01:05:05,522 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 19694 states and 22501 transitions.
[2020-05-31 01:05:05,643 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 19694 to 19588.
[2020-05-31 01:05:05,643 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19588 states.
[2020-05-31 01:05:05,674 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19588 states to 19588 states and 22364 transitions.
[2020-05-31 01:05:05,674 INFO  L751         BuchiCegarLoop]: Abstraction has 19588 states and 22364 transitions.
[2020-05-31 01:05:05,674 INFO  L631         BuchiCegarLoop]: Abstraction has 19588 states and 22364 transitions.
[2020-05-31 01:05:05,674 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-31 01:05:05,674 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19588 states and 22364 transitions.
[2020-05-31 01:05:05,696 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:05,696 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:05,697 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:05,698 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:05,698 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:05,702 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:05,702 INFO  L82        PathProgramCache]: Analyzing trace with hash 1238483947, now seen corresponding path program 1 times
[2020-05-31 01:05:05,702 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:05,720 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:05,897 INFO  L134       CoverageAnalysis]: Checked inductivity of 97 backedges. 15 proven. 21 refuted. 0 times theorem prover too weak. 61 trivial. 0 not checked.
[2020-05-31 01:05:05,897 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:05:05,897 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [30] total 30
[2020-05-31 01:05:05,898 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:05,898 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 31 interpolants.
[2020-05-31 01:05:05,898 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=87, Invalid=843, Unknown=0, NotChecked=0, Total=930
[2020-05-31 01:05:05,898 INFO  L87              Difference]: Start difference. First operand 19588 states and 22364 transitions. cyclomatic complexity: 2819 Second operand 31 states.
[2020-05-31 01:05:34,389 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:34,389 INFO  L93              Difference]: Finished difference Result 19987 states and 23197 transitions.
[2020-05-31 01:05:34,389 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 50 states. 
[2020-05-31 01:05:34,389 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 19987 states and 23197 transitions.
[2020-05-31 01:05:34,424 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 16
[2020-05-31 01:05:34,475 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 19987 states to 19987 states and 23197 transitions.
[2020-05-31 01:05:34,475 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1320
[2020-05-31 01:05:34,476 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1320
[2020-05-31 01:05:34,476 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 19987 states and 23197 transitions.
[2020-05-31 01:05:34,488 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:34,488 INFO  L728         BuchiCegarLoop]: Abstraction has 19987 states and 23197 transitions.
[2020-05-31 01:05:34,496 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 19987 states and 23197 transitions.
[2020-05-31 01:05:34,623 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 19987 to 19594.
[2020-05-31 01:05:34,623 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19594 states.
[2020-05-31 01:05:34,653 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19594 states to 19594 states and 22456 transitions.
[2020-05-31 01:05:34,653 INFO  L751         BuchiCegarLoop]: Abstraction has 19594 states and 22456 transitions.
[2020-05-31 01:05:34,653 INFO  L631         BuchiCegarLoop]: Abstraction has 19594 states and 22456 transitions.
[2020-05-31 01:05:34,653 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-31 01:05:34,653 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19594 states and 22456 transitions.
[2020-05-31 01:05:34,674 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:34,674 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:34,674 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:34,676 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:34,676 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND TRUE   choice == 4
[L2204]                    gas := gas - 21000;
[L2205]        COND TRUE   gas >= 0
[L2207]                    assume msgvalue_MSG == 0;
[L2208]        CALL        call withdrawAll_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L417]                     havoc __exception;
[L418]                     revert := false;
[L419]         COND FALSE  !(__exception)
[L439]         CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L439]         RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L440]                     assume !revert && gas >= 0;
[L2208]        RET         call withdrawAll_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:34,680 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:34,680 INFO  L82        PathProgramCache]: Analyzing trace with hash -1529189619, now seen corresponding path program 1 times
[2020-05-31 01:05:34,680 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:34,695 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:34,781 INFO  L134       CoverageAnalysis]: Checked inductivity of 140 backedges. 4 proven. 26 refuted. 0 times theorem prover too weak. 110 trivial. 0 not checked.
[2020-05-31 01:05:34,781 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:05:34,781 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [10] total 10
[2020-05-31 01:05:34,782 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:34,782 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:05:34,782 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:05:34,782 INFO  L87              Difference]: Start difference. First operand 19594 states and 22456 transitions. cyclomatic complexity: 2911 Second operand 10 states.
[2020-05-31 01:05:36,921 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:36,922 INFO  L93              Difference]: Finished difference Result 19803 states and 22728 transitions.
[2020-05-31 01:05:36,922 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-31 01:05:36,922 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 19803 states and 22728 transitions.
[2020-05-31 01:05:36,969 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:37,025 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 19803 states to 19803 states and 22728 transitions.
[2020-05-31 01:05:37,025 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1300
[2020-05-31 01:05:37,026 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1300
[2020-05-31 01:05:37,026 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 19803 states and 22728 transitions.
[2020-05-31 01:05:37,039 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:37,039 INFO  L728         BuchiCegarLoop]: Abstraction has 19803 states and 22728 transitions.
[2020-05-31 01:05:37,048 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 19803 states and 22728 transitions.
[2020-05-31 01:05:37,172 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 19803 to 19575.
[2020-05-31 01:05:37,172 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19575 states.
[2020-05-31 01:05:37,201 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19575 states to 19575 states and 22382 transitions.
[2020-05-31 01:05:37,202 INFO  L751         BuchiCegarLoop]: Abstraction has 19575 states and 22382 transitions.
[2020-05-31 01:05:37,202 INFO  L631         BuchiCegarLoop]: Abstraction has 19575 states and 22382 transitions.
[2020-05-31 01:05:37,202 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-31 01:05:37,202 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19575 states and 22382 transitions.
[2020-05-31 01:05:37,223 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-31 01:05:37,223 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:37,223 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:37,224 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:37,224 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND TRUE   choice == 6
[L2186]                    gas := gas - 21000;
[L2187]        COND TRUE   gas >= 0
[L2189]                    assume msgvalue_MSG == 0;
[L2190]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2190]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:37,227 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:37,228 INFO  L82        PathProgramCache]: Analyzing trace with hash -1936552802, now seen corresponding path program 1 times
[2020-05-31 01:05:37,228 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:37,239 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:37,296 INFO  L134       CoverageAnalysis]: Checked inductivity of 34 backedges. 24 proven. 0 refuted. 0 times theorem prover too weak. 10 trivial. 0 not checked.
[2020-05-31 01:05:37,296 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:05:37,296 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-31 01:05:37,297 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:37,297 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:05:37,297 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:05:37,297 INFO  L87              Difference]: Start difference. First operand 19575 states and 22382 transitions. cyclomatic complexity: 2856 Second operand 10 states.
[2020-05-31 01:05:43,941 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:43,942 INFO  L93              Difference]: Finished difference Result 21888 states and 25480 transitions.
[2020-05-31 01:05:43,942 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:05:43,942 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21888 states and 25480 transitions.
[2020-05-31 01:05:44,005 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 18
[2020-05-31 01:05:44,078 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21888 states to 21748 states and 25320 transitions.
[2020-05-31 01:05:44,078 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1358
[2020-05-31 01:05:44,079 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1358
[2020-05-31 01:05:44,079 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21748 states and 25320 transitions.
[2020-05-31 01:05:44,094 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:44,094 INFO  L728         BuchiCegarLoop]: Abstraction has 21748 states and 25320 transitions.
[2020-05-31 01:05:44,104 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21748 states and 25320 transitions.
[2020-05-31 01:05:44,317 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21748 to 21668.
[2020-05-31 01:05:44,317 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 21668 states.
[2020-05-31 01:05:44,351 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 21668 states to 21668 states and 25215 transitions.
[2020-05-31 01:05:44,351 INFO  L751         BuchiCegarLoop]: Abstraction has 21668 states and 25215 transitions.
[2020-05-31 01:05:44,351 INFO  L631         BuchiCegarLoop]: Abstraction has 21668 states and 25215 transitions.
[2020-05-31 01:05:44,351 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-31 01:05:44,351 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 21668 states and 25215 transitions.
[2020-05-31 01:05:44,372 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 18
[2020-05-31 01:05:44,372 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:44,372 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:44,373 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:44,374 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND TRUE   choice == 6
[L2186]                    gas := gas - 21000;
[L2187]        COND TRUE   gas >= 0
[L2189]                    assume msgvalue_MSG == 0;
[L2190]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2190]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND TRUE   choice == 5
[L2195]                    gas := gas - 21000;
[L2196]        COND TRUE   gas >= 0
[L2198]                    assume msgvalue_MSG == 0;
[L2199]        CALL        call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L379]                     havoc __exception;
[L380]                     revert := false;
[L381]         COND FALSE  !(__exception)
[L401]         CALL        call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L1491]                    gas := gas - 276;
[L1492]        COND FALSE  !(!(msgsender_MSG == superOwner_EscrowVault[this]))
[L1498]                    gas := gas - 367;
[L1499]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1505]                    gas := gas - 468;
[L1506]                    assume _amount_s320 >= 0;
[L1507]                    __var_6 := this;
[L1508]                    assume Balance[this] >= 0;
[L1509]                    assume _amount_s320 >= 0;
[L1510]        COND FALSE  !(!(_amount_s320 <= Balance[this] && _amount_s320 > 0))
[L1516]                    gas := gas - 36029;
[L1517]                    __var_7 := gas;
[L1518]        COND FALSE  !(gas > 2300)
[L1523]                    __var_7 := __var_7 - gas;
[L1524]                    assume _amount_s320 >= 0;
[L1525]        CALL        call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1525]        RET         call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1526]        COND FALSE  !(!__var_8)
[L1532]                    gas := __var_7 + gas;
[L1533]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L401]         RET         call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L402]                     assume !revert && gas >= 0;
[L2199]        RET         call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:44,390 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:44,390 INFO  L82        PathProgramCache]: Analyzing trace with hash -760151734, now seen corresponding path program 1 times
[2020-05-31 01:05:44,391 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:44,406 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:44,488 INFO  L134       CoverageAnalysis]: Checked inductivity of 163 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 159 trivial. 0 not checked.
[2020-05-31 01:05:44,488 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:05:44,488 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [5] imperfect sequences [] total 5
[2020-05-31 01:05:44,489 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:44,489 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 5 interpolants.
[2020-05-31 01:05:44,489 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=7, Invalid=13, Unknown=0, NotChecked=0, Total=20
[2020-05-31 01:05:44,489 INFO  L87              Difference]: Start difference. First operand 21668 states and 25215 transitions. cyclomatic complexity: 3596 Second operand 5 states.
[2020-05-31 01:05:44,584 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:44,584 INFO  L93              Difference]: Finished difference Result 21678 states and 25183 transitions.
[2020-05-31 01:05:44,584 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-31 01:05:44,584 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21678 states and 25183 transitions.
[2020-05-31 01:05:44,629 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 18
[2020-05-31 01:05:44,686 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21678 states to 21678 states and 25183 transitions.
[2020-05-31 01:05:44,687 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1346
[2020-05-31 01:05:44,687 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1346
[2020-05-31 01:05:44,687 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21678 states and 25183 transitions.
[2020-05-31 01:05:44,700 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:44,700 INFO  L728         BuchiCegarLoop]: Abstraction has 21678 states and 25183 transitions.
[2020-05-31 01:05:44,709 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21678 states and 25183 transitions.
[2020-05-31 01:05:44,835 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21678 to 21678.
[2020-05-31 01:05:44,835 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 21678 states.
[2020-05-31 01:05:44,865 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 21678 states to 21678 states and 25183 transitions.
[2020-05-31 01:05:44,865 INFO  L751         BuchiCegarLoop]: Abstraction has 21678 states and 25183 transitions.
[2020-05-31 01:05:44,865 INFO  L631         BuchiCegarLoop]: Abstraction has 21678 states and 25183 transitions.
[2020-05-31 01:05:44,865 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-31 01:05:44,865 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 21678 states and 25183 transitions.
[2020-05-31 01:05:44,887 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 18
[2020-05-31 01:05:44,887 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:44,887 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:44,888 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:44,888 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:44,891 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:44,891 INFO  L82        PathProgramCache]: Analyzing trace with hash -957057417, now seen corresponding path program 1 times
[2020-05-31 01:05:44,892 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:44,906 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:44,988 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 2 proven. 2 refuted. 0 times theorem prover too weak. 77 trivial. 0 not checked.
[2020-05-31 01:05:44,989 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:05:44,989 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [8] total 8
[2020-05-31 01:05:44,989 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:44,989 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 8 interpolants.
[2020-05-31 01:05:44,989 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=13, Invalid=43, Unknown=0, NotChecked=0, Total=56
[2020-05-31 01:05:44,989 INFO  L87              Difference]: Start difference. First operand 21678 states and 25183 transitions. cyclomatic complexity: 3554 Second operand 8 states.
[2020-05-31 01:05:51,182 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:05:51,182 INFO  L93              Difference]: Finished difference Result 56433 states and 66068 transitions.
[2020-05-31 01:05:51,182 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 16 states. 
[2020-05-31 01:05:51,182 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 56433 states and 66068 transitions.
[2020-05-31 01:05:51,353 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 48
[2020-05-31 01:05:51,588 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 56433 states to 56433 states and 66068 transitions.
[2020-05-31 01:05:51,588 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3438
[2020-05-31 01:05:51,590 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3438
[2020-05-31 01:05:51,590 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 56433 states and 66068 transitions.
[2020-05-31 01:05:51,637 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:05:51,637 INFO  L728         BuchiCegarLoop]: Abstraction has 56433 states and 66068 transitions.
[2020-05-31 01:05:51,664 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 56433 states and 66068 transitions.
[2020-05-31 01:05:52,114 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 56433 to 55993.
[2020-05-31 01:05:52,114 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 55993 states.
[2020-05-31 01:05:52,224 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 55993 states to 55993 states and 65542 transitions.
[2020-05-31 01:05:52,224 INFO  L751         BuchiCegarLoop]: Abstraction has 55993 states and 65542 transitions.
[2020-05-31 01:05:52,224 INFO  L631         BuchiCegarLoop]: Abstraction has 55993 states and 65542 transitions.
[2020-05-31 01:05:52,224 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-31 01:05:52,224 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 55993 states and 65542 transitions.
[2020-05-31 01:05:52,295 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 48
[2020-05-31 01:05:52,295 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:05:52,295 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:05:52,297 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:05:52,297 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND TRUE   DType[to] == Ownable
[L1854]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:05:52,300 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:05:52,301 INFO  L82        PathProgramCache]: Analyzing trace with hash -442971408, now seen corresponding path program 1 times
[2020-05-31 01:05:52,301 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:05:52,317 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:05:52,402 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 2 proven. 2 refuted. 0 times theorem prover too weak. 77 trivial. 0 not checked.
[2020-05-31 01:05:52,402 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:05:52,402 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [8] total 8
[2020-05-31 01:05:52,402 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:05:52,403 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 8 interpolants.
[2020-05-31 01:05:52,403 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=13, Invalid=43, Unknown=0, NotChecked=0, Total=56
[2020-05-31 01:05:52,403 INFO  L87              Difference]: Start difference. First operand 55993 states and 65542 transitions. cyclomatic complexity: 9670 Second operand 8 states.
[2020-05-31 01:06:00,938 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:00,938 INFO  L93              Difference]: Finished difference Result 69238 states and 80887 transitions.
[2020-05-31 01:06:00,939 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 16 states. 
[2020-05-31 01:06:00,939 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 69238 states and 80887 transitions.
[2020-05-31 01:06:01,127 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:01,399 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 69238 states to 69238 states and 80887 transitions.
[2020-05-31 01:06:01,400 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 4140
[2020-05-31 01:06:01,402 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 4140
[2020-05-31 01:06:01,402 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 69238 states and 80887 transitions.
[2020-05-31 01:06:01,456 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:01,456 INFO  L728         BuchiCegarLoop]: Abstraction has 69238 states and 80887 transitions.
[2020-05-31 01:06:01,487 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 69238 states and 80887 transitions.
[2020-05-31 01:06:01,990 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 69238 to 68678.
[2020-05-31 01:06:01,990 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 68678 states.
[2020-05-31 01:06:02,119 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 68678 states to 68678 states and 80233 transitions.
[2020-05-31 01:06:02,119 INFO  L751         BuchiCegarLoop]: Abstraction has 68678 states and 80233 transitions.
[2020-05-31 01:06:02,119 INFO  L631         BuchiCegarLoop]: Abstraction has 68678 states and 80233 transitions.
[2020-05-31 01:06:02,119 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-31 01:06:02,119 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 68678 states and 80233 transitions.
[2020-05-31 01:06:02,203 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:02,203 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:02,203 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:02,205 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:02,205 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND TRUE   choice == 6
[L2186]                    gas := gas - 21000;
[L2187]        COND TRUE   gas >= 0
[L2189]                    assume msgvalue_MSG == 0;
[L2190]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2190]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND TRUE   choice == 4
[L2204]                    gas := gas - 21000;
[L2205]        COND TRUE   gas >= 0
[L2207]                    assume msgvalue_MSG == 0;
[L2208]        CALL        call withdrawAll_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L417]                     havoc __exception;
[L418]                     revert := false;
[L419]         COND FALSE  !(__exception)
[L439]         CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND TRUE   DType[to] == Ownable
[L1854]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L439]         RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L440]                     assume !revert && gas >= 0;
[L2208]        RET         call withdrawAll_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:02,209 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:02,209 INFO  L82        PathProgramCache]: Analyzing trace with hash -1391118906, now seen corresponding path program 1 times
[2020-05-31 01:06:02,209 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:02,226 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:02,327 INFO  L134       CoverageAnalysis]: Checked inductivity of 168 backedges. 24 proven. 2 refuted. 0 times theorem prover too weak. 142 trivial. 0 not checked.
[2020-05-31 01:06:02,328 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:02,328 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-31 01:06:02,328 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:02,329 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-31 01:06:02,329 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-31 01:06:02,329 INFO  L87              Difference]: Start difference. First operand 68678 states and 80233 transitions. cyclomatic complexity: 11710 Second operand 11 states.
[2020-05-31 01:06:08,150 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:08,150 INFO  L93              Difference]: Finished difference Result 68678 states and 79897 transitions.
[2020-05-31 01:06:08,150 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:06:08,150 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 68678 states and 79897 transitions.
[2020-05-31 01:06:08,346 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:08,620 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 68678 states to 68678 states and 79897 transitions.
[2020-05-31 01:06:08,620 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 4074
[2020-05-31 01:06:08,622 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 4074
[2020-05-31 01:06:08,623 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 68678 states and 79897 transitions.
[2020-05-31 01:06:08,676 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:08,676 INFO  L728         BuchiCegarLoop]: Abstraction has 68678 states and 79897 transitions.
[2020-05-31 01:06:08,710 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 68678 states and 79897 transitions.
[2020-05-31 01:06:09,969 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 68678 to 68678.
[2020-05-31 01:06:09,969 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 68678 states.
[2020-05-31 01:06:10,092 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 68678 states to 68678 states and 79897 transitions.
[2020-05-31 01:06:10,092 INFO  L751         BuchiCegarLoop]: Abstraction has 68678 states and 79897 transitions.
[2020-05-31 01:06:10,092 INFO  L631         BuchiCegarLoop]: Abstraction has 68678 states and 79897 transitions.
[2020-05-31 01:06:10,093 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-31 01:06:10,093 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 68678 states and 79897 transitions.
[2020-05-31 01:06:10,176 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:10,176 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:10,176 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:10,177 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:10,178 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND FALSE  !(Balance[from] >= amount)
[L1997]                    success := false;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:10,190 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:10,191 INFO  L82        PathProgramCache]: Analyzing trace with hash 1122610113, now seen corresponding path program 1 times
[2020-05-31 01:06:10,191 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:10,204 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:10,269 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 77 trivial. 0 not checked.
[2020-05-31 01:06:10,269 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:06:10,269 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-31 01:06:10,269 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:10,269 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-31 01:06:10,269 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-31 01:06:10,269 INFO  L87              Difference]: Start difference. First operand 68678 states and 79897 transitions. cyclomatic complexity: 11374 Second operand 4 states.
[2020-05-31 01:06:10,474 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:10,474 INFO  L93              Difference]: Finished difference Result 68806 states and 79961 transitions.
[2020-05-31 01:06:10,474 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-31 01:06:10,475 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 68806 states and 79961 transitions.
[2020-05-31 01:06:10,662 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:10,932 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 68806 states to 68678 states and 79833 transitions.
[2020-05-31 01:06:10,932 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 4074
[2020-05-31 01:06:10,934 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 4074
[2020-05-31 01:06:10,935 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 68678 states and 79833 transitions.
[2020-05-31 01:06:10,987 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:10,987 INFO  L728         BuchiCegarLoop]: Abstraction has 68678 states and 79833 transitions.
[2020-05-31 01:06:11,019 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 68678 states and 79833 transitions.
[2020-05-31 01:06:11,537 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 68678 to 68678.
[2020-05-31 01:06:11,537 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 68678 states.
[2020-05-31 01:06:11,671 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 68678 states to 68678 states and 79833 transitions.
[2020-05-31 01:06:11,671 INFO  L751         BuchiCegarLoop]: Abstraction has 68678 states and 79833 transitions.
[2020-05-31 01:06:11,671 INFO  L631         BuchiCegarLoop]: Abstraction has 68678 states and 79833 transitions.
[2020-05-31 01:06:11,671 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-31 01:06:11,671 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 68678 states and 79833 transitions.
[2020-05-31 01:06:11,758 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 60
[2020-05-31 01:06:11,758 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:11,758 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:11,760 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:11,760 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND TRUE   DType[to] == Ownable
[L1854]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:11,764 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:11,764 INFO  L82        PathProgramCache]: Analyzing trace with hash 176817467, now seen corresponding path program 1 times
[2020-05-31 01:06:11,765 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:11,780 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:11,866 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 34 proven. 29 refuted. 0 times theorem prover too weak. 18 trivial. 0 not checked.
[2020-05-31 01:06:11,867 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:11,867 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-31 01:06:11,867 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:11,867 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-31 01:06:11,867 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=19, Invalid=91, Unknown=0, NotChecked=0, Total=110
[2020-05-31 01:06:11,867 INFO  L87              Difference]: Start difference. First operand 68678 states and 79833 transitions. cyclomatic complexity: 11310 Second operand 11 states.
[2020-05-31 01:06:14,231 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:14,231 INFO  L93              Difference]: Finished difference Result 61550 states and 70180 transitions.
[2020-05-31 01:06:14,231 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-31 01:06:14,232 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 61550 states and 70180 transitions.
[2020-05-31 01:06:14,389 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-31 01:06:14,521 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 61550 states to 39903 states and 45631 transitions.
[2020-05-31 01:06:14,521 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3130
[2020-05-31 01:06:14,523 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3286
[2020-05-31 01:06:14,523 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 39903 states and 45631 transitions.
[2020-05-31 01:06:14,549 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:14,549 INFO  L728         BuchiCegarLoop]: Abstraction has 39903 states and 45631 transitions.
[2020-05-31 01:06:14,566 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 39903 states and 45631 transitions.
[2020-05-31 01:06:14,948 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 39903 to 35382.
[2020-05-31 01:06:14,948 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 35382 states.
[2020-05-31 01:06:15,002 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 35382 states to 35382 states and 40653 transitions.
[2020-05-31 01:06:15,002 INFO  L751         BuchiCegarLoop]: Abstraction has 35382 states and 40653 transitions.
[2020-05-31 01:06:15,002 INFO  L631         BuchiCegarLoop]: Abstraction has 35382 states and 40653 transitions.
[2020-05-31 01:06:15,002 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-31 01:06:15,002 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 35382 states and 40653 transitions.
[2020-05-31 01:06:15,041 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-31 01:06:15,041 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:15,041 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:15,042 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:15,043 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:15,050 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:15,050 INFO  L82        PathProgramCache]: Analyzing trace with hash 345575988, now seen corresponding path program 1 times
[2020-05-31 01:06:15,050 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:15,063 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:15,134 INFO  L134       CoverageAnalysis]: Checked inductivity of 58 backedges. 2 proven. 29 refuted. 0 times theorem prover too weak. 27 trivial. 0 not checked.
[2020-05-31 01:06:15,134 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:15,134 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-31 01:06:15,134 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:15,135 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-31 01:06:15,135 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=23, Invalid=109, Unknown=0, NotChecked=0, Total=132
[2020-05-31 01:06:15,135 INFO  L87              Difference]: Start difference. First operand 35382 states and 40653 transitions. cyclomatic complexity: 5361 Second operand 12 states.
[2020-05-31 01:06:16,373 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:16,373 INFO  L93              Difference]: Finished difference Result 35542 states and 40801 transitions.
[2020-05-31 01:06:16,374 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-31 01:06:16,374 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 35542 states and 40801 transitions.
[2020-05-31 01:06:16,452 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-31 01:06:16,565 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 35542 states to 35542 states and 40801 transitions.
[2020-05-31 01:06:16,565 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1700
[2020-05-31 01:06:16,566 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1700
[2020-05-31 01:06:16,566 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 35542 states and 40801 transitions.
[2020-05-31 01:06:16,590 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:16,590 INFO  L728         BuchiCegarLoop]: Abstraction has 35542 states and 40801 transitions.
[2020-05-31 01:06:16,606 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 35542 states and 40801 transitions.
[2020-05-31 01:06:16,821 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 35542 to 35382.
[2020-05-31 01:06:16,822 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 35382 states.
[2020-05-31 01:06:16,877 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 35382 states to 35382 states and 40609 transitions.
[2020-05-31 01:06:16,877 INFO  L751         BuchiCegarLoop]: Abstraction has 35382 states and 40609 transitions.
[2020-05-31 01:06:16,877 INFO  L631         BuchiCegarLoop]: Abstraction has 35382 states and 40609 transitions.
[2020-05-31 01:06:16,877 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-31 01:06:16,877 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 35382 states and 40609 transitions.
[2020-05-31 01:06:16,916 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-31 01:06:16,916 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:16,916 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:16,917 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:16,918 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND TRUE   choice == 6
[L2186]                    gas := gas - 21000;
[L2187]        COND TRUE   gas >= 0
[L2189]                    assume msgvalue_MSG == 0;
[L2190]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2190]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND TRUE   choice == 3
[L2213]                    gas := gas - 21000;
[L2214]        COND TRUE   gas >= 0
[L2216]                    assume msgvalue_MSG == 0;
[L2217]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2217]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:16,921 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:16,921 INFO  L82        PathProgramCache]: Analyzing trace with hash 233551268, now seen corresponding path program 1 times
[2020-05-31 01:06:16,922 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:16,935 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:17,013 INFO  L134       CoverageAnalysis]: Checked inductivity of 86 backedges. 31 proven. 0 refuted. 0 times theorem prover too weak. 55 trivial. 0 not checked.
[2020-05-31 01:06:17,014 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:06:17,014 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-31 01:06:17,014 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:17,014 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-31 01:06:17,014 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-31 01:06:17,014 INFO  L87              Difference]: Start difference. First operand 35382 states and 40609 transitions. cyclomatic complexity: 5317 Second operand 10 states.
[2020-05-31 01:06:18,154 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:18,154 INFO  L93              Difference]: Finished difference Result 20846 states and 23587 transitions.
[2020-05-31 01:06:18,154 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-31 01:06:18,154 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20846 states and 23587 transitions.
[2020-05-31 01:06:18,200 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-31 01:06:18,258 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20846 states to 19458 states and 22099 transitions.
[2020-05-31 01:06:18,258 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1585
[2020-05-31 01:06:18,259 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1585
[2020-05-31 01:06:18,259 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 19458 states and 22099 transitions.
[2020-05-31 01:06:18,270 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:18,270 INFO  L728         BuchiCegarLoop]: Abstraction has 19458 states and 22099 transitions.
[2020-05-31 01:06:18,277 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 19458 states and 22099 transitions.
[2020-05-31 01:06:18,370 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 19458 to 17892.
[2020-05-31 01:06:18,371 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 17892 states.
[2020-05-31 01:06:18,391 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 17892 states to 17892 states and 20176 transitions.
[2020-05-31 01:06:18,391 INFO  L751         BuchiCegarLoop]: Abstraction has 17892 states and 20176 transitions.
[2020-05-31 01:06:18,391 INFO  L631         BuchiCegarLoop]: Abstraction has 17892 states and 20176 transitions.
[2020-05-31 01:06:18,391 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-31 01:06:18,391 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 17892 states and 20176 transitions.
[2020-05-31 01:06:18,408 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:18,408 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:18,408 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:18,409 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:18,409 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:18,412 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:18,412 INFO  L82        PathProgramCache]: Analyzing trace with hash -2003635571, now seen corresponding path program 1 times
[2020-05-31 01:06:18,412 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:18,431 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:18,729 INFO  L134       CoverageAnalysis]: Checked inductivity of 106 backedges. 7 proven. 21 refuted. 0 times theorem prover too weak. 78 trivial. 0 not checked.
[2020-05-31 01:06:18,729 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:18,730 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-31 01:06:18,730 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:18,730 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-31 01:06:18,730 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=184, Invalid=1708, Unknown=0, NotChecked=0, Total=1892
[2020-05-31 01:06:18,730 INFO  L87              Difference]: Start difference. First operand 17892 states and 20176 transitions. cyclomatic complexity: 2332 Second operand 44 states.
[2020-05-31 01:06:25,771 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:25,772 INFO  L93              Difference]: Finished difference Result 18909 states and 21691 transitions.
[2020-05-31 01:06:25,772 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 57 states. 
[2020-05-31 01:06:25,772 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 18909 states and 21691 transitions.
[2020-05-31 01:06:25,816 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:25,874 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 18909 states to 18901 states and 21660 transitions.
[2020-05-31 01:06:25,874 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1110
[2020-05-31 01:06:25,874 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1110
[2020-05-31 01:06:25,874 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18901 states and 21660 transitions.
[2020-05-31 01:06:25,886 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:25,886 INFO  L728         BuchiCegarLoop]: Abstraction has 18901 states and 21660 transitions.
[2020-05-31 01:06:25,893 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18901 states and 21660 transitions.
[2020-05-31 01:06:25,986 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18901 to 18216.
[2020-05-31 01:06:25,986 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 18216 states.
[2020-05-31 01:06:26,008 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 18216 states to 18216 states and 20722 transitions.
[2020-05-31 01:06:26,008 INFO  L751         BuchiCegarLoop]: Abstraction has 18216 states and 20722 transitions.
[2020-05-31 01:06:26,008 INFO  L631         BuchiCegarLoop]: Abstraction has 18216 states and 20722 transitions.
[2020-05-31 01:06:26,008 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-05-31 01:06:26,008 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 18216 states and 20722 transitions.
[2020-05-31 01:06:26,025 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:26,025 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:26,025 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:26,026 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:26,026 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:26,028 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:26,028 INFO  L82        PathProgramCache]: Analyzing trace with hash -1607818233, now seen corresponding path program 1 times
[2020-05-31 01:06:26,028 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:26,037 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:26,081 INFO  L134       CoverageAnalysis]: Checked inductivity of 88 backedges. 1 proven. 0 refuted. 0 times theorem prover too weak. 87 trivial. 0 not checked.
[2020-05-31 01:06:26,081 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-31 01:06:26,081 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-31 01:06:26,082 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:26,082 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-31 01:06:26,082 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-31 01:06:26,082 INFO  L87              Difference]: Start difference. First operand 18216 states and 20722 transitions. cyclomatic complexity: 2564 Second operand 3 states.
[2020-05-31 01:06:26,125 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:26,125 INFO  L93              Difference]: Finished difference Result 18228 states and 20725 transitions.
[2020-05-31 01:06:26,125 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-31 01:06:26,126 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 18228 states and 20725 transitions.
[2020-05-31 01:06:26,158 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:26,207 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 18228 states to 18228 states and 20725 transitions.
[2020-05-31 01:06:26,207 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1044
[2020-05-31 01:06:26,208 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1044
[2020-05-31 01:06:26,208 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18228 states and 20725 transitions.
[2020-05-31 01:06:26,217 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:26,217 INFO  L728         BuchiCegarLoop]: Abstraction has 18228 states and 20725 transitions.
[2020-05-31 01:06:26,223 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18228 states and 20725 transitions.
[2020-05-31 01:06:26,307 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18228 to 18216.
[2020-05-31 01:06:26,307 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 18216 states.
[2020-05-31 01:06:26,329 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 18216 states to 18216 states and 20706 transitions.
[2020-05-31 01:06:26,329 INFO  L751         BuchiCegarLoop]: Abstraction has 18216 states and 20706 transitions.
[2020-05-31 01:06:26,329 INFO  L631         BuchiCegarLoop]: Abstraction has 18216 states and 20706 transitions.
[2020-05-31 01:06:26,329 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-05-31 01:06:26,329 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 18216 states and 20706 transitions.
[2020-05-31 01:06:26,346 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:26,346 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:26,346 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:26,347 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:26,347 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]  CALL        call CorralChoice_EscrowVault(this);
[L2146]              havoc msgsender_MSG;
[L2147]              havoc msgvalue_MSG;
[L2148]              havoc choice;
[L2149]              havoc newOwner_s150;
[L2150]              havoc _superOwner_s224;
[L2151]              havoc _beneficiary_s224;
[L2152]              havoc investor_s256;
[L2153]              havoc _amount_s320;
[L2154]              havoc investor_s431;
[L2155]              havoc tmpNow;
[L2156]              havoc gas;
[L2157]              assume gas > 4000000 && gas <= 8000000;
[L2158]              tmpNow := now;
[L2159]              havoc now;
[L2160]              assume now > tmpNow;
[L2161]              assume msgsender_MSG != null;
[L2162]              assume DType[msgsender_MSG] != SafeMath;
[L2163]              assume DType[msgsender_MSG] != Ownable;
[L2164]              assume DType[msgsender_MSG] != EscrowVault;
[L2165]              Alloc[msgsender_MSG] := true;
[L2166]  COND FALSE  !(choice == 8)
[L2175]  COND FALSE  !(choice == 7)
[L2184]  COND FALSE  !(choice == 6)
[L2193]  COND FALSE  !(choice == 5)
[L2202]  COND FALSE  !(choice == 4)
[L2211]  COND FALSE  !(choice == 3)
[L2220]  COND FALSE  !(choice == 2)
[L2229]  COND FALSE  !(choice == 1)
[L2259]  RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:26,349 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:26,349 INFO  L82        PathProgramCache]: Analyzing trace with hash -737054262, now seen corresponding path program 1 times
[2020-05-31 01:06:26,350 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:26,364 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:26,705 INFO  L134       CoverageAnalysis]: Checked inductivity of 44 backedges. 0 proven. 11 refuted. 0 times theorem prover too weak. 33 trivial. 0 not checked.
[2020-05-31 01:06:26,705 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:26,705 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-05-31 01:06:26,706 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:26,706 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-05-31 01:06:26,706 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=99, Invalid=1383, Unknown=0, NotChecked=0, Total=1482
[2020-05-31 01:06:26,706 INFO  L87              Difference]: Start difference. First operand 18216 states and 20706 transitions. cyclomatic complexity: 2548 Second operand 39 states.
[2020-05-31 01:06:39,766 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:39,767 INFO  L93              Difference]: Finished difference Result 20744 states and 24110 transitions.
[2020-05-31 01:06:39,767 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-31 01:06:39,767 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20744 states and 24110 transitions.
[2020-05-31 01:06:39,810 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:39,867 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20744 states to 20744 states and 24108 transitions.
[2020-05-31 01:06:39,867 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1064
[2020-05-31 01:06:39,867 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1064
[2020-05-31 01:06:39,867 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20744 states and 24108 transitions.
[2020-05-31 01:06:39,879 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:39,879 INFO  L728         BuchiCegarLoop]: Abstraction has 20744 states and 24108 transitions.
[2020-05-31 01:06:39,885 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20744 states and 24108 transitions.
[2020-05-31 01:06:39,992 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20744 to 20412.
[2020-05-31 01:06:39,992 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20412 states.
[2020-05-31 01:06:40,023 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20412 states to 20412 states and 23655 transitions.
[2020-05-31 01:06:40,023 INFO  L751         BuchiCegarLoop]: Abstraction has 20412 states and 23655 transitions.
[2020-05-31 01:06:40,023 INFO  L631         BuchiCegarLoop]: Abstraction has 20412 states and 23655 transitions.
[2020-05-31 01:06:40,024 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-05-31 01:06:40,024 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20412 states and 23655 transitions.
[2020-05-31 01:06:40,044 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:40,045 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:40,045 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:40,046 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:40,046 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:40,049 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:40,049 INFO  L82        PathProgramCache]: Analyzing trace with hash 1436567679, now seen corresponding path program 1 times
[2020-05-31 01:06:40,049 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:40,078 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:40,477 INFO  L134       CoverageAnalysis]: Checked inductivity of 142 backedges. 14 proven. 48 refuted. 0 times theorem prover too weak. 80 trivial. 0 not checked.
[2020-05-31 01:06:40,477 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:40,477 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [46] total 46
[2020-05-31 01:06:40,477 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:40,477 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 47 interpolants.
[2020-05-31 01:06:40,478 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=190, Invalid=1972, Unknown=0, NotChecked=0, Total=2162
[2020-05-31 01:06:40,478 INFO  L87              Difference]: Start difference. First operand 20412 states and 23655 transitions. cyclomatic complexity: 3311 Second operand 47 states.
[2020-05-31 01:06:49,390 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:06:49,390 INFO  L93              Difference]: Finished difference Result 21261 states and 25056 transitions.
[2020-05-31 01:06:49,391 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 59 states. 
[2020-05-31 01:06:49,391 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21261 states and 25056 transitions.
[2020-05-31 01:06:49,446 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:49,512 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21261 states to 21253 states and 25025 transitions.
[2020-05-31 01:06:49,513 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1110
[2020-05-31 01:06:49,513 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1110
[2020-05-31 01:06:49,513 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21253 states and 25025 transitions.
[2020-05-31 01:06:49,528 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:06:49,528 INFO  L728         BuchiCegarLoop]: Abstraction has 21253 states and 25025 transitions.
[2020-05-31 01:06:49,536 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21253 states and 25025 transitions.
[2020-05-31 01:06:49,654 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21253 to 20438.
[2020-05-31 01:06:49,654 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20438 states.
[2020-05-31 01:06:49,688 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20438 states to 20438 states and 23757 transitions.
[2020-05-31 01:06:49,688 INFO  L751         BuchiCegarLoop]: Abstraction has 20438 states and 23757 transitions.
[2020-05-31 01:06:49,688 INFO  L631         BuchiCegarLoop]: Abstraction has 20438 states and 23757 transitions.
[2020-05-31 01:06:49,688 INFO  L445         BuchiCegarLoop]: ======== Iteration 32============
[2020-05-31 01:06:49,689 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20438 states and 23757 transitions.
[2020-05-31 01:06:49,711 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:06:49,711 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:06:49,711 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:06:49,712 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:06:49,712 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:06:49,715 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:06:49,715 INFO  L82        PathProgramCache]: Analyzing trace with hash 1960372555, now seen corresponding path program 1 times
[2020-05-31 01:06:49,716 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:06:49,734 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:06:50,128 INFO  L134       CoverageAnalysis]: Checked inductivity of 44 backedges. 0 proven. 36 refuted. 0 times theorem prover too weak. 8 trivial. 0 not checked.
[2020-05-31 01:06:50,128 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:06:50,129 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-31 01:06:50,129 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:06:50,129 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-31 01:06:50,129 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=2206, Unknown=0, NotChecked=0, Total=2352
[2020-05-31 01:06:50,129 INFO  L87              Difference]: Start difference. First operand 20438 states and 23757 transitions. cyclomatic complexity: 3394 Second operand 49 states.
[2020-05-31 01:07:05,433 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:05,433 INFO  L93              Difference]: Finished difference Result 21339 states and 25452 transitions.
[2020-05-31 01:07:05,433 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 55 states. 
[2020-05-31 01:07:05,433 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21339 states and 25452 transitions.
[2020-05-31 01:07:05,477 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:05,542 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21339 states to 21339 states and 25452 transitions.
[2020-05-31 01:07:05,542 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1110
[2020-05-31 01:07:05,543 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1110
[2020-05-31 01:07:05,543 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21339 states and 25452 transitions.
[2020-05-31 01:07:05,558 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:05,558 INFO  L728         BuchiCegarLoop]: Abstraction has 21339 states and 25452 transitions.
[2020-05-31 01:07:05,565 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21339 states and 25452 transitions.
[2020-05-31 01:07:05,682 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21339 to 20833.
[2020-05-31 01:07:05,682 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20833 states.
[2020-05-31 01:07:05,716 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20833 states to 20833 states and 24595 transitions.
[2020-05-31 01:07:05,716 INFO  L751         BuchiCegarLoop]: Abstraction has 20833 states and 24595 transitions.
[2020-05-31 01:07:05,717 INFO  L631         BuchiCegarLoop]: Abstraction has 20833 states and 24595 transitions.
[2020-05-31 01:07:05,717 INFO  L445         BuchiCegarLoop]: ======== Iteration 33============
[2020-05-31 01:07:05,717 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20833 states and 24595 transitions.
[2020-05-31 01:07:05,738 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:05,738 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:07:05,738 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:07:05,739 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:07:05,739 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:07:05,742 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:07:05,743 INFO  L82        PathProgramCache]: Analyzing trace with hash -1728309236, now seen corresponding path program 1 times
[2020-05-31 01:07:05,743 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:07:05,780 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:07:06,093 INFO  L134       CoverageAnalysis]: Checked inductivity of 188 backedges. 19 proven. 38 refuted. 0 times theorem prover too weak. 131 trivial. 0 not checked.
[2020-05-31 01:07:06,093 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:07:06,093 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-31 01:07:06,093 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:07:06,093 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-31 01:07:06,094 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=102, Invalid=1158, Unknown=0, NotChecked=0, Total=1260
[2020-05-31 01:07:06,094 INFO  L87              Difference]: Start difference. First operand 20833 states and 24595 transitions. cyclomatic complexity: 3858 Second operand 36 states.
[2020-05-31 01:07:11,983 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:11,983 INFO  L93              Difference]: Finished difference Result 20989 states and 24957 transitions.
[2020-05-31 01:07:11,983 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 41 states. 
[2020-05-31 01:07:11,983 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20989 states and 24957 transitions.
[2020-05-31 01:07:12,026 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:12,090 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20989 states to 20977 states and 24919 transitions.
[2020-05-31 01:07:12,090 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1054
[2020-05-31 01:07:12,091 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1054
[2020-05-31 01:07:12,091 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20977 states and 24919 transitions.
[2020-05-31 01:07:12,105 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:12,105 INFO  L728         BuchiCegarLoop]: Abstraction has 20977 states and 24919 transitions.
[2020-05-31 01:07:12,112 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20977 states and 24919 transitions.
[2020-05-31 01:07:12,221 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20977 to 20753.
[2020-05-31 01:07:12,221 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20753 states.
[2020-05-31 01:07:12,255 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20753 states to 20753 states and 24277 transitions.
[2020-05-31 01:07:12,255 INFO  L751         BuchiCegarLoop]: Abstraction has 20753 states and 24277 transitions.
[2020-05-31 01:07:12,255 INFO  L631         BuchiCegarLoop]: Abstraction has 20753 states and 24277 transitions.
[2020-05-31 01:07:12,255 INFO  L445         BuchiCegarLoop]: ======== Iteration 34============
[2020-05-31 01:07:12,255 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20753 states and 24277 transitions.
[2020-05-31 01:07:12,277 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:12,277 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:07:12,277 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:07:12,278 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:07:12,278 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:07:12,281 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:07:12,281 INFO  L82        PathProgramCache]: Analyzing trace with hash 1921373849, now seen corresponding path program 1 times
[2020-05-31 01:07:12,281 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:07:12,316 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:07:12,630 INFO  L134       CoverageAnalysis]: Checked inductivity of 170 backedges. 13 proven. 32 refuted. 0 times theorem prover too weak. 125 trivial. 0 not checked.
[2020-05-31 01:07:12,631 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:07:12,631 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [40] total 40
[2020-05-31 01:07:12,631 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:07:12,631 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 41 interpolants.
[2020-05-31 01:07:12,631 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=104, Invalid=1536, Unknown=0, NotChecked=0, Total=1640
[2020-05-31 01:07:12,631 INFO  L87              Difference]: Start difference. First operand 20753 states and 24277 transitions. cyclomatic complexity: 3606 Second operand 41 states.
[2020-05-31 01:07:20,136 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:20,136 INFO  L93              Difference]: Finished difference Result 20851 states and 24379 transitions.
[2020-05-31 01:07:20,136 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 41 states. 
[2020-05-31 01:07:20,136 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20851 states and 24379 transitions.
[2020-05-31 01:07:20,176 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:20,232 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20851 states to 20851 states and 24377 transitions.
[2020-05-31 01:07:20,232 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1054
[2020-05-31 01:07:20,233 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1054
[2020-05-31 01:07:20,233 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20851 states and 24377 transitions.
[2020-05-31 01:07:20,246 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:20,246 INFO  L728         BuchiCegarLoop]: Abstraction has 20851 states and 24377 transitions.
[2020-05-31 01:07:20,252 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20851 states and 24377 transitions.
[2020-05-31 01:07:20,365 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20851 to 20268.
[2020-05-31 01:07:20,365 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20268 states.
[2020-05-31 01:07:20,394 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20268 states to 20268 states and 23289 transitions.
[2020-05-31 01:07:20,395 INFO  L751         BuchiCegarLoop]: Abstraction has 20268 states and 23289 transitions.
[2020-05-31 01:07:20,395 INFO  L631         BuchiCegarLoop]: Abstraction has 20268 states and 23289 transitions.
[2020-05-31 01:07:20,395 INFO  L445         BuchiCegarLoop]: ======== Iteration 35============
[2020-05-31 01:07:20,395 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20268 states and 23289 transitions.
[2020-05-31 01:07:20,416 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:20,416 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:07:20,416 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:07:20,417 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:07:20,417 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:07:20,420 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:07:20,420 INFO  L82        PathProgramCache]: Analyzing trace with hash 1292227513, now seen corresponding path program 1 times
[2020-05-31 01:07:20,421 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:07:20,440 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:07:20,760 INFO  L134       CoverageAnalysis]: Checked inductivity of 134 backedges. 15 proven. 32 refuted. 0 times theorem prover too weak. 87 trivial. 0 not checked.
[2020-05-31 01:07:20,760 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:07:20,760 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-31 01:07:20,761 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:07:20,761 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-31 01:07:20,761 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=131, Invalid=1761, Unknown=0, NotChecked=0, Total=1892
[2020-05-31 01:07:20,761 INFO  L87              Difference]: Start difference. First operand 20268 states and 23289 transitions. cyclomatic complexity: 3078 Second operand 44 states.
[2020-05-31 01:07:38,367 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:38,367 INFO  L93              Difference]: Finished difference Result 20642 states and 23774 transitions.
[2020-05-31 01:07:38,367 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 63 states. 
[2020-05-31 01:07:38,367 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20642 states and 23774 transitions.
[2020-05-31 01:07:38,401 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:38,451 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20642 states to 20642 states and 23772 transitions.
[2020-05-31 01:07:38,451 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1064
[2020-05-31 01:07:38,452 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1064
[2020-05-31 01:07:38,452 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20642 states and 23772 transitions.
[2020-05-31 01:07:38,463 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:38,463 INFO  L728         BuchiCegarLoop]: Abstraction has 20642 states and 23772 transitions.
[2020-05-31 01:07:38,469 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20642 states and 23772 transitions.
[2020-05-31 01:07:38,563 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20642 to 20322.
[2020-05-31 01:07:38,563 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20322 states.
[2020-05-31 01:07:38,592 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20322 states to 20322 states and 23299 transitions.
[2020-05-31 01:07:38,592 INFO  L751         BuchiCegarLoop]: Abstraction has 20322 states and 23299 transitions.
[2020-05-31 01:07:38,592 INFO  L631         BuchiCegarLoop]: Abstraction has 20322 states and 23299 transitions.
[2020-05-31 01:07:38,592 INFO  L445         BuchiCegarLoop]: ======== Iteration 36============
[2020-05-31 01:07:38,592 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20322 states and 23299 transitions.
[2020-05-31 01:07:38,613 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:38,613 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:07:38,613 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:07:38,614 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:07:38,614 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:07:38,617 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:07:38,618 INFO  L82        PathProgramCache]: Analyzing trace with hash -1294842820, now seen corresponding path program 1 times
[2020-05-31 01:07:38,618 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:07:38,642 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:07:39,184 INFO  L134       CoverageAnalysis]: Checked inductivity of 144 backedges. 7 proven. 57 refuted. 0 times theorem prover too weak. 80 trivial. 0 not checked.
[2020-05-31 01:07:39,184 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:07:39,184 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [52] total 52
[2020-05-31 01:07:39,185 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:07:39,185 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 53 interpolants.
[2020-05-31 01:07:39,185 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=182, Invalid=2574, Unknown=0, NotChecked=0, Total=2756
[2020-05-31 01:07:39,185 INFO  L87              Difference]: Start difference. First operand 20322 states and 23299 transitions. cyclomatic complexity: 3030 Second operand 53 states.
[2020-05-31 01:07:43,865 WARN  L188               SmtUtils]: Spent 137.00 ms on a formula simplification. DAG size of input: 47 DAG size of output: 34
[2020-05-31 01:07:51,680 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:51,680 INFO  L93              Difference]: Finished difference Result 21338 states and 25120 transitions.
[2020-05-31 01:07:51,680 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 57 states. 
[2020-05-31 01:07:51,680 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21338 states and 25120 transitions.
[2020-05-31 01:07:51,732 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:51,798 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21338 states to 21330 states and 25089 transitions.
[2020-05-31 01:07:51,798 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1110
[2020-05-31 01:07:51,798 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1110
[2020-05-31 01:07:51,799 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21330 states and 25089 transitions.
[2020-05-31 01:07:51,813 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:51,813 INFO  L728         BuchiCegarLoop]: Abstraction has 21330 states and 25089 transitions.
[2020-05-31 01:07:51,820 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21330 states and 25089 transitions.
[2020-05-31 01:07:51,926 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21330 to 20797.
[2020-05-31 01:07:51,927 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20797 states.
[2020-05-31 01:07:51,959 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20797 states to 20797 states and 24222 transitions.
[2020-05-31 01:07:51,959 INFO  L751         BuchiCegarLoop]: Abstraction has 20797 states and 24222 transitions.
[2020-05-31 01:07:51,960 INFO  L631         BuchiCegarLoop]: Abstraction has 20797 states and 24222 transitions.
[2020-05-31 01:07:51,960 INFO  L445         BuchiCegarLoop]: ======== Iteration 37============
[2020-05-31 01:07:51,960 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20797 states and 24222 transitions.
[2020-05-31 01:07:51,982 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-31 01:07:51,982 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-31 01:07:51,982 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-31 01:07:51,983 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-31 01:07:51,983 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2250]                    assume null == 0;
[L2251]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2251]        RET         call this := FreshRefGenerator__success();
[L2252]                    assume now >= 0;
[L2253]                    assume DType[this] == EscrowVault;
[L2254]                    gas := gas - 53000;
[L2255]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2255]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2256]                    assume !revert && gas >= 0;
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND TRUE   choice == 7
[L2177]                    gas := gas - 21000;
[L2178]        COND TRUE   gas >= 0
[L2180]                    assume msgvalue_MSG >= 0;
[L2181]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2181]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND TRUE   choice == 2
[L2222]                    gas := gas - 21000;
[L2223]        COND TRUE   gas >= 0
[L2225]                    assume msgvalue_MSG == 0;
[L2226]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2020]                    gas := gas - 1932;
[L2021]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2226]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L1879]                    assume Balance[from] >= amount;
[L1880]                    Balance[from] := Balance[from] - amount;
[L1881]                    Balance[to] := Balance[to] + amount;
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2259]        CALL        call CorralChoice_EscrowVault(this);
[L2146]                    havoc msgsender_MSG;
[L2147]                    havoc msgvalue_MSG;
[L2148]                    havoc choice;
[L2149]                    havoc newOwner_s150;
[L2150]                    havoc _superOwner_s224;
[L2151]                    havoc _beneficiary_s224;
[L2152]                    havoc investor_s256;
[L2153]                    havoc _amount_s320;
[L2154]                    havoc investor_s431;
[L2155]                    havoc tmpNow;
[L2156]                    havoc gas;
[L2157]                    assume gas > 4000000 && gas <= 8000000;
[L2158]                    tmpNow := now;
[L2159]                    havoc now;
[L2160]                    assume now > tmpNow;
[L2161]                    assume msgsender_MSG != null;
[L2162]                    assume DType[msgsender_MSG] != SafeMath;
[L2163]                    assume DType[msgsender_MSG] != Ownable;
[L2164]                    assume DType[msgsender_MSG] != EscrowVault;
[L2165]                    Alloc[msgsender_MSG] := true;
[L2166]        COND FALSE  !(choice == 8)
[L2175]        COND FALSE  !(choice == 7)
[L2184]        COND FALSE  !(choice == 6)
[L2193]        COND FALSE  !(choice == 5)
[L2202]        COND FALSE  !(choice == 4)
[L2211]        COND FALSE  !(choice == 3)
[L2220]        COND FALSE  !(choice == 2)
[L2229]        COND TRUE   choice == 1
[L2231]                    gas := gas - 21000;
[L2232]        COND TRUE   gas >= 0
[L2234]                    assume msgvalue_MSG == 0;
[L2235]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1963]                    havoc __exception;
[L1964]        COND FALSE  !(__exception)
[L1990]        COND TRUE   Balance[from] >= amount
[L1992]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L1992]        RET         call FallbackDispatch__success(from, to, amount);
[L1993]                    success := true;
[L2000]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2235]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2259]        RET         call CorralChoice_EscrowVault(this);

[2020-05-31 01:07:51,986 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-31 01:07:51,987 INFO  L82        PathProgramCache]: Analyzing trace with hash -319577670, now seen corresponding path program 1 times
[2020-05-31 01:07:51,987 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-31 01:07:52,033 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-31 01:07:52,626 INFO  L134       CoverageAnalysis]: Checked inductivity of 216 backedges. 19 proven. 47 refuted. 0 times theorem prover too weak. 150 trivial. 0 not checked.
[2020-05-31 01:07:52,626 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-31 01:07:52,626 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [44] total 44
[2020-05-31 01:07:52,627 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-31 01:07:52,627 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-05-31 01:07:52,627 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1853, Unknown=0, NotChecked=0, Total=1980
[2020-05-31 01:07:52,627 INFO  L87              Difference]: Start difference. First operand 20797 states and 24222 transitions. cyclomatic complexity: 3500 Second operand 45 states.
[2020-05-31 01:07:59,877 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-31 01:07:59,877 INFO  L93              Difference]: Finished difference Result 19474 states and 22764 transitions.
[2020-05-31 01:07:59,877 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 43 states. 
[2020-05-31 01:07:59,877 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 19474 states and 22764 transitions.
[2020-05-31 01:07:59,922 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-31 01:07:59,922 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 19474 states to 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-31 01:07:59,923 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-31 01:07:59,923 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-31 01:07:59,923 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L445         BuchiCegarLoop]: ======== Iteration 38============
[2020-05-31 01:07:59,923 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-31 01:07:59,923 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-31 01:07:59,923 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-31 01:07:59,927 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 31.05 01:07:59 BasicIcfg
[2020-05-31 01:07:59,927 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-31 01:07:59,928 INFO  L168              Benchmark]: Toolchain (without parser) took 269350.43 ms. Allocated memory was 514.9 MB in the beginning and 5.9 GB in the end (delta: 5.3 GB). Free memory was 460.2 MB in the beginning and 1.1 GB in the end (delta: -607.1 MB). Peak memory consumption was 4.7 GB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,928 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,929 INFO  L168              Benchmark]: Boogie Preprocessor took 63.54 ms. Allocated memory is still 514.9 MB. Free memory was 460.2 MB in the beginning and 454.8 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,929 INFO  L168              Benchmark]: UtopiaSpecLang took 39.02 ms. Allocated memory is still 514.9 MB. Free memory was 454.8 MB in the beginning and 450.7 MB in the end (delta: 4.1 MB). Peak memory consumption was 4.1 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,929 INFO  L168              Benchmark]: Boogie Printer took 11.11 ms. Allocated memory is still 514.9 MB. Free memory was 450.7 MB in the beginning and 449.3 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,930 INFO  L168              Benchmark]: RCFGBuilder took 404.45 ms. Allocated memory is still 514.9 MB. Free memory was 449.3 MB in the beginning and 398.1 MB in the end (delta: 51.3 MB). Peak memory consumption was 51.3 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,930 INFO  L168              Benchmark]: UtopiaLTL2Aut took 46.59 ms. Allocated memory is still 514.9 MB. Free memory was 398.1 MB in the beginning and 394.9 MB in the end (delta: 3.1 MB). Peak memory consumption was 3.1 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,930 INFO  L168              Benchmark]: Büchi Program Product took 3700.69 ms. Allocated memory was 514.9 MB in the beginning and 1.0 GB in the end (delta: 494.4 MB). Free memory was 394.9 MB in the beginning and 547.0 MB in the end (delta: -152.1 MB). Peak memory consumption was 654.4 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,931 INFO  L168              Benchmark]: BlockEncodingV2 took 266.77 ms. Allocated memory is still 1.0 GB. Free memory was 547.0 MB in the beginning and 361.3 MB in the end (delta: 185.8 MB). Peak memory consumption was 185.8 MB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,931 INFO  L168              Benchmark]: BuchiAutomizer took 264814.62 ms. Allocated memory was 1.0 GB in the beginning and 5.9 GB in the end (delta: 4.9 GB). Free memory was 361.3 MB in the beginning and 1.1 GB in the end (delta: -706.0 MB). Peak memory consumption was 4.1 GB. Max. memory is 15.3 GB.
[2020-05-31 01:07:59,934 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    8239 locations, 31628 edges
  - StatisticsResult: Encoded RCFG
    8119 locations, 30946 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 63.54 ms. Allocated memory is still 514.9 MB. Free memory was 460.2 MB in the beginning and 454.8 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 39.02 ms. Allocated memory is still 514.9 MB. Free memory was 454.8 MB in the beginning and 450.7 MB in the end (delta: 4.1 MB). Peak memory consumption was 4.1 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 11.11 ms. Allocated memory is still 514.9 MB. Free memory was 450.7 MB in the beginning and 449.3 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 404.45 ms. Allocated memory is still 514.9 MB. Free memory was 449.3 MB in the beginning and 398.1 MB in the end (delta: 51.3 MB). Peak memory consumption was 51.3 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 46.59 ms. Allocated memory is still 514.9 MB. Free memory was 398.1 MB in the beginning and 394.9 MB in the end (delta: 3.1 MB). Peak memory consumption was 3.1 MB. Max. memory is 15.3 GB.
 * Büchi Program Product took 3700.69 ms. Allocated memory was 514.9 MB in the beginning and 1.0 GB in the end (delta: 494.4 MB). Free memory was 394.9 MB in the beginning and 547.0 MB in the end (delta: -152.1 MB). Peak memory consumption was 654.4 MB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 266.77 ms. Allocated memory is still 1.0 GB. Free memory was 547.0 MB in the beginning and 361.3 MB in the end (delta: 185.8 MB). Peak memory consumption was 185.8 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 264814.62 ms. Allocated memory was 1.0 GB in the beginning and 5.9 GB in the end (delta: 4.9 GB). Free memory was 361.3 MB in the beginning and 1.1 GB in the end (delta: -706.0 MB). Peak memory consumption was 4.1 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    888 locations, 1095 edges
  - StatisticsResult: BuchiProgram size
    8239 locations, 31628 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 37 terminating modules (37 trivial, 0 deterministic, 0 nondeterministic). 37 modules have a trivial ranking function, the largest among these consists of 53 locations.
  - StatisticsResult: Timing statistics
    BüchiAutomizer plugin needed 264.7s and 38 iterations.  TraceHistogramMax:3. Analysis of lassos took 7.1s. Construction of modules took 196.4s. Büchi inclusion checks took 46.1s. Highest rank in rank-based complementation 0. Minimization of det autom 37. Minimization of nondet autom 0. Automata minimization 8.1s AutomataMinimizationTime, 36 MinimizatonAttempts, 24578 StatesRemovedByMinimization, 29 NontrivialMinimizations. Non-live state removal took 5.0s Buchi closure took 0.0s. Biggest automaton had 68678 states and ocurred in iteration 22.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 248462 SDtfs, 431576 SDslu, 592102 SDs, 0 SdLazy, 1861373 SolverSat, 71176 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 196.4s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU37 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_EscrowVault0) ) && ( <>(success_refund_EscrowVault0) ) )&& ! ( ( []( (success_enableRefunds_EscrowVault0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
