This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 23:28:59,796 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 23:28:59,797 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 23:28:59,808 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 23:28:59,808 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 23:28:59,810 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 23:28:59,811 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 23:28:59,812 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 23:28:59,814 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 23:28:59,815 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 23:28:59,816 INFO  L177        SettingsManager]: Büchi Program Product provides no preferences, ignoring...
[2020-05-30 23:28:59,816 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 23:28:59,818 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 23:28:59,819 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 23:28:59,820 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 23:28:59,821 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 23:28:59,823 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 23:28:59,824 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 23:28:59,825 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 23:28:59,827 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 23:28:59,828 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 23:28:59,829 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 23:28:59,831 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 23:28:59,831 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 23:28:59,831 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 23:28:59,832 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 23:28:59,832 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 23:28:59,834 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 23:28:59,834 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 23:28:59,834 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 23:28:59,835 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 23:28:59,836 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 23:28:59,837 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 23:28:59,838 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 23:28:59,839 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 23:28:59,840 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 23:28:59,840 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 23:28:59,841 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 23:28:59,841 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 23:28:59,841 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 23:28:59,842 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 23:28:59,843 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 23:28:59,843 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 23:28:59,853 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 23:28:59,853 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 23:28:59,854 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 23:28:59,854 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 23:28:59,854 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 23:28:59,854 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 23:28:59,854 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 23:28:59,854 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 23:28:59,854 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 23:28:59,855 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 23:28:59,855 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 23:28:59,855 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 23:28:59,856 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 23:28:59,856 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 23:28:59,877 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 23:28:59,888 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 23:28:59,890 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 23:28:59,891 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 23:28:59,891 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 23:28:59,892 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/EscrowVault/single-callback/L1-EscrowVault.bpl
[2020-05-30 23:28:59,893 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/EscrowVault/single-callback/L1-EscrowVault.bpl'
[2020-05-30 23:28:59,944 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 23:28:59,946 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 23:28:59,947 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 23:28:59,947 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 23:28:59,947 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 23:28:59,961 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:28:59,962 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:28:59,984 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:28:59,985 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:28:59,997 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:29:00,002 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:29:00,006 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:29:00,013 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 23:29:00,014 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 23:29:00,014 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 23:29:00,015 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 23:29:00,018 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/1) ...
[2020-05-30 23:29:00,029 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-30 23:29:00,034 INFO  L979   opiaSpecLangObserver]: Successfully lexed: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-30 23:29:00,040 INFO  L981   opiaSpecLangObserver]: Successfully parsed: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-30 23:29:00,042 INFO  L599   opiaSpecLangObserver]: Parsed investor_s256==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s256,<IMPLEMENTATION_INPARAM,deposit_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 23:29:00,044 INFO  L599   opiaSpecLangObserver]: Parsed ( to==user && amount==fsum_deposit_EscrowVault_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[user,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_EscrowVault_2_0,GLOBAL]]]
[2020-05-30 23:29:00,045 INFO  L968   opiaSpecLangObserver]: Compiling: []((finished(EscrowVault.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(EscrowVault.deposit(payee), 2, payee == user))))))
[2020-05-30 23:29:00,045 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_enableRefunds_EscrowVault0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 23:29:00,045 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-30 23:29:00,045 INFO  L979   opiaSpecLangObserver]: Successfully lexed: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-30 23:29:00,046 INFO  L981   opiaSpecLangObserver]: Successfully parsed: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-30 23:29:00,047 INFO  L599   opiaSpecLangObserver]: Parsed investor_s256==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s256,<IMPLEMENTATION_INPARAM,deposit_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 23:29:00,049 INFO  L599   opiaSpecLangObserver]: Parsed investor_s431==user to BinaryExpression[COMPEQ,IdentifierExpression[investor_s431,<IMPLEMENTATION_INPARAM,refund_EscrowVault>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 23:29:00,049 INFO  L968   opiaSpecLangObserver]: Compiling: (<>(finished(EscrowVault.deposit(payee), (payee == user)))) && (<>(finished(EscrowVault.refund(payee), (payee == user))))
[2020-05-30 23:29:00,049 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_EscrowVault0) ) && ( <>AP(success_refund_EscrowVault0) ) )
Executed UtopiaSpecLang
[2020-05-30 23:29:00,056 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 11:29:00 PropertyContainer
[2020-05-30 23:29:00,056 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 23:29:00,056 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 23:29:00,057 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 23:29:00,057 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 23:29:00,057 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/2) ...
[2020-05-30 23:29:00,058 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 23:29:00,058 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 23:29:00,067 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 11:29:00" (2/2) ...
[2020-05-30 23:29:00,067 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 23:29:00,068 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 23:29:00,068 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 23:29:00,068 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 23:29:00,069 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/2) ...
[2020-05-30 23:29:00,110 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 23:29:00,110 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 23:29:00,111 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 23:29:00,111 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 23:29:00,111 INFO  L130     BoogieDeclarations]: Found specification of procedure mul_SafeMath__success
[2020-05-30 23:29:00,111 INFO  L130     BoogieDeclarations]: Found specification of procedure div_SafeMath__success
[2020-05-30 23:29:00,111 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 23:29:00,111 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 23:29:00,112 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable_NoBaseCtor__success
[2020-05-30 23:29:00,112 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable
[2020-05-30 23:29:00,112 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable
[2020-05-30 23:29:00,112 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable
[2020-05-30 23:29:00,112 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable
[2020-05-30 23:29:00,112 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault_NoBaseCtor__success
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault
[2020-05-30 23:29:00,113 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault
[2020-05-30 23:29:00,113 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault
[2020-05-30 23:29:00,113 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault
[2020-05-30 23:29:00,113 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault
[2020-05-30 23:29:00,113 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault
[2020-05-30 23:29:00,113 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault
[2020-05-30 23:29:00,114 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault
[2020-05-30 23:29:00,114 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault
[2020-05-30 23:29:00,114 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault
[2020-05-30 23:29:00,114 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault
[2020-05-30 23:29:00,114 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault
[2020-05-30 23:29:00,114 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 23:29:00,114 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 23:29:00,114 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__success
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Ownable
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Ownable
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_EscrowVault
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure mul_SafeMath__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure div_SafeMath__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 23:29:00,115 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable_NoBaseCtor__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable__success
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure Ownable_Ownable__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable__success
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure transferOwnership_Ownable__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault_NoBaseCtor__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault__success
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure EscrowVault_EscrowVault__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault__success
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_EscrowVault__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault__success
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure setGoalReached_EscrowVault__fail
[2020-05-30 23:29:00,116 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault__success
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_EscrowVault__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault__success
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawAll_EscrowVault__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault__success
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure close_EscrowVault__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault__success
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_EscrowVault__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault__success
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure refund_EscrowVault__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 23:29:00,117 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul_SafeMath__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul_SafeMath__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure div_SafeMath__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure div_SafeMath__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 23:29:00,118 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable_NoBaseCtor__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable_NoBaseCtor__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure Ownable_Ownable__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferOwnership_Ownable__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault_NoBaseCtor__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault_NoBaseCtor__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault__fail
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure EscrowVault_EscrowVault__success
[2020-05-30 23:29:00,119 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault__fail
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_EscrowVault__success
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault__fail
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure setGoalReached_EscrowVault__success
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault__fail
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_EscrowVault__success
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault__fail
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawAll_EscrowVault__success
[2020-05-30 23:29:00,120 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault__fail
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_EscrowVault__success
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault__fail
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_EscrowVault__success
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault__fail
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure refund_EscrowVault__success
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 23:29:00,121 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__fail
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__success
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Ownable
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Ownable
[2020-05-30 23:29:00,122 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_EscrowVault
[2020-05-30 23:29:00,123 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 23:29:00,123 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 23:29:00,123 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 23:29:00,171 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 23:29:00,171 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 23:29:00,260 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 23:29:00,272 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 23:29:00,460 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 23:29:00,489 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 23:29:00,489 INFO  L286             CfgBuilder]: Removed 3 assue(true) statements.
[2020-05-30 23:29:00,490 INFO  L202        PluginConnector]: Adding new model L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 11:29:00 BoogieIcfgContainer
[2020-05-30 23:29:00,491 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 11:29:00" (2/2) ...
[2020-05-30 23:29:00,491 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 23:29:00,492 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@4148cc8b and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 11:29:00, skipping insertion in model container
[2020-05-30 23:29:00,492 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 23:29:00,492 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 23:29:00,492 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 23:29:00,493 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 23:29:00,493 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/3) ...
[2020-05-30 23:29:00,494 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@6ef92e39 and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 11:29:00, skipping insertion in model container
[2020-05-30 23:29:00,494 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 11:29:00" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 23:29:00,538 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 11:29:00 NWAContainer
[2020-05-30 23:29:00,538 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 23:29:00,539 INFO  L113        PluginConnector]: ------------------------Büchi Program Product----------------------------
[2020-05-30 23:29:00,539 INFO  L271        PluginConnector]: Initializing Büchi Program Product...
[2020-05-30 23:29:00,539 INFO  L276        PluginConnector]: Büchi Program Product initialized
[2020-05-30 23:29:00,540 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 11:29:00" (3/4) ...
[2020-05-30 23:29:00,541 INFO  L205        PluginConnector]: Invalid model from Büchi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@550cc1ce and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 11:29:00, skipping insertion in model container
[2020-05-30 23:29:00,541 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 11:29:00" (4/4) ...
[2020-05-30 23:29:00,543 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 23:29:00,545 INFO  L110   BuchiProductObserver]: Initial RCFG 1006 locations, 1311 edges
[2020-05-30 23:29:00,546 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 23:29:00,555 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 23:29:04,464 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 23:29:04,479 INFO  L110   BuchiProductObserver]: BuchiProgram size 9471 locations, 37928 edges
[2020-05-30 23:29:04,479 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 11:29:04 BoogieIcfgContainer
[2020-05-30 23:29:04,479 INFO  L132        PluginConnector]: ------------------------ END Büchi Program Product----------------------------
[2020-05-30 23:29:04,479 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 23:29:04,479 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 23:29:04,481 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 23:29:04,481 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 11:29:04" (1/1) ...
[2020-05-30 23:29:04,794 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,795 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,796 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 23:29:04,796 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,796 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,796 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,796 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,797 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,797 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,802 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,803 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,803 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,804 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,804 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,804 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,804 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 23:29:04,834 INFO  L313           BlockEncoder]: Initial Icfg 9471 locations, 37928 edges
[2020-05-30 23:29:04,835 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 23:29:04,835 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 23:29:04,835 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 23:29:04,836 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 23:29:04,861 INFO  L70    emoveInfeasibleEdges]: Removed 413 edges and 36 locations because of local infeasibility
[2020-05-30 23:29:04,877 INFO  L70        RemoveSinkStates]: Removed 18 edges and 4 locations by removing sink states
[2020-05-30 23:29:04,907 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 23:29:04,915 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 23:29:04,925 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 23:29:04,925 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 23:29:04,934 INFO  L313           BlockEncoder]: Encoded RCFG 9351 locations, 37246 edges
[2020-05-30 23:29:04,934 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 11:29:04 BasicIcfg
[2020-05-30 23:29:04,934 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 23:29:04,935 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 23:29:04,935 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 23:29:04,937 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 23:29:04,937 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,937 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 11:28:59" (1/6) ...
[2020-05-30 23:29:04,938 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@25b5ae27 and model type L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 11:29:04, skipping insertion in model container
[2020-05-30 23:29:04,938 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,938 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 11:29:00" (2/6) ...
[2020-05-30 23:29:04,938 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@25b5ae27 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 11:29:04, skipping insertion in model container
[2020-05-30 23:29:04,938 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,939 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 11:29:00" (3/6) ...
[2020-05-30 23:29:04,939 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@25b5ae27 and model type L1-EscrowVault.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 11:29:04, skipping insertion in model container
[2020-05-30 23:29:04,939 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,939 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 11:29:00" (4/6) ...
[2020-05-30 23:29:04,939 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@25b5ae27 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 11:29:04, skipping insertion in model container
[2020-05-30 23:29:04,939 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,939 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 11:29:04" (5/6) ...
[2020-05-30 23:29:04,939 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@25b5ae27 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 11:29:04, skipping insertion in model container
[2020-05-30 23:29:04,940 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 23:29:04,940 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 11:29:04" (6/6) ...
[2020-05-30 23:29:04,940 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L1-EscrowVault.bpl_BEv2
[2020-05-30 23:29:04,972 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 23:29:04,973 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 23:29:04,973 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 23:29:04,973 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 23:29:04,973 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 23:29:04,973 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 23:29:04,973 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 23:29:04,973 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 23:29:04,973 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 23:29:05,056 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9351 states.
[2020-05-30 23:29:05,194 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:05,194 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:05,194 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:05,204 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:05,204 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:05,204 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 23:29:05,204 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9351 states.
[2020-05-30 23:29:05,275 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:05,275 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:05,275 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:05,277 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:05,277 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2540]              assume null == 0;
[L2541]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2541]  RET         call this := FreshRefGenerator__success();
[L2542]              assume now >= 0;
[L2543]              assume DType[this] == EscrowVault;
[L2544]              gas := gas - 53000;
[L2545]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND TRUE   revert
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2545]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]              assume !revert && gas >= 0;

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND TRUE   choice == 8
[L2458]              gas := gas - 21000;
[L2459]  COND FALSE  !(gas >= 0)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:05,292 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:05,293 INFO  L82        PathProgramCache]: Analyzing trace with hash -1899656607, now seen corresponding path program 1 times
[2020-05-30 23:29:05,296 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:05,314 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:05,360 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 23:29:05,362 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:05,362 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 23:29:05,923 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:05,940 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 23:29:05,941 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 23:29:05,943 INFO  L87              Difference]: Start difference. First operand 9351 states. Second operand 3 states.
[2020-05-30 23:29:06,865 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:06,865 INFO  L93              Difference]: Finished difference Result 7987 states and 19977 transitions.
[2020-05-30 23:29:06,866 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 23:29:06,867 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7987 states and 19977 transitions.
[2020-05-30 23:29:06,936 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:07,032 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7987 states to 7987 states and 19977 transitions.
[2020-05-30 23:29:07,033 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 23:29:07,036 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 220
[2020-05-30 23:29:07,036 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7987 states and 19977 transitions.
[2020-05-30 23:29:07,071 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:07,071 INFO  L728         BuchiCegarLoop]: Abstraction has 7987 states and 19977 transitions.
[2020-05-30 23:29:07,098 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7987 states and 19977 transitions.
[2020-05-30 23:29:07,250 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7987 to 7987.
[2020-05-30 23:29:07,251 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7987 states.
[2020-05-30 23:29:07,284 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7987 states to 7987 states and 19977 transitions.
[2020-05-30 23:29:07,285 INFO  L751         BuchiCegarLoop]: Abstraction has 7987 states and 19977 transitions.
[2020-05-30 23:29:07,285 INFO  L631         BuchiCegarLoop]: Abstraction has 7987 states and 19977 transitions.
[2020-05-30 23:29:07,285 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 23:29:07,285 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7987 states and 19977 transitions.
[2020-05-30 23:29:07,303 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:07,303 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:07,303 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:07,305 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:07,305 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2540]              assume null == 0;
[L2541]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2541]  RET         call this := FreshRefGenerator__success();
[L2542]              assume now >= 0;
[L2543]              assume DType[this] == EscrowVault;
[L2544]              gas := gas - 53000;
[L2545]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2545]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]              assume !revert && gas >= 0;
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND TRUE   choice == 2
[L2512]              gas := gas - 21000;
[L2513]  COND TRUE   gas >= 0
[L2515]              assume msgvalue_MSG == 0;
[L2516]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2516]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND TRUE   choice == 2
[L2512]              gas := gas - 21000;
[L2513]  COND TRUE   gas >= 0
[L2515]              assume msgvalue_MSG == 0;
[L2516]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2516]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:07,310 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:07,310 INFO  L82        PathProgramCache]: Analyzing trace with hash -58871651, now seen corresponding path program 1 times
[2020-05-30 23:29:07,311 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:07,319 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:07,338 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 23:29:07,338 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:07,338 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 23:29:07,340 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:07,340 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 23:29:07,340 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 23:29:07,341 INFO  L87              Difference]: Start difference. First operand 7987 states and 19977 transitions. cyclomatic complexity: 12014 Second operand 4 states.
[2020-05-30 23:29:09,811 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:09,811 INFO  L93              Difference]: Finished difference Result 7713 states and 13323 transitions.
[2020-05-30 23:29:09,811 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 23:29:09,811 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7713 states and 13323 transitions.
[2020-05-30 23:29:09,836 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:09,883 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7713 states to 7713 states and 13323 transitions.
[2020-05-30 23:29:09,883 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 220
[2020-05-30 23:29:09,884 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 220
[2020-05-30 23:29:09,884 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7713 states and 13323 transitions.
[2020-05-30 23:29:09,898 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:09,898 INFO  L728         BuchiCegarLoop]: Abstraction has 7713 states and 13323 transitions.
[2020-05-30 23:29:09,908 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7713 states and 13323 transitions.
[2020-05-30 23:29:09,981 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7713 to 7713.
[2020-05-30 23:29:09,981 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7713 states.
[2020-05-30 23:29:09,998 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7713 states to 7713 states and 13323 transitions.
[2020-05-30 23:29:09,999 INFO  L751         BuchiCegarLoop]: Abstraction has 7713 states and 13323 transitions.
[2020-05-30 23:29:09,999 INFO  L631         BuchiCegarLoop]: Abstraction has 7713 states and 13323 transitions.
[2020-05-30 23:29:09,999 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 23:29:09,999 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7713 states and 13323 transitions.
[2020-05-30 23:29:10,009 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:10,010 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:10,010 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:10,011 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:10,011 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2540]              assume null == 0;
[L2541]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2541]  RET         call this := FreshRefGenerator__success();
[L2542]              assume now >= 0;
[L2543]              assume DType[this] == EscrowVault;
[L2544]              gas := gas - 53000;
[L2545]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2545]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]              assume !revert && gas >= 0;
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND TRUE   choice == 2
[L2512]              gas := gas - 21000;
[L2513]  COND TRUE   gas >= 0
[L2515]              assume msgvalue_MSG == 0;
[L2516]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2516]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND TRUE   choice == 7
[L2467]              gas := gas - 21000;
[L2468]  COND TRUE   gas >= 0
[L2470]              assume msgvalue_MSG >= 0;
[L2471]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND TRUE   revert
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2471]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND TRUE   choice == 7
[L2467]              gas := gas - 21000;
[L2468]  COND TRUE   gas >= 0
[L2470]              assume msgvalue_MSG >= 0;
[L2471]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND TRUE   revert
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2471]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:10,016 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:10,016 INFO  L82        PathProgramCache]: Analyzing trace with hash -579469027, now seen corresponding path program 1 times
[2020-05-30 23:29:10,016 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:10,024 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:10,046 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 23:29:10,046 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:10,046 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 23:29:10,047 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:10,047 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 23:29:10,047 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 23:29:10,047 INFO  L87              Difference]: Start difference. First operand 7713 states and 13323 transitions. cyclomatic complexity: 5634 Second operand 4 states.
[2020-05-30 23:29:11,108 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:11,108 INFO  L93              Difference]: Finished difference Result 7576 states and 9142 transitions.
[2020-05-30 23:29:11,108 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 23:29:11,108 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7576 states and 9142 transitions.
[2020-05-30 23:29:11,123 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:11,145 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7576 states to 7576 states and 9142 transitions.
[2020-05-30 23:29:11,145 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 220
[2020-05-30 23:29:11,145 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 220
[2020-05-30 23:29:11,145 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7576 states and 9142 transitions.
[2020-05-30 23:29:11,150 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:11,150 INFO  L728         BuchiCegarLoop]: Abstraction has 7576 states and 9142 transitions.
[2020-05-30 23:29:11,157 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7576 states and 9142 transitions.
[2020-05-30 23:29:11,209 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7576 to 7576.
[2020-05-30 23:29:11,209 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7576 states.
[2020-05-30 23:29:11,217 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7576 states to 7576 states and 9142 transitions.
[2020-05-30 23:29:11,217 INFO  L751         BuchiCegarLoop]: Abstraction has 7576 states and 9142 transitions.
[2020-05-30 23:29:11,217 INFO  L631         BuchiCegarLoop]: Abstraction has 7576 states and 9142 transitions.
[2020-05-30 23:29:11,217 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 23:29:11,217 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7576 states and 9142 transitions.
[2020-05-30 23:29:11,224 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:11,224 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:11,224 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:11,225 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:11,225 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2540]              assume null == 0;
[L2541]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2541]  RET         call this := FreshRefGenerator__success();
[L2542]              assume now >= 0;
[L2543]              assume DType[this] == EscrowVault;
[L2544]              gas := gas - 53000;
[L2545]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2545]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]              assume !revert && gas >= 0;
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND TRUE   choice == 1
[L2521]              gas := gas - 21000;
[L2522]  COND TRUE   gas >= 0
[L2524]              assume msgvalue_MSG == 0;
[L2525]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2525]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]  RET         call CorralChoice_EscrowVault(this);
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND TRUE   choice == 2
[L2512]              gas := gas - 21000;
[L2513]  COND TRUE   gas >= 0
[L2515]              assume msgvalue_MSG == 0;
[L2516]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND TRUE   revert
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2516]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND TRUE   choice == 7
[L2467]              gas := gas - 21000;
[L2468]  COND TRUE   gas >= 0
[L2470]              assume msgvalue_MSG >= 0;
[L2471]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND TRUE   revert
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2471]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND TRUE   choice == 1
[L2521]              gas := gas - 21000;
[L2522]  COND TRUE   gas >= 0
[L2524]              assume msgvalue_MSG == 0;
[L2525]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2525]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:11,228 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:11,228 INFO  L82        PathProgramCache]: Analyzing trace with hash 791886095, now seen corresponding path program 1 times
[2020-05-30 23:29:11,229 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:11,235 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:11,258 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 23:29:11,258 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:11,258 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 23:29:11,259 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:11,259 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 23:29:11,259 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 23:29:11,259 INFO  L87              Difference]: Start difference. First operand 7576 states and 9142 transitions. cyclomatic complexity: 1590 Second operand 3 states.
[2020-05-30 23:29:11,412 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:11,412 INFO  L93              Difference]: Finished difference Result 9778 states and 11857 transitions.
[2020-05-30 23:29:11,412 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 23:29:11,412 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9778 states and 11857 transitions.
[2020-05-30 23:29:11,435 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:11,471 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9778 states to 9778 states and 11857 transitions.
[2020-05-30 23:29:11,471 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 321
[2020-05-30 23:29:11,471 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 321
[2020-05-30 23:29:11,471 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9778 states and 11857 transitions.
[2020-05-30 23:29:11,478 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:11,478 INFO  L728         BuchiCegarLoop]: Abstraction has 9778 states and 11857 transitions.
[2020-05-30 23:29:11,488 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9778 states and 11857 transitions.
[2020-05-30 23:29:11,583 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9778 to 9029.
[2020-05-30 23:29:11,583 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9029 states.
[2020-05-30 23:29:11,594 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9029 states to 9029 states and 10931 transitions.
[2020-05-30 23:29:11,594 INFO  L751         BuchiCegarLoop]: Abstraction has 9029 states and 10931 transitions.
[2020-05-30 23:29:11,595 INFO  L631         BuchiCegarLoop]: Abstraction has 9029 states and 10931 transitions.
[2020-05-30 23:29:11,595 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 23:29:11,595 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9029 states and 10931 transitions.
[2020-05-30 23:29:11,604 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:11,604 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:11,604 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:11,606 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:11,607 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 fsum_deposit_EscrowVault_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L2540]              assume null == 0;
[L2541]  CALL        call this := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L2541]  RET         call this := FreshRefGenerator__success();
[L2542]              assume now >= 0;
[L2543]              assume DType[this] == EscrowVault;
[L2544]              gas := gas - 53000;
[L2545]  CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]               havoc __exception;
[L266]               revert := false;
[L267]   COND FALSE  !(__exception)
[L287]   CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]  CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]  CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]              assume msgsender_MSG != null;
[L1092]              Balance[this] := 0;
[L1093]              owner_Ownable[this] := null;
[L1094]              owner_Ownable[this] := msgsender_MSG;
[L1112]  RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]  COND FALSE  !(revert)
[L1293]  RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]  COND FALSE  !(revert)
[L1299]  CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]              assume msgsender_MSG != null;
[L1225]              Balance[this] := 0;
[L1226]  CALL        call __var_4 := FreshRefGenerator__success();
[L833]               havoc newRef;
[L834]               assume Alloc[newRef] == false;
[L835]               Alloc[newRef] := true;
[L836]               assume newRef != null;
[L1226]  RET         call __var_4 := FreshRefGenerator__success();
[L1227]  COND FALSE  !(revert)
[L1232]              deposited_EscrowVault[this] := __var_4;
[L1233]              M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]              sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]              beneficiary_EscrowVault[this] := null;
[L1236]              superOwner_EscrowVault[this] := null;
[L1237]              __var_2 := null;
[L1238]  COND TRUE   !(_beneficiary_s224 != null)
[L1240]              revert := true;
[L1299]  RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]  COND TRUE   revert
[L287]   RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]               assume !revert && gas >= 0;
[L2545]  RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]              assume !revert && gas >= 0;
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND TRUE   choice == 1
[L2521]              gas := gas - 21000;
[L2522]  COND TRUE   gas >= 0
[L2524]              assume msgvalue_MSG == 0;
[L2525]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2525]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]  RET         call CorralChoice_EscrowVault(this);
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND TRUE   choice == 2
[L2512]              gas := gas - 21000;
[L2513]  COND TRUE   gas >= 0
[L2515]              assume msgvalue_MSG == 0;
[L2516]  CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]               havoc __exception;
[L494]               revert := false;
[L495]   COND FALSE  !(__exception)
[L515]   CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]  COND FALSE  !(revert)
[L1717]              gas := gas - 367;
[L1718]  COND TRUE   !(state_EscrowVault[this] == 0)
[L1720]              revert := true;
[L515]   RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_EscrowVault0 := true;
[L7]                 success_enableRefunds_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2516]  RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND TRUE   choice == 7
[L2467]              gas := gas - 21000;
[L2468]  COND TRUE   gas >= 0
[L2470]              assume msgvalue_MSG >= 0;
[L2471]  CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]               havoc __exception;
[L304]               revert := false;
[L305]   COND FALSE  !(__exception)
[L325]   CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]              Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]  COND FALSE  !(revert)
[L1363]              gas := gas - 733;
[L1364]  COND TRUE   !(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2)
[L1366]              revert := true;
[L325]   RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s256 == user;
[L7]                 success_deposit_EscrowVault0 := true;
[L7]                 success_deposit_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(investor_s256 == user);
[L2471]  RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]  RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND TRUE   choice == 1
[L2521]              gas := gas - 21000;
[L2522]  COND TRUE   gas >= 0
[L2524]              assume msgvalue_MSG == 0;
[L2525]  CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]               havoc __exception;
[L532]               revert := false;
[L533]   COND FALSE  !(__exception)
[L553]   CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]              gas := gas - 367;
[L1785]  COND TRUE   !(state_EscrowVault[this] == 1)
[L1787]              revert := true;
[L553]   RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume investor_s431 == user;
[L7]                 success_refund_EscrowVault0 := true;
[L7]                 success_refund_EscrowVault0 := false;
[L7]                 revert := revert_hold;
[L2525]  RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:11,610 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:11,610 INFO  L82        PathProgramCache]: Analyzing trace with hash 393013111, now seen corresponding path program 1 times
[2020-05-30 23:29:11,610 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:11,617 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:11,659 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:11,660 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:11,660 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 23:29:11,660 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:11,660 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 23:29:11,661 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 23:29:11,661 INFO  L87              Difference]: Start difference. First operand 9029 states and 10931 transitions. cyclomatic complexity: 1926 Second operand 3 states.
[2020-05-30 23:29:11,811 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:11,811 INFO  L93              Difference]: Finished difference Result 10344 states and 12285 transitions.
[2020-05-30 23:29:11,811 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 23:29:11,812 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10344 states and 12285 transitions.
[2020-05-30 23:29:11,847 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-05-30 23:29:11,890 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10344 states to 9536 states and 11267 transitions.
[2020-05-30 23:29:11,891 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 266
[2020-05-30 23:29:11,891 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 266
[2020-05-30 23:29:11,891 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9536 states and 11267 transitions.
[2020-05-30 23:29:11,900 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:11,900 INFO  L728         BuchiCegarLoop]: Abstraction has 9536 states and 11267 transitions.
[2020-05-30 23:29:11,909 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9536 states and 11267 transitions.
[2020-05-30 23:29:11,977 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9536 to 8336.
[2020-05-30 23:29:11,977 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8336 states.
[2020-05-30 23:29:11,991 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8336 states to 8336 states and 9736 transitions.
[2020-05-30 23:29:11,991 INFO  L751         BuchiCegarLoop]: Abstraction has 8336 states and 9736 transitions.
[2020-05-30 23:29:11,991 INFO  L631         BuchiCegarLoop]: Abstraction has 8336 states and 9736 transitions.
[2020-05-30 23:29:11,991 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 23:29:11,991 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8336 states and 9736 transitions.
[2020-05-30 23:29:12,000 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:12,000 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:12,000 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:12,002 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:12,002 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND FALSE  !(Balance[from] >= amount)
[L2287]                    success := false;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND FALSE  !(Balance[from] >= amount)
[L2287]                    success := false;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:12,006 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:12,006 INFO  L82        PathProgramCache]: Analyzing trace with hash -238777754, now seen corresponding path program 1 times
[2020-05-30 23:29:12,007 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:12,030 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:12,159 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:12,159 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:12,159 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 23:29:12,160 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:12,160 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 23:29:12,160 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 23:29:12,160 INFO  L87              Difference]: Start difference. First operand 8336 states and 9736 transitions. cyclomatic complexity: 1424 Second operand 3 states.
[2020-05-30 23:29:12,258 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:12,258 INFO  L93              Difference]: Finished difference Result 8368 states and 9768 transitions.
[2020-05-30 23:29:12,258 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 23:29:12,258 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8368 states and 9768 transitions.
[2020-05-30 23:29:12,281 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:12,314 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8368 states to 8368 states and 9768 transitions.
[2020-05-30 23:29:12,315 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 222
[2020-05-30 23:29:12,315 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 222
[2020-05-30 23:29:12,315 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8368 states and 9768 transitions.
[2020-05-30 23:29:12,324 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:12,324 INFO  L728         BuchiCegarLoop]: Abstraction has 8368 states and 9768 transitions.
[2020-05-30 23:29:12,334 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8368 states and 9768 transitions.
[2020-05-30 23:29:12,396 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8368 to 8360.
[2020-05-30 23:29:12,396 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8360 states.
[2020-05-30 23:29:12,406 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8360 states to 8360 states and 9760 transitions.
[2020-05-30 23:29:12,406 INFO  L751         BuchiCegarLoop]: Abstraction has 8360 states and 9760 transitions.
[2020-05-30 23:29:12,406 INFO  L631         BuchiCegarLoop]: Abstraction has 8360 states and 9760 transitions.
[2020-05-30 23:29:12,406 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 23:29:12,406 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8360 states and 9760 transitions.
[2020-05-30 23:29:12,415 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:12,415 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:12,415 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:12,417 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:12,417 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND FALSE  !(Balance[from] >= amount)
[L2287]                    success := false;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND FALSE  !(Balance[from] >= amount)
[L2287]                    success := false;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:12,421 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:12,421 INFO  L82        PathProgramCache]: Analyzing trace with hash -1829133247, now seen corresponding path program 1 times
[2020-05-30 23:29:12,422 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:12,442 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:12,494 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:12,495 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:12,495 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 23:29:12,495 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:12,495 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 23:29:12,495 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 23:29:12,496 INFO  L87              Difference]: Start difference. First operand 8360 states and 9760 transitions. cyclomatic complexity: 1424 Second operand 4 states.
[2020-05-30 23:29:12,581 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:12,581 INFO  L93              Difference]: Finished difference Result 8440 states and 9852 transitions.
[2020-05-30 23:29:12,581 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 23:29:12,581 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8440 states and 9852 transitions.
[2020-05-30 23:29:12,597 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:12,623 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8440 states to 8424 states and 9836 transitions.
[2020-05-30 23:29:12,623 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 229
[2020-05-30 23:29:12,623 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 229
[2020-05-30 23:29:12,623 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8424 states and 9836 transitions.
[2020-05-30 23:29:12,629 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:12,629 INFO  L728         BuchiCegarLoop]: Abstraction has 8424 states and 9836 transitions.
[2020-05-30 23:29:12,637 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8424 states and 9836 transitions.
[2020-05-30 23:29:12,691 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8424 to 8424.
[2020-05-30 23:29:12,691 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8424 states.
[2020-05-30 23:29:12,700 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8424 states to 8424 states and 9836 transitions.
[2020-05-30 23:29:12,700 INFO  L751         BuchiCegarLoop]: Abstraction has 8424 states and 9836 transitions.
[2020-05-30 23:29:12,700 INFO  L631         BuchiCegarLoop]: Abstraction has 8424 states and 9836 transitions.
[2020-05-30 23:29:12,700 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 23:29:12,700 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8424 states and 9836 transitions.
[2020-05-30 23:29:12,709 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:12,709 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:12,709 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:12,711 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:12,711 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND FALSE  !(gas > 2300)
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:12,715 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:12,716 INFO  L82        PathProgramCache]: Analyzing trace with hash -404202294, now seen corresponding path program 1 times
[2020-05-30 23:29:12,716 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:12,734 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:12,831 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:12,831 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:12,831 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 23:29:12,832 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:12,832 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 23:29:12,832 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=28, Invalid=62, Unknown=0, NotChecked=0, Total=90
[2020-05-30 23:29:12,832 INFO  L87              Difference]: Start difference. First operand 8424 states and 9836 transitions. cyclomatic complexity: 1436 Second operand 10 states.
[2020-05-30 23:29:16,841 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:16,841 INFO  L93              Difference]: Finished difference Result 11272 states and 13181 transitions.
[2020-05-30 23:29:16,841 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-30 23:29:16,842 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11272 states and 13181 transitions.
[2020-05-30 23:29:16,861 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 23:29:16,896 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11272 states to 11272 states and 13181 transitions.
[2020-05-30 23:29:16,896 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 385
[2020-05-30 23:29:16,896 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 385
[2020-05-30 23:29:16,896 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11272 states and 13181 transitions.
[2020-05-30 23:29:16,905 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:16,905 INFO  L728         BuchiCegarLoop]: Abstraction has 11272 states and 13181 transitions.
[2020-05-30 23:29:16,913 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11272 states and 13181 transitions.
[2020-05-30 23:29:16,983 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11272 to 8255.
[2020-05-30 23:29:16,983 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8255 states.
[2020-05-30 23:29:16,993 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8255 states to 8255 states and 9492 transitions.
[2020-05-30 23:29:16,994 INFO  L751         BuchiCegarLoop]: Abstraction has 8255 states and 9492 transitions.
[2020-05-30 23:29:16,994 INFO  L631         BuchiCegarLoop]: Abstraction has 8255 states and 9492 transitions.
[2020-05-30 23:29:16,994 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 23:29:16,994 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8255 states and 9492 transitions.
[2020-05-30 23:29:17,003 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 23:29:17,003 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:17,003 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:17,005 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:17,005 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:17,008 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:17,008 INFO  L82        PathProgramCache]: Analyzing trace with hash -767488849, now seen corresponding path program 1 times
[2020-05-30 23:29:17,009 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:17,026 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:17,105 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:17,105 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:17,105 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 23:29:17,106 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:17,106 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 23:29:17,106 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 23:29:17,106 INFO  L87              Difference]: Start difference. First operand 8255 states and 9492 transitions. cyclomatic complexity: 1261 Second operand 10 states.
[2020-05-30 23:29:22,988 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:22,988 INFO  L93              Difference]: Finished difference Result 9780 states and 11351 transitions.
[2020-05-30 23:29:22,988 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 23:29:22,988 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9780 states and 11351 transitions.
[2020-05-30 23:29:23,003 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:23,028 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9780 states to 9724 states and 11287 transitions.
[2020-05-30 23:29:23,028 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 335
[2020-05-30 23:29:23,028 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 335
[2020-05-30 23:29:23,028 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9724 states and 11287 transitions.
[2020-05-30 23:29:23,033 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:23,034 INFO  L728         BuchiCegarLoop]: Abstraction has 9724 states and 11287 transitions.
[2020-05-30 23:29:23,039 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9724 states and 11287 transitions.
[2020-05-30 23:29:23,087 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9724 to 9638.
[2020-05-30 23:29:23,087 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9638 states.
[2020-05-30 23:29:23,098 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9638 states to 9638 states and 11163 transitions.
[2020-05-30 23:29:23,098 INFO  L751         BuchiCegarLoop]: Abstraction has 9638 states and 11163 transitions.
[2020-05-30 23:29:23,098 INFO  L631         BuchiCegarLoop]: Abstraction has 9638 states and 11163 transitions.
[2020-05-30 23:29:23,098 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 23:29:23,099 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9638 states and 11163 transitions.
[2020-05-30 23:29:23,107 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:23,107 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:23,108 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:23,109 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:23,109 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND FALSE  !(gas < 21000)
[L2049]        COND TRUE   DType[from] == EscrowVault
[L2051]        COND FALSE  !(choice == 8)
[L2064]        COND FALSE  !(choice == 7)
[L2077]        COND TRUE   choice == 6
[L2079]                    gas := gas - 21000;
[L2080]        COND TRUE   gas >= 0
[L2082]                    assume msgvalue_MSG == 0;
[L2083]        CALL        call setGoalReached_EscrowVault__success(from, to, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L2083]        RET         call setGoalReached_EscrowVault__success(from, to, msgvalue_MSG);
[L2084]        COND FALSE  !(revert)
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:23,112 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:23,112 INFO  L82        PathProgramCache]: Analyzing trace with hash 570077713, now seen corresponding path program 1 times
[2020-05-30 23:29:23,112 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:23,126 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:23,183 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:23,183 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:23,184 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 23:29:23,184 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:23,184 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 23:29:23,184 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=11, Invalid=19, Unknown=0, NotChecked=0, Total=30
[2020-05-30 23:29:23,185 INFO  L87              Difference]: Start difference. First operand 9638 states and 11163 transitions. cyclomatic complexity: 1549 Second operand 6 states.
[2020-05-30 23:29:24,385 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:24,386 INFO  L93              Difference]: Finished difference Result 8302 states and 9259 transitions.
[2020-05-30 23:29:24,386 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 23:29:24,386 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8302 states and 9259 transitions.
[2020-05-30 23:29:24,405 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 23:29:24,425 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8302 states to 8142 states and 9083 transitions.
[2020-05-30 23:29:24,425 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 272
[2020-05-30 23:29:24,426 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 680
[2020-05-30 23:29:24,426 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8142 states and 9083 transitions.
[2020-05-30 23:29:24,430 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:24,430 INFO  L728         BuchiCegarLoop]: Abstraction has 8142 states and 9083 transitions.
[2020-05-30 23:29:24,435 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8142 states and 9083 transitions.
[2020-05-30 23:29:24,472 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8142 to 7502.
[2020-05-30 23:29:24,472 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7502 states.
[2020-05-30 23:29:24,480 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7502 states to 7502 states and 8311 transitions.
[2020-05-30 23:29:24,480 INFO  L751         BuchiCegarLoop]: Abstraction has 7502 states and 8311 transitions.
[2020-05-30 23:29:24,480 INFO  L631         BuchiCegarLoop]: Abstraction has 7502 states and 8311 transitions.
[2020-05-30 23:29:24,480 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 23:29:24,480 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7502 states and 8311 transitions.
[2020-05-30 23:29:24,487 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:24,487 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:24,487 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:24,488 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:24,488 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND TRUE   choice == 6
[L2476]                    gas := gas - 21000;
[L2477]        COND TRUE   gas >= 0
[L2479]                    assume msgvalue_MSG == 0;
[L2480]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2480]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND TRUE   choice == 6
[L2476]              gas := gas - 21000;
[L2477]  COND TRUE   gas >= 0
[L2479]              assume msgvalue_MSG == 0;
[L2480]  CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]               havoc __exception;
[L342]               revert := false;
[L343]   COND FALSE  !(__exception)
[L363]   CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]              gas := gas - 1932;
[L2311]  COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]  COND FALSE  !(revert)
[L1419]              gas := gas - 367;
[L1420]  COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]              gas := gas - 20337;
[L1427]              state_EscrowVault[this] := 2;
[L1428]              assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]   RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]               assume !revert && gas >= 0;
[L2480]  RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:24,491 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:24,491 INFO  L82        PathProgramCache]: Analyzing trace with hash 2127768778, now seen corresponding path program 1 times
[2020-05-30 23:29:24,492 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:24,502 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:24,555 INFO  L134       CoverageAnalysis]: Checked inductivity of 37 backedges. 2 proven. 25 refuted. 0 times theorem prover too weak. 10 trivial. 0 not checked.
[2020-05-30 23:29:24,555 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:29:24,556 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 23:29:24,556 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:24,556 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:29:24,556 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:29:24,556 INFO  L87              Difference]: Start difference. First operand 7502 states and 8311 transitions. cyclomatic complexity: 817 Second operand 11 states.
[2020-05-30 23:29:28,047 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:29:28,047 INFO  L93              Difference]: Finished difference Result 7530 states and 8359 transitions.
[2020-05-30 23:29:28,048 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 23:29:28,048 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7530 states and 8359 transitions.
[2020-05-30 23:29:28,062 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:28,076 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7530 states to 7530 states and 8359 transitions.
[2020-05-30 23:29:28,077 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 626
[2020-05-30 23:29:28,077 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 626
[2020-05-30 23:29:28,077 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7530 states and 8359 transitions.
[2020-05-30 23:29:28,080 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:29:28,080 INFO  L728         BuchiCegarLoop]: Abstraction has 7530 states and 8359 transitions.
[2020-05-30 23:29:28,085 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7530 states and 8359 transitions.
[2020-05-30 23:29:28,115 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7530 to 7494.
[2020-05-30 23:29:28,115 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7494 states.
[2020-05-30 23:29:28,122 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7494 states to 7494 states and 8295 transitions.
[2020-05-30 23:29:28,122 INFO  L751         BuchiCegarLoop]: Abstraction has 7494 states and 8295 transitions.
[2020-05-30 23:29:28,122 INFO  L631         BuchiCegarLoop]: Abstraction has 7494 states and 8295 transitions.
[2020-05-30 23:29:28,122 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 23:29:28,122 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7494 states and 8295 transitions.
[2020-05-30 23:29:28,129 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 23:29:28,129 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:29:28,129 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:29:28,130 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:29:28,130 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:29:28,133 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:29:28,133 INFO  L82        PathProgramCache]: Analyzing trace with hash -1314151121, now seen corresponding path program 1 times
[2020-05-30 23:29:28,134 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:29:28,149 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:29:28,445 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:29:28,445 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:29:28,445 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [41] imperfect sequences [] total 41
[2020-05-30 23:29:28,445 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:29:28,446 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 42 interpolants.
[2020-05-30 23:29:28,446 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=120, Invalid=1602, Unknown=0, NotChecked=0, Total=1722
[2020-05-30 23:29:28,446 INFO  L87              Difference]: Start difference. First operand 7494 states and 8295 transitions. cyclomatic complexity: 809 Second operand 42 states.
[2020-05-30 23:30:03,819 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:30:03,819 INFO  L93              Difference]: Finished difference Result 16618 states and 19436 transitions.
[2020-05-30 23:30:03,819 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 84 states. 
[2020-05-30 23:30:03,819 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16618 states and 19436 transitions.
[2020-05-30 23:30:03,862 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:03,909 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16618 states to 16618 states and 19436 transitions.
[2020-05-30 23:30:03,909 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1429
[2020-05-30 23:30:03,910 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1429
[2020-05-30 23:30:03,910 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 16618 states and 19436 transitions.
[2020-05-30 23:30:03,919 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:30:03,920 INFO  L728         BuchiCegarLoop]: Abstraction has 16618 states and 19436 transitions.
[2020-05-30 23:30:03,926 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 16618 states and 19436 transitions.
[2020-05-30 23:30:04,068 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 16618 to 15821.
[2020-05-30 23:30:04,068 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15821 states.
[2020-05-30 23:30:04,088 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15821 states to 15821 states and 17955 transitions.
[2020-05-30 23:30:04,088 INFO  L751         BuchiCegarLoop]: Abstraction has 15821 states and 17955 transitions.
[2020-05-30 23:30:04,088 INFO  L631         BuchiCegarLoop]: Abstraction has 15821 states and 17955 transitions.
[2020-05-30 23:30:04,088 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 23:30:04,088 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15821 states and 17955 transitions.
[2020-05-30 23:30:04,107 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:04,107 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:30:04,107 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:30:04,108 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:30:04,108 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:30:04,111 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:30:04,112 INFO  L82        PathProgramCache]: Analyzing trace with hash 2120575449, now seen corresponding path program 1 times
[2020-05-30 23:30:04,112 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:30:04,187 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:30:04,442 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:30:04,442 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:30:04,442 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [39] imperfect sequences [] total 39
[2020-05-30 23:30:04,442 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:30:04,443 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 40 interpolants.
[2020-05-30 23:30:04,443 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=143, Invalid=1417, Unknown=0, NotChecked=0, Total=1560
[2020-05-30 23:30:04,443 INFO  L87              Difference]: Start difference. First operand 15821 states and 17955 transitions. cyclomatic complexity: 2166 Second operand 40 states.
[2020-05-30 23:30:25,698 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:30:25,699 INFO  L93              Difference]: Finished difference Result 20987 states and 24436 transitions.
[2020-05-30 23:30:25,699 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 67 states. 
[2020-05-30 23:30:25,699 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20987 states and 24436 transitions.
[2020-05-30 23:30:25,747 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:25,806 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20987 states to 20987 states and 24436 transitions.
[2020-05-30 23:30:25,806 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1439
[2020-05-30 23:30:25,807 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1439
[2020-05-30 23:30:25,807 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20987 states and 24436 transitions.
[2020-05-30 23:30:25,820 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:30:25,820 INFO  L728         BuchiCegarLoop]: Abstraction has 20987 states and 24436 transitions.
[2020-05-30 23:30:25,828 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20987 states and 24436 transitions.
[2020-05-30 23:30:25,969 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20987 to 20134.
[2020-05-30 23:30:25,969 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20134 states.
[2020-05-30 23:30:25,999 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20134 states to 20134 states and 23115 transitions.
[2020-05-30 23:30:25,999 INFO  L751         BuchiCegarLoop]: Abstraction has 20134 states and 23115 transitions.
[2020-05-30 23:30:25,999 INFO  L631         BuchiCegarLoop]: Abstraction has 20134 states and 23115 transitions.
[2020-05-30 23:30:25,999 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 23:30:25,999 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20134 states and 23115 transitions.
[2020-05-30 23:30:26,022 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:26,022 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:30:26,022 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:30:26,023 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:30:26,023 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:30:26,026 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:30:26,026 INFO  L82        PathProgramCache]: Analyzing trace with hash 1028063106, now seen corresponding path program 1 times
[2020-05-30 23:30:26,027 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:30:26,036 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:30:26,084 INFO  L134       CoverageAnalysis]: Checked inductivity of 6 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:30:26,084 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:30:26,084 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 23:30:26,084 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:30:26,084 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 23:30:26,084 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-30 23:30:26,085 INFO  L87              Difference]: Start difference. First operand 20134 states and 23115 transitions. cyclomatic complexity: 3035 Second operand 10 states.
[2020-05-30 23:30:30,100 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:30:30,100 INFO  L93              Difference]: Finished difference Result 20292 states and 23620 transitions.
[2020-05-30 23:30:30,100 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 23:30:30,101 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20292 states and 23620 transitions.
[2020-05-30 23:30:30,154 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:30,215 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20292 states to 20292 states and 23620 transitions.
[2020-05-30 23:30:30,215 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1329
[2020-05-30 23:30:30,216 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1329
[2020-05-30 23:30:30,216 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20292 states and 23620 transitions.
[2020-05-30 23:30:30,229 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:30:30,230 INFO  L728         BuchiCegarLoop]: Abstraction has 20292 states and 23620 transitions.
[2020-05-30 23:30:30,239 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20292 states and 23620 transitions.
[2020-05-30 23:30:30,379 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20292 to 20183.
[2020-05-30 23:30:30,379 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20183 states.
[2020-05-30 23:30:30,506 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20183 states to 20183 states and 23308 transitions.
[2020-05-30 23:30:30,506 INFO  L751         BuchiCegarLoop]: Abstraction has 20183 states and 23308 transitions.
[2020-05-30 23:30:30,506 INFO  L631         BuchiCegarLoop]: Abstraction has 20183 states and 23308 transitions.
[2020-05-30 23:30:30,506 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 23:30:30,507 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20183 states and 23308 transitions.
[2020-05-30 23:30:30,530 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:30,530 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:30:30,530 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:30:30,531 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:30:30,531 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND TRUE   choice == 5
[L2485]                    gas := gas - 21000;
[L2486]        COND TRUE   gas >= 0
[L2488]                    assume msgvalue_MSG == 0;
[L2489]        CALL        call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L379]                     havoc __exception;
[L380]                     revert := false;
[L381]         COND FALSE  !(__exception)
[L401]         CALL        call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L1491]                    gas := gas - 276;
[L1492]        COND FALSE  !(!(msgsender_MSG == superOwner_EscrowVault[this]))
[L1498]                    gas := gas - 367;
[L1499]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1505]                    gas := gas - 468;
[L1506]                    assume _amount_s320 >= 0;
[L1507]                    __var_6 := this;
[L1508]                    assume Balance[this] >= 0;
[L1509]                    assume _amount_s320 >= 0;
[L1510]        COND FALSE  !(!(_amount_s320 <= Balance[this] && _amount_s320 > 0))
[L1516]                    gas := gas - 36029;
[L1517]                    __var_7 := gas;
[L1518]        COND FALSE  !(gas > 2300)
[L1523]                    __var_7 := __var_7 - gas;
[L1524]                    assume _amount_s320 >= 0;
[L1525]        CALL        call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1525]        RET         call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1526]        COND FALSE  !(!__var_8)
[L1532]                    gas := __var_7 + gas;
[L1533]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L401]         RET         call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L402]                     assume !revert && gas >= 0;
[L2489]        RET         call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:30:30,538 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:30:30,538 INFO  L82        PathProgramCache]: Analyzing trace with hash 1147815335, now seen corresponding path program 1 times
[2020-05-30 23:30:30,538 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:30:30,551 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:30:30,621 INFO  L134       CoverageAnalysis]: Checked inductivity of 30 backedges. 1 proven. 23 refuted. 0 times theorem prover too weak. 6 trivial. 0 not checked.
[2020-05-30 23:30:30,621 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:30:30,621 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 23:30:30,621 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:30:30,622 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:30:30,622 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:30:30,622 INFO  L87              Difference]: Start difference. First operand 20183 states and 23308 transitions. cyclomatic complexity: 3188 Second operand 11 states.
[2020-05-30 23:30:34,794 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:30:34,794 INFO  L93              Difference]: Finished difference Result 20438 states and 23886 transitions.
[2020-05-30 23:30:34,794 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 23:30:34,794 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20438 states and 23886 transitions.
[2020-05-30 23:30:34,848 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:34,911 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20438 states to 20438 states and 23886 transitions.
[2020-05-30 23:30:34,911 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1335
[2020-05-30 23:30:34,911 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1335
[2020-05-30 23:30:34,912 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20438 states and 23886 transitions.
[2020-05-30 23:30:34,926 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:30:34,926 INFO  L728         BuchiCegarLoop]: Abstraction has 20438 states and 23886 transitions.
[2020-05-30 23:30:34,935 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20438 states and 23886 transitions.
[2020-05-30 23:30:35,078 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20438 to 20218.
[2020-05-30 23:30:35,078 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20218 states.
[2020-05-30 23:30:35,109 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20218 states to 20218 states and 23382 transitions.
[2020-05-30 23:30:35,109 INFO  L751         BuchiCegarLoop]: Abstraction has 20218 states and 23382 transitions.
[2020-05-30 23:30:35,109 INFO  L631         BuchiCegarLoop]: Abstraction has 20218 states and 23382 transitions.
[2020-05-30 23:30:35,110 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 23:30:35,110 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20218 states and 23382 transitions.
[2020-05-30 23:30:35,132 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:30:35,132 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:30:35,132 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:30:35,133 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:30:35,133 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:30:35,137 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:30:35,137 INFO  L82        PathProgramCache]: Analyzing trace with hash -238234594, now seen corresponding path program 1 times
[2020-05-30 23:30:35,138 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:30:35,170 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:30:35,435 INFO  L134       CoverageAnalysis]: Checked inductivity of 88 backedges. 12 proven. 17 refuted. 0 times theorem prover too weak. 59 trivial. 0 not checked.
[2020-05-30 23:30:35,436 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:30:35,436 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [32] total 32
[2020-05-30 23:30:35,436 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:30:35,437 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 33 interpolants.
[2020-05-30 23:30:35,437 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=87, Invalid=969, Unknown=0, NotChecked=0, Total=1056
[2020-05-30 23:30:35,437 INFO  L87              Difference]: Start difference. First operand 20218 states and 23382 transitions. cyclomatic complexity: 3227 Second operand 33 states.
[2020-05-30 23:31:00,114 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:31:00,114 INFO  L93              Difference]: Finished difference Result 20446 states and 23964 transitions.
[2020-05-30 23:31:00,114 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 48 states. 
[2020-05-30 23:31:00,115 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20446 states and 23964 transitions.
[2020-05-30 23:31:00,164 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:31:00,224 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20446 states to 20446 states and 23964 transitions.
[2020-05-30 23:31:00,224 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1331
[2020-05-30 23:31:00,225 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1331
[2020-05-30 23:31:00,225 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20446 states and 23964 transitions.
[2020-05-30 23:31:00,239 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:31:00,239 INFO  L728         BuchiCegarLoop]: Abstraction has 20446 states and 23964 transitions.
[2020-05-30 23:31:00,247 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20446 states and 23964 transitions.
[2020-05-30 23:31:00,386 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20446 to 20220.
[2020-05-30 23:31:00,387 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20220 states.
[2020-05-30 23:31:00,418 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20220 states to 20220 states and 23372 transitions.
[2020-05-30 23:31:00,418 INFO  L751         BuchiCegarLoop]: Abstraction has 20220 states and 23372 transitions.
[2020-05-30 23:31:00,418 INFO  L631         BuchiCegarLoop]: Abstraction has 20220 states and 23372 transitions.
[2020-05-30 23:31:00,419 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 23:31:00,419 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20220 states and 23372 transitions.
[2020-05-30 23:31:00,441 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 14
[2020-05-30 23:31:00,442 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:31:00,442 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:31:00,443 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:31:00,443 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:31:00,447 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:31:00,447 INFO  L82        PathProgramCache]: Analyzing trace with hash -1277148584, now seen corresponding path program 1 times
[2020-05-30 23:31:00,447 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:31:00,465 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:31:00,824 INFO  L134       CoverageAnalysis]: Checked inductivity of 97 backedges. 4 proven. 40 refuted. 0 times theorem prover too weak. 53 trivial. 0 not checked.
[2020-05-30 23:31:00,824 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:31:00,824 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [47] total 47
[2020-05-30 23:31:00,825 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:31:00,825 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 48 interpolants.
[2020-05-30 23:31:00,825 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=178, Invalid=2078, Unknown=0, NotChecked=0, Total=2256
[2020-05-30 23:31:00,826 INFO  L87              Difference]: Start difference. First operand 20220 states and 23372 transitions. cyclomatic complexity: 3214 Second operand 48 states.
[2020-05-30 23:31:53,053 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:31:53,053 INFO  L93              Difference]: Finished difference Result 21331 states and 26317 transitions.
[2020-05-30 23:31:53,054 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 82 states. 
[2020-05-30 23:31:53,054 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21331 states and 26317 transitions.
[2020-05-30 23:31:53,113 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 28
[2020-05-30 23:31:53,186 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21331 states to 21331 states and 26317 transitions.
[2020-05-30 23:31:53,186 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1456
[2020-05-30 23:31:53,187 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1456
[2020-05-30 23:31:53,187 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21331 states and 26317 transitions.
[2020-05-30 23:31:53,203 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:31:53,203 INFO  L728         BuchiCegarLoop]: Abstraction has 21331 states and 26317 transitions.
[2020-05-30 23:31:53,212 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21331 states and 26317 transitions.
[2020-05-30 23:31:53,377 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21331 to 20712.
[2020-05-30 23:31:53,378 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20712 states.
[2020-05-30 23:31:53,413 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20712 states to 20712 states and 24728 transitions.
[2020-05-30 23:31:53,413 INFO  L751         BuchiCegarLoop]: Abstraction has 20712 states and 24728 transitions.
[2020-05-30 23:31:53,413 INFO  L631         BuchiCegarLoop]: Abstraction has 20712 states and 24728 transitions.
[2020-05-30 23:31:53,413 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 23:31:53,414 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20712 states and 24728 transitions.
[2020-05-30 23:31:53,437 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 24
[2020-05-30 23:31:53,437 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:31:53,437 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:31:53,438 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:31:53,438 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:31:53,442 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:31:53,442 INFO  L82        PathProgramCache]: Analyzing trace with hash 26224912, now seen corresponding path program 1 times
[2020-05-30 23:31:53,442 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:31:53,464 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:31:53,759 INFO  L134       CoverageAnalysis]: Checked inductivity of 96 backedges. 4 proven. 39 refuted. 0 times theorem prover too weak. 53 trivial. 0 not checked.
[2020-05-30 23:31:53,759 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:31:53,759 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 23:31:53,760 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:31:53,760 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 23:31:53,760 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=184, Invalid=1708, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 23:31:53,760 INFO  L87              Difference]: Start difference. First operand 20712 states and 24728 transitions. cyclomatic complexity: 4112 Second operand 44 states.
[2020-05-30 23:32:26,179 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:26,179 INFO  L93              Difference]: Finished difference Result 21392 states and 26689 transitions.
[2020-05-30 23:32:26,180 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 23:32:26,180 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 21392 states and 26689 transitions.
[2020-05-30 23:32:26,237 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 24
[2020-05-30 23:32:26,313 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 21392 states to 21392 states and 26689 transitions.
[2020-05-30 23:32:26,313 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1442
[2020-05-30 23:32:26,314 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1442
[2020-05-30 23:32:26,314 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 21392 states and 26689 transitions.
[2020-05-30 23:32:26,331 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:26,331 INFO  L728         BuchiCegarLoop]: Abstraction has 21392 states and 26689 transitions.
[2020-05-30 23:32:26,340 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 21392 states and 26689 transitions.
[2020-05-30 23:32:26,509 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 21392 to 20884.
[2020-05-30 23:32:26,509 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20884 states.
[2020-05-30 23:32:26,548 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20884 states to 20884 states and 25418 transitions.
[2020-05-30 23:32:26,548 INFO  L751         BuchiCegarLoop]: Abstraction has 20884 states and 25418 transitions.
[2020-05-30 23:32:26,548 INFO  L631         BuchiCegarLoop]: Abstraction has 20884 states and 25418 transitions.
[2020-05-30 23:32:26,548 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 23:32:26,548 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20884 states and 25418 transitions.
[2020-05-30 23:32:26,572 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 24
[2020-05-30 23:32:26,572 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:26,572 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:26,573 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:26,573 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND TRUE   choice == 6
[L2476]                    gas := gas - 21000;
[L2477]        COND TRUE   gas >= 0
[L2479]                    assume msgvalue_MSG == 0;
[L2480]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2480]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:26,576 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:26,576 INFO  L82        PathProgramCache]: Analyzing trace with hash -194990632, now seen corresponding path program 1 times
[2020-05-30 23:32:26,577 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:26,589 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:26,653 INFO  L134       CoverageAnalysis]: Checked inductivity of 34 backedges. 24 proven. 0 refuted. 0 times theorem prover too weak. 10 trivial. 0 not checked.
[2020-05-30 23:32:26,653 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:32:26,653 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 23:32:26,654 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:26,654 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:32:26,654 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:32:26,654 INFO  L87              Difference]: Start difference. First operand 20884 states and 25418 transitions. cyclomatic complexity: 4650 Second operand 11 states.
[2020-05-30 23:32:34,356 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:34,356 INFO  L93              Difference]: Finished difference Result 23422 states and 29765 transitions.
[2020-05-30 23:32:34,356 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 23:32:34,357 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 23422 states and 29765 transitions.
[2020-05-30 23:32:34,433 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 38
[2020-05-30 23:32:34,533 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 23422 states to 23282 states and 29605 transitions.
[2020-05-30 23:32:34,533 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1462
[2020-05-30 23:32:34,534 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1462
[2020-05-30 23:32:34,534 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 23282 states and 29605 transitions.
[2020-05-30 23:32:34,554 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:34,554 INFO  L728         BuchiCegarLoop]: Abstraction has 23282 states and 29605 transitions.
[2020-05-30 23:32:34,566 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 23282 states and 29605 transitions.
[2020-05-30 23:32:34,765 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 23282 to 23177.
[2020-05-30 23:32:34,766 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 23177 states.
[2020-05-30 23:32:34,815 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 23177 states to 23177 states and 29172 transitions.
[2020-05-30 23:32:34,816 INFO  L751         BuchiCegarLoop]: Abstraction has 23177 states and 29172 transitions.
[2020-05-30 23:32:34,816 INFO  L631         BuchiCegarLoop]: Abstraction has 23177 states and 29172 transitions.
[2020-05-30 23:32:34,816 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 23:32:34,816 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 23177 states and 29172 transitions.
[2020-05-30 23:32:34,844 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 38
[2020-05-30 23:32:34,844 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:34,844 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:34,845 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:34,845 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND TRUE   choice == 3
[L2503]                    gas := gas - 21000;
[L2504]        COND TRUE   gas >= 0
[L2506]                    assume msgvalue_MSG == 0;
[L2507]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND FALSE  !(Balance[from] >= amount)
[L2287]                    success := false;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2507]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:34,849 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:34,849 INFO  L82        PathProgramCache]: Analyzing trace with hash -570523169, now seen corresponding path program 1 times
[2020-05-30 23:32:34,850 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:34,866 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:34,933 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 77 trivial. 0 not checked.
[2020-05-30 23:32:34,933 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:32:34,933 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 23:32:34,934 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:34,934 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 23:32:34,934 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 23:32:34,934 INFO  L87              Difference]: Start difference. First operand 23177 states and 29172 transitions. cyclomatic complexity: 6111 Second operand 4 states.
[2020-05-30 23:32:35,151 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:35,152 INFO  L93              Difference]: Finished difference Result 23217 states and 29192 transitions.
[2020-05-30 23:32:35,152 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 23:32:35,152 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 23217 states and 29192 transitions.
[2020-05-30 23:32:35,302 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 38
[2020-05-30 23:32:35,373 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 23217 states to 23177 states and 29152 transitions.
[2020-05-30 23:32:35,373 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1454
[2020-05-30 23:32:35,374 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1454
[2020-05-30 23:32:35,374 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 23177 states and 29152 transitions.
[2020-05-30 23:32:35,391 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:35,391 INFO  L728         BuchiCegarLoop]: Abstraction has 23177 states and 29152 transitions.
[2020-05-30 23:32:35,400 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 23177 states and 29152 transitions.
[2020-05-30 23:32:35,581 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 23177 to 23177.
[2020-05-30 23:32:35,581 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 23177 states.
[2020-05-30 23:32:35,628 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 23177 states to 23177 states and 29152 transitions.
[2020-05-30 23:32:35,628 INFO  L751         BuchiCegarLoop]: Abstraction has 23177 states and 29152 transitions.
[2020-05-30 23:32:35,628 INFO  L631         BuchiCegarLoop]: Abstraction has 23177 states and 29152 transitions.
[2020-05-30 23:32:35,628 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 23:32:35,628 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 23177 states and 29152 transitions.
[2020-05-30 23:32:35,654 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 38
[2020-05-30 23:32:35,654 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:35,654 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:35,656 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:35,656 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND TRUE   choice == 3
[L2503]                    gas := gas - 21000;
[L2504]        COND TRUE   gas >= 0
[L2506]                    assume msgvalue_MSG == 0;
[L2507]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2507]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:35,674 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:35,674 INFO  L82        PathProgramCache]: Analyzing trace with hash 2122011252, now seen corresponding path program 1 times
[2020-05-30 23:32:35,674 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:35,690 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:35,779 INFO  L134       CoverageAnalysis]: Checked inductivity of 81 backedges. 2 proven. 29 refuted. 0 times theorem prover too weak. 50 trivial. 0 not checked.
[2020-05-30 23:32:35,779 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:32:35,779 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 23:32:35,779 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:35,779 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:32:35,779 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:32:35,780 INFO  L87              Difference]: Start difference. First operand 23177 states and 29152 transitions. cyclomatic complexity: 6091 Second operand 11 states.
[2020-05-30 23:32:42,032 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:42,033 INFO  L93              Difference]: Finished difference Result 27034 states and 35525 transitions.
[2020-05-30 23:32:42,033 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 23:32:42,033 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 27034 states and 35525 transitions.
[2020-05-30 23:32:42,132 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 54
[2020-05-30 23:32:42,258 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 27034 states to 25581 states and 33014 transitions.
[2020-05-30 23:32:42,259 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1615
[2020-05-30 23:32:42,260 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1615
[2020-05-30 23:32:42,260 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 25581 states and 33014 transitions.
[2020-05-30 23:32:42,284 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:42,285 INFO  L728         BuchiCegarLoop]: Abstraction has 25581 states and 33014 transitions.
[2020-05-30 23:32:42,296 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 25581 states and 33014 transitions.
[2020-05-30 23:32:42,515 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 25581 to 25442.
[2020-05-30 23:32:42,515 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 25442 states.
[2020-05-30 23:32:42,574 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 25442 states to 25442 states and 32503 transitions.
[2020-05-30 23:32:42,574 INFO  L751         BuchiCegarLoop]: Abstraction has 25442 states and 32503 transitions.
[2020-05-30 23:32:42,574 INFO  L631         BuchiCegarLoop]: Abstraction has 25442 states and 32503 transitions.
[2020-05-30 23:32:42,574 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 23:32:42,574 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 25442 states and 32503 transitions.
[2020-05-30 23:32:42,605 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 54
[2020-05-30 23:32:42,605 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:42,606 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:42,607 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:42,607 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND TRUE   __exception
[L269]                     __tmp__Balance := Balance;
[L270]                     __tmp__DType := DType;
[L271]                     __tmp__Alloc := Alloc;
[L272]                     __tmp__balance_ADDR := balance_ADDR;
[L273]                     __tmp__M_Ref_int_deposited0 := M_Ref_int_deposited0;
[L274]                     __tmp__sum_deposited0 := sum_deposited0;
[L275]                     __tmp__Length := Length;
[L276]                     __tmp__now := now;
[L277]                     __tmp__owner_Ownable := owner_Ownable;
[L278]                     __tmp__deposited_EscrowVault := deposited_EscrowVault;
[L279]                     __tmp__beneficiary_EscrowVault := beneficiary_EscrowVault;
[L280]                     __tmp__superOwner_EscrowVault := superOwner_EscrowVault;
[L281]                     __tmp__state_EscrowVault := state_EscrowVault;
[L282]         CALL        call EscrowVault_EscrowVault__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1268]        CALL        call Ownable_Ownable__fail(this, msgsender_MSG, msgvalue_MSG);
[L1101]        CALL        call Ownable_Ownable_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1081]                    assume msgsender_MSG != null;
[L1082]                    __tmp__Balance[this] := 0;
[L1083]                    __tmp__owner_Ownable[this] := null;
[L1084]                    __tmp__owner_Ownable[this] := msgsender_MSG;
[L1101]        RET         call Ownable_Ownable_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1102]        COND FALSE  !(revert)
[L1268]        RET         call Ownable_Ownable__fail(this, msgsender_MSG, msgvalue_MSG);
[L1269]        COND FALSE  !(revert)
[L1274]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1180]                    assume msgsender_MSG != null;
[L1181]                    __tmp__Balance[this] := 0;
[L1182]        CALL        call __var_4 := FreshRefGenerator__fail();
[L823]                     havoc newRef;
[L824]                     assume __tmp__Alloc[newRef] == false;
[L825]                     __tmp__Alloc[newRef] := true;
[L826]                     assume newRef != null;
[L1182]        RET         call __var_4 := FreshRefGenerator__fail();
[L1183]        COND FALSE  !(revert)
[L1188]                    __tmp__deposited_EscrowVault[this] := __var_4;
[L1189]                    __tmp__M_Ref_int_deposited0[__tmp__deposited_EscrowVault[this]] := zeroRefIntArr();
[L1190]                    __tmp__sum_deposited0[__tmp__deposited_EscrowVault[this]] := 0;
[L1191]                    __tmp__beneficiary_EscrowVault[this] := null;
[L1192]                    __tmp__superOwner_EscrowVault[this] := null;
[L1193]                    __var_2 := null;
[L1194]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1200]                    __var_3 := null;
[L1201]        COND FALSE  !(!(_superOwner_s224 != null))
[L1207]                    __tmp__beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1208]                    __tmp__superOwner_EscrowVault[this] := _superOwner_s224;
[L1209]                    __tmp__state_EscrowVault[this] := 0;
[L1274]        RET         call EscrowVault_EscrowVault_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1275]        COND FALSE  !(revert)
[L282]         RET         call EscrowVault_EscrowVault__fail(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L283]                     assume revert || gas < 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND TRUE   choice == 5
[L2485]              gas := gas - 21000;
[L2486]  COND TRUE   gas >= 0
[L2488]              assume msgvalue_MSG == 0;
[L2489]  CALL        call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L379]               havoc __exception;
[L380]               revert := false;
[L381]   COND FALSE  !(__exception)
[L401]   CALL        call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L1491]              gas := gas - 276;
[L1492]  COND FALSE  !(!(msgsender_MSG == superOwner_EscrowVault[this]))
[L1498]              gas := gas - 367;
[L1499]  COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1505]              gas := gas - 468;
[L1506]              assume _amount_s320 >= 0;
[L1507]              __var_6 := this;
[L1508]              assume Balance[this] >= 0;
[L1509]              assume _amount_s320 >= 0;
[L1510]  COND FALSE  !(!(_amount_s320 <= Balance[this] && _amount_s320 > 0))
[L1516]              gas := gas - 36029;
[L1517]              __var_7 := gas;
[L1518]  COND FALSE  !(gas > 2300)
[L1523]              __var_7 := __var_7 - gas;
[L1524]              assume _amount_s320 >= 0;
[L1525]  CALL        call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L2253]              havoc __exception;
[L2254]  COND FALSE  !(__exception)
[L2280]  COND TRUE   Balance[from] >= amount
[L2282]  CALL        call FallbackDispatch__success(from, to, amount);
[L1848]  COND FALSE  !(DType[to] == EscrowVault)
[L1852]  COND FALSE  !(DType[to] == Ownable)
[L1858]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]              assume Balance[from] >= amount;
[L2036]              Balance[from] := Balance[from] - amount;
[L2037]              Balance[to] := Balance[to] + amount;
[L2038]  COND FALSE  !(choice == 0)
[L2044]  COND TRUE   gas < 21000
[L1858]  RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]  COND FALSE  !(revert)
[L2282]  RET         call FallbackDispatch__success(from, to, amount);
[L2283]              success := true;
[L2290]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                 revert := revert_hold;
[L1525]  RET         call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1526]  COND FALSE  !(!__var_8)
[L1532]              gas := __var_7 + gas;
[L1533]              assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L401]   RET         call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L402]               assume !revert && gas >= 0;
[L2489]  RET         call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:42,609 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:42,610 INFO  L82        PathProgramCache]: Analyzing trace with hash -639928804, now seen corresponding path program 1 times
[2020-05-30 23:32:42,610 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:42,618 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:42,652 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 23:32:42,652 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:32:42,652 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 23:32:42,653 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:42,653 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 23:32:42,653 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 23:32:42,653 INFO  L87              Difference]: Start difference. First operand 25442 states and 32503 transitions. cyclomatic complexity: 7199 Second operand 4 states.
[2020-05-30 23:32:45,236 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:45,236 INFO  L93              Difference]: Finished difference Result 40015 states and 68174 transitions.
[2020-05-30 23:32:45,236 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 23:32:45,236 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 40015 states and 68174 transitions.
[2020-05-30 23:32:45,478 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 216
[2020-05-30 23:32:45,837 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 40015 states to 39946 states and 68105 transitions.
[2020-05-30 23:32:45,838 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2358
[2020-05-30 23:32:45,840 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2358
[2020-05-30 23:32:45,840 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 39946 states and 68105 transitions.
[2020-05-30 23:32:46,035 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:46,035 INFO  L728         BuchiCegarLoop]: Abstraction has 39946 states and 68105 transitions.
[2020-05-30 23:32:46,046 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 39946 states and 68105 transitions.
[2020-05-30 23:32:46,547 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 39946 to 26294.
[2020-05-30 23:32:46,548 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 26294 states.
[2020-05-30 23:32:46,609 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 26294 states to 26294 states and 33742 transitions.
[2020-05-30 23:32:46,610 INFO  L751         BuchiCegarLoop]: Abstraction has 26294 states and 33742 transitions.
[2020-05-30 23:32:46,610 INFO  L631         BuchiCegarLoop]: Abstraction has 26294 states and 33742 transitions.
[2020-05-30 23:32:46,610 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 23:32:46,610 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 26294 states and 33742 transitions.
[2020-05-30 23:32:46,644 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 58
[2020-05-30 23:32:46,644 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:46,644 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:46,645 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:46,645 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND TRUE   choice == 3
[L2503]                    gas := gas - 21000;
[L2504]        COND TRUE   gas >= 0
[L2506]                    assume msgvalue_MSG == 0;
[L2507]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2507]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:46,657 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:46,657 INFO  L82        PathProgramCache]: Analyzing trace with hash 48424365, now seen corresponding path program 1 times
[2020-05-30 23:32:46,658 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:46,668 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:46,729 INFO  L134       CoverageAnalysis]: Checked inductivity of 56 backedges. 1 proven. 27 refuted. 0 times theorem prover too weak. 28 trivial. 0 not checked.
[2020-05-30 23:32:46,729 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:32:46,729 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 23:32:46,729 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:46,729 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:32:46,729 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:32:46,730 INFO  L87              Difference]: Start difference. First operand 26294 states and 33742 transitions. cyclomatic complexity: 7586 Second operand 11 states.
[2020-05-30 23:32:50,240 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:50,240 INFO  L93              Difference]: Finished difference Result 26294 states and 33704 transitions.
[2020-05-30 23:32:50,240 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 11 states. 
[2020-05-30 23:32:50,240 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 26294 states and 33704 transitions.
[2020-05-30 23:32:50,328 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 58
[2020-05-30 23:32:50,447 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 26294 states to 26294 states and 33704 transitions.
[2020-05-30 23:32:50,447 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1749
[2020-05-30 23:32:50,448 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1749
[2020-05-30 23:32:50,448 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 26294 states and 33704 transitions.
[2020-05-30 23:32:50,473 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:50,473 INFO  L728         BuchiCegarLoop]: Abstraction has 26294 states and 33704 transitions.
[2020-05-30 23:32:50,485 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 26294 states and 33704 transitions.
[2020-05-30 23:32:50,706 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 26294 to 26294.
[2020-05-30 23:32:50,707 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 26294 states.
[2020-05-30 23:32:50,767 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 26294 states to 26294 states and 33704 transitions.
[2020-05-30 23:32:50,767 INFO  L751         BuchiCegarLoop]: Abstraction has 26294 states and 33704 transitions.
[2020-05-30 23:32:50,768 INFO  L631         BuchiCegarLoop]: Abstraction has 26294 states and 33704 transitions.
[2020-05-30 23:32:50,768 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 23:32:50,768 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 26294 states and 33704 transitions.
[2020-05-30 23:32:50,799 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 58
[2020-05-30 23:32:50,800 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:50,800 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:50,801 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:50,801 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND TRUE   choice == 3
[L2503]                    gas := gas - 21000;
[L2504]        COND TRUE   gas >= 0
[L2506]                    assume msgvalue_MSG == 0;
[L2507]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2507]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:50,804 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:50,804 INFO  L82        PathProgramCache]: Analyzing trace with hash -1701084351, now seen corresponding path program 1 times
[2020-05-30 23:32:50,804 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:50,820 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:50,904 INFO  L134       CoverageAnalysis]: Checked inductivity of 141 backedges. 37 proven. 29 refuted. 0 times theorem prover too weak. 75 trivial. 0 not checked.
[2020-05-30 23:32:50,904 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:32:50,904 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 23:32:50,905 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:50,905 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:32:50,905 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:32:50,905 INFO  L87              Difference]: Start difference. First operand 26294 states and 33704 transitions. cyclomatic complexity: 7548 Second operand 11 states.
[2020-05-30 23:32:55,887 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:55,887 INFO  L93              Difference]: Finished difference Result 22480 states and 26736 transitions.
[2020-05-30 23:32:55,887 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 23:32:55,887 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 22480 states and 26736 transitions.
[2020-05-30 23:32:55,942 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 16
[2020-05-30 23:32:55,993 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 22480 states to 15588 states and 18845 transitions.
[2020-05-30 23:32:55,993 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1309
[2020-05-30 23:32:55,994 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1361
[2020-05-30 23:32:55,994 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15588 states and 18845 transitions.
[2020-05-30 23:32:56,004 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:56,005 INFO  L728         BuchiCegarLoop]: Abstraction has 15588 states and 18845 transitions.
[2020-05-30 23:32:56,011 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15588 states and 18845 transitions.
[2020-05-30 23:32:56,112 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15588 to 14995.
[2020-05-30 23:32:56,112 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14995 states.
[2020-05-30 23:32:56,136 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14995 states to 14995 states and 17768 transitions.
[2020-05-30 23:32:56,136 INFO  L751         BuchiCegarLoop]: Abstraction has 14995 states and 17768 transitions.
[2020-05-30 23:32:56,136 INFO  L631         BuchiCegarLoop]: Abstraction has 14995 states and 17768 transitions.
[2020-05-30 23:32:56,136 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 23:32:56,136 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14995 states and 17768 transitions.
[2020-05-30 23:32:56,153 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:32:56,153 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:56,153 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:56,154 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:56,154 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:56,157 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:56,157 INFO  L82        PathProgramCache]: Analyzing trace with hash 713699604, now seen corresponding path program 1 times
[2020-05-30 23:32:56,158 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:56,168 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:56,215 INFO  L134       CoverageAnalysis]: Checked inductivity of 88 backedges. 1 proven. 0 refuted. 0 times theorem prover too weak. 87 trivial. 0 not checked.
[2020-05-30 23:32:56,215 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:32:56,215 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 23:32:56,215 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:56,215 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 23:32:56,216 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 23:32:56,216 INFO  L87              Difference]: Start difference. First operand 14995 states and 17768 transitions. cyclomatic complexity: 2828 Second operand 3 states.
[2020-05-30 23:32:56,280 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:32:56,281 INFO  L93              Difference]: Finished difference Result 14999 states and 17766 transitions.
[2020-05-30 23:32:56,281 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 23:32:56,281 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14999 states and 17766 transitions.
[2020-05-30 23:32:56,315 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:32:56,358 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14999 states to 14999 states and 17766 transitions.
[2020-05-30 23:32:56,358 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1195
[2020-05-30 23:32:56,359 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1195
[2020-05-30 23:32:56,359 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14999 states and 17766 transitions.
[2020-05-30 23:32:56,369 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:32:56,369 INFO  L728         BuchiCegarLoop]: Abstraction has 14999 states and 17766 transitions.
[2020-05-30 23:32:56,374 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14999 states and 17766 transitions.
[2020-05-30 23:32:56,466 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14999 to 14995.
[2020-05-30 23:32:56,466 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14995 states.
[2020-05-30 23:32:56,489 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14995 states to 14995 states and 17758 transitions.
[2020-05-30 23:32:56,490 INFO  L751         BuchiCegarLoop]: Abstraction has 14995 states and 17758 transitions.
[2020-05-30 23:32:56,490 INFO  L631         BuchiCegarLoop]: Abstraction has 14995 states and 17758 transitions.
[2020-05-30 23:32:56,490 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 23:32:56,490 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14995 states and 17758 transitions.
[2020-05-30 23:32:56,506 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:32:56,506 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:32:56,506 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:32:56,507 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:32:56,508 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:32:56,511 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:32:56,511 INFO  L82        PathProgramCache]: Analyzing trace with hash 756562986, now seen corresponding path program 1 times
[2020-05-30 23:32:56,511 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:32:56,527 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:32:56,760 INFO  L134       CoverageAnalysis]: Checked inductivity of 44 backedges. 0 proven. 11 refuted. 0 times theorem prover too weak. 33 trivial. 0 not checked.
[2020-05-30 23:32:56,760 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:32:56,760 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [39] total 39
[2020-05-30 23:32:56,761 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:32:56,761 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 40 interpolants.
[2020-05-30 23:32:56,761 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=101, Invalid=1459, Unknown=0, NotChecked=0, Total=1560
[2020-05-30 23:32:56,761 INFO  L87              Difference]: Start difference. First operand 14995 states and 17758 transitions. cyclomatic complexity: 2818 Second operand 40 states.
[2020-05-30 23:33:33,574 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:33:33,574 INFO  L93              Difference]: Finished difference Result 17728 states and 21907 transitions.
[2020-05-30 23:33:33,574 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 55 states. 
[2020-05-30 23:33:33,574 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17728 states and 21907 transitions.
[2020-05-30 23:33:33,621 INFO  L131   ngComponentsAnalysis]: Automaton has 8 accepting balls. 16
[2020-05-30 23:33:33,686 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17728 states to 17728 states and 21892 transitions.
[2020-05-30 23:33:33,686 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1265
[2020-05-30 23:33:33,687 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1265
[2020-05-30 23:33:33,687 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17728 states and 21892 transitions.
[2020-05-30 23:33:33,700 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:33:33,700 INFO  L728         BuchiCegarLoop]: Abstraction has 17728 states and 21892 transitions.
[2020-05-30 23:33:33,707 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17728 states and 21892 transitions.
[2020-05-30 23:33:33,822 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17728 to 16744.
[2020-05-30 23:33:33,822 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 16744 states.
[2020-05-30 23:33:33,847 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 16744 states to 16744 states and 20383 transitions.
[2020-05-30 23:33:33,847 INFO  L751         BuchiCegarLoop]: Abstraction has 16744 states and 20383 transitions.
[2020-05-30 23:33:33,847 INFO  L631         BuchiCegarLoop]: Abstraction has 16744 states and 20383 transitions.
[2020-05-30 23:33:33,848 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 23:33:33,848 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 16744 states and 20383 transitions.
[2020-05-30 23:33:33,864 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:33:33,864 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:33:33,864 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:33:33,865 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:33:33,866 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:33:33,868 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:33:33,869 INFO  L82        PathProgramCache]: Analyzing trace with hash -1545152386, now seen corresponding path program 1 times
[2020-05-30 23:33:33,869 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:33:33,904 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:33:34,389 INFO  L134       CoverageAnalysis]: Checked inductivity of 144 backedges. 11 proven. 78 refuted. 0 times theorem prover too weak. 55 trivial. 0 not checked.
[2020-05-30 23:33:34,389 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:33:34,389 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [45] total 45
[2020-05-30 23:33:34,389 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:33:34,389 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 46 interpolants.
[2020-05-30 23:33:34,390 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=171, Invalid=1899, Unknown=0, NotChecked=0, Total=2070
[2020-05-30 23:33:34,390 INFO  L87              Difference]: Start difference. First operand 16744 states and 20383 transitions. cyclomatic complexity: 3699 Second operand 46 states.
[2020-05-30 23:33:55,730 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:33:55,730 INFO  L93              Difference]: Finished difference Result 17438 states and 21818 transitions.
[2020-05-30 23:33:55,730 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 70 states. 
[2020-05-30 23:33:55,730 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17438 states and 21818 transitions.
[2020-05-30 23:33:55,780 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:33:55,848 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17438 states to 17426 states and 21767 transitions.
[2020-05-30 23:33:55,848 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1268
[2020-05-30 23:33:55,849 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1268
[2020-05-30 23:33:55,849 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17426 states and 21767 transitions.
[2020-05-30 23:33:55,862 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:33:55,862 INFO  L728         BuchiCegarLoop]: Abstraction has 17426 states and 21767 transitions.
[2020-05-30 23:33:55,868 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17426 states and 21767 transitions.
[2020-05-30 23:33:55,988 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17426 to 16842.
[2020-05-30 23:33:55,989 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 16842 states.
[2020-05-30 23:33:56,020 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 16842 states to 16842 states and 20774 transitions.
[2020-05-30 23:33:56,020 INFO  L751         BuchiCegarLoop]: Abstraction has 16842 states and 20774 transitions.
[2020-05-30 23:33:56,020 INFO  L631         BuchiCegarLoop]: Abstraction has 16842 states and 20774 transitions.
[2020-05-30 23:33:56,020 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 23:33:56,020 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 16842 states and 20774 transitions.
[2020-05-30 23:33:56,039 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:33:56,039 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:33:56,040 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:33:56,041 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:33:56,041 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:33:56,044 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:33:56,044 INFO  L82        PathProgramCache]: Analyzing trace with hash -1987299330, now seen corresponding path program 1 times
[2020-05-30 23:33:56,044 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:33:56,070 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:33:56,597 INFO  L134       CoverageAnalysis]: Checked inductivity of 44 backedges. 0 proven. 36 refuted. 0 times theorem prover too weak. 8 trivial. 0 not checked.
[2020-05-30 23:33:56,597 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:33:56,597 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-30 23:33:56,598 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:33:56,598 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-30 23:33:56,598 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=2206, Unknown=0, NotChecked=0, Total=2352
[2020-05-30 23:33:56,598 INFO  L87              Difference]: Start difference. First operand 16842 states and 20774 transitions. cyclomatic complexity: 4003 Second operand 49 states.
[2020-05-30 23:34:24,791 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:34:24,791 INFO  L93              Difference]: Finished difference Result 17480 states and 22098 transitions.
[2020-05-30 23:34:24,791 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 64 states. 
[2020-05-30 23:34:24,791 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17480 states and 22098 transitions.
[2020-05-30 23:34:24,842 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:34:24,908 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17480 states to 17480 states and 22098 transitions.
[2020-05-30 23:34:24,908 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1268
[2020-05-30 23:34:24,909 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1268
[2020-05-30 23:34:24,909 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17480 states and 22098 transitions.
[2020-05-30 23:34:24,923 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:34:24,924 INFO  L728         BuchiCegarLoop]: Abstraction has 17480 states and 22098 transitions.
[2020-05-30 23:34:24,931 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17480 states and 22098 transitions.
[2020-05-30 23:34:25,050 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17480 to 16951.
[2020-05-30 23:34:25,050 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 16951 states.
[2020-05-30 23:34:25,083 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 16951 states to 16951 states and 21221 transitions.
[2020-05-30 23:34:25,083 INFO  L751         BuchiCegarLoop]: Abstraction has 16951 states and 21221 transitions.
[2020-05-30 23:34:25,083 INFO  L631         BuchiCegarLoop]: Abstraction has 16951 states and 21221 transitions.
[2020-05-30 23:34:25,083 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-05-30 23:34:25,084 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 16951 states and 21221 transitions.
[2020-05-30 23:34:25,102 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:34:25,102 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:34:25,102 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:34:25,103 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:34:25,103 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:34:25,106 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:34:25,107 INFO  L82        PathProgramCache]: Analyzing trace with hash -1644870337, now seen corresponding path program 1 times
[2020-05-30 23:34:25,107 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:34:25,133 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:34:25,555 INFO  L134       CoverageAnalysis]: Checked inductivity of 190 backedges. 16 proven. 68 refuted. 0 times theorem prover too weak. 106 trivial. 0 not checked.
[2020-05-30 23:34:25,556 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:34:25,556 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-30 23:34:25,556 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:34:25,556 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-30 23:34:25,556 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=102, Invalid=1158, Unknown=0, NotChecked=0, Total=1260
[2020-05-30 23:34:25,556 INFO  L87              Difference]: Start difference. First operand 16951 states and 21221 transitions. cyclomatic complexity: 4357 Second operand 36 states.
[2020-05-30 23:34:39,732 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:34:39,732 INFO  L93              Difference]: Finished difference Result 17096 states and 21819 transitions.
[2020-05-30 23:34:39,732 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 50 states. 
[2020-05-30 23:34:39,733 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17096 states and 21819 transitions.
[2020-05-30 23:34:39,782 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:34:39,848 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17096 states to 17076 states and 21740 transitions.
[2020-05-30 23:34:39,848 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1225
[2020-05-30 23:34:39,849 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1225
[2020-05-30 23:34:39,849 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17076 states and 21740 transitions.
[2020-05-30 23:34:39,863 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:34:39,863 INFO  L728         BuchiCegarLoop]: Abstraction has 17076 states and 21740 transitions.
[2020-05-30 23:34:39,869 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17076 states and 21740 transitions.
[2020-05-30 23:34:39,984 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17076 to 16903.
[2020-05-30 23:34:39,984 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 16903 states.
[2020-05-30 23:34:40,016 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 16903 states to 16903 states and 20963 transitions.
[2020-05-30 23:34:40,016 INFO  L751         BuchiCegarLoop]: Abstraction has 16903 states and 20963 transitions.
[2020-05-30 23:34:40,016 INFO  L631         BuchiCegarLoop]: Abstraction has 16903 states and 20963 transitions.
[2020-05-30 23:34:40,017 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-05-30 23:34:40,017 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 16903 states and 20963 transitions.
[2020-05-30 23:34:40,036 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:34:40,036 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:34:40,036 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:34:40,037 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:34:40,037 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:34:40,041 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:34:40,041 INFO  L82        PathProgramCache]: Analyzing trace with hash -484963782, now seen corresponding path program 1 times
[2020-05-30 23:34:40,041 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:34:40,077 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:34:40,394 INFO  L134       CoverageAnalysis]: Checked inductivity of 170 backedges. 13 proven. 32 refuted. 0 times theorem prover too weak. 125 trivial. 0 not checked.
[2020-05-30 23:34:40,394 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:34:40,394 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [40] total 40
[2020-05-30 23:34:40,395 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:34:40,395 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 41 interpolants.
[2020-05-30 23:34:40,395 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=104, Invalid=1536, Unknown=0, NotChecked=0, Total=1640
[2020-05-30 23:34:40,395 INFO  L87              Difference]: Start difference. First operand 16903 states and 20963 transitions. cyclomatic complexity: 4137 Second operand 41 states.
[2020-05-30 23:35:01,391 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:35:01,391 INFO  L93              Difference]: Finished difference Result 17233 states and 21789 transitions.
[2020-05-30 23:35:01,391 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 48 states. 
[2020-05-30 23:35:01,391 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17233 states and 21789 transitions.
[2020-05-30 23:35:01,438 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:35:01,501 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17233 states to 17233 states and 21787 transitions.
[2020-05-30 23:35:01,501 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1225
[2020-05-30 23:35:01,501 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1225
[2020-05-30 23:35:01,502 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17233 states and 21787 transitions.
[2020-05-30 23:35:01,515 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:35:01,516 INFO  L728         BuchiCegarLoop]: Abstraction has 17233 states and 21787 transitions.
[2020-05-30 23:35:01,522 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17233 states and 21787 transitions.
[2020-05-30 23:35:01,651 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17233 to 17043.
[2020-05-30 23:35:01,651 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 17043 states.
[2020-05-30 23:35:01,683 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 17043 states to 17043 states and 21240 transitions.
[2020-05-30 23:35:01,684 INFO  L751         BuchiCegarLoop]: Abstraction has 17043 states and 21240 transitions.
[2020-05-30 23:35:01,684 INFO  L631         BuchiCegarLoop]: Abstraction has 17043 states and 21240 transitions.
[2020-05-30 23:35:01,684 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-05-30 23:35:01,684 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 17043 states and 21240 transitions.
[2020-05-30 23:35:01,702 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 12
[2020-05-30 23:35:01,703 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:35:01,703 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:35:01,704 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:35:01,704 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND FALSE  !(choice == 5)
[L2492]  COND FALSE  !(choice == 4)
[L2501]  COND FALSE  !(choice == 3)
[L2510]  COND FALSE  !(choice == 2)
[L2519]  COND FALSE  !(choice == 1)
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:35:01,706 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:35:01,707 INFO  L82        PathProgramCache]: Analyzing trace with hash 591494731, now seen corresponding path program 1 times
[2020-05-30 23:35:01,707 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:35:01,738 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:35:02,307 INFO  L134       CoverageAnalysis]: Checked inductivity of 134 backedges. 4 proven. 75 refuted. 0 times theorem prover too weak. 55 trivial. 0 not checked.
[2020-05-30 23:35:02,307 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:35:02,307 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [54] total 54
[2020-05-30 23:35:02,308 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:35:02,308 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 55 interpolants.
[2020-05-30 23:35:02,308 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=187, Invalid=2783, Unknown=0, NotChecked=0, Total=2970
[2020-05-30 23:35:02,308 INFO  L87              Difference]: Start difference. First operand 17043 states and 21240 transitions. cyclomatic complexity: 4271 Second operand 55 states.
[2020-05-30 23:35:32,043 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:35:32,043 INFO  L93              Difference]: Finished difference Result 20351 states and 27633 transitions.
[2020-05-30 23:35:32,043 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 80 states. 
[2020-05-30 23:35:32,044 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20351 states and 27633 transitions.
[2020-05-30 23:35:32,111 INFO  L131   ngComponentsAnalysis]: Automaton has 12 accepting balls. 24
[2020-05-30 23:35:32,204 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20351 states to 20351 states and 27603 transitions.
[2020-05-30 23:35:32,204 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1336
[2020-05-30 23:35:32,205 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1336
[2020-05-30 23:35:32,205 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20351 states and 27603 transitions.
[2020-05-30 23:35:32,225 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:35:32,225 INFO  L728         BuchiCegarLoop]: Abstraction has 20351 states and 27603 transitions.
[2020-05-30 23:35:32,232 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20351 states and 27603 transitions.
[2020-05-30 23:35:32,372 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20351 to 20092.
[2020-05-30 23:35:32,372 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20092 states.
[2020-05-30 23:35:32,420 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20092 states to 20092 states and 26688 transitions.
[2020-05-30 23:35:32,420 INFO  L751         BuchiCegarLoop]: Abstraction has 20092 states and 26688 transitions.
[2020-05-30 23:35:32,420 INFO  L631         BuchiCegarLoop]: Abstraction has 20092 states and 26688 transitions.
[2020-05-30 23:35:32,420 INFO  L445         BuchiCegarLoop]: ======== Iteration 32============
[2020-05-30 23:35:32,420 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20092 states and 26688 transitions.
[2020-05-30 23:35:32,444 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 23:35:32,444 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:35:32,444 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:35:32,446 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:35:32,446 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s256 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(investor_s256 == user);
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(investor_s431 == user);
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:35:32,449 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:35:32,450 INFO  L82        PathProgramCache]: Analyzing trace with hash -918669510, now seen corresponding path program 1 times
[2020-05-30 23:35:32,450 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:35:32,511 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:35:33,062 INFO  L134       CoverageAnalysis]: Checked inductivity of 228 backedges. 16 proven. 77 refuted. 0 times theorem prover too weak. 135 trivial. 0 not checked.
[2020-05-30 23:35:33,063 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 23:35:33,063 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [44] total 44
[2020-05-30 23:35:33,063 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:35:33,063 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-05-30 23:35:33,063 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1853, Unknown=0, NotChecked=0, Total=1980
[2020-05-30 23:35:33,064 INFO  L87              Difference]: Start difference. First operand 20092 states and 26688 transitions. cyclomatic complexity: 6741 Second operand 45 states.
[2020-05-30 23:35:50,927 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:35:50,927 INFO  L93              Difference]: Finished difference Result 20566 states and 28147 transitions.
[2020-05-30 23:35:50,927 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 53 states. 
[2020-05-30 23:35:50,927 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20566 states and 28147 transitions.
[2020-05-30 23:35:51,002 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 23:35:51,108 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20566 states to 20532 states and 27983 transitions.
[2020-05-30 23:35:51,109 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1328
[2020-05-30 23:35:51,109 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1328
[2020-05-30 23:35:51,109 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20532 states and 27983 transitions.
[2020-05-30 23:35:51,131 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:35:51,131 INFO  L728         BuchiCegarLoop]: Abstraction has 20532 states and 27983 transitions.
[2020-05-30 23:35:51,139 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20532 states and 27983 transitions.
[2020-05-30 23:35:51,291 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20532 to 20190.
[2020-05-30 23:35:51,291 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 20190 states.
[2020-05-30 23:35:51,333 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 20190 states to 20190 states and 25936 transitions.
[2020-05-30 23:35:51,334 INFO  L751         BuchiCegarLoop]: Abstraction has 20190 states and 25936 transitions.
[2020-05-30 23:35:51,334 INFO  L631         BuchiCegarLoop]: Abstraction has 20190 states and 25936 transitions.
[2020-05-30 23:35:51,334 INFO  L445         BuchiCegarLoop]: ======== Iteration 33============
[2020-05-30 23:35:51,334 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 20190 states and 25936 transitions.
[2020-05-30 23:35:51,356 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 23:35:51,356 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 23:35:51,356 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 23:35:51,357 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 23:35:51,357 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       fsum_deposit_EscrowVault_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L2540]                    assume null == 0;
[L2541]        CALL        call this := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L2541]        RET         call this := FreshRefGenerator__success();
[L2542]                    assume now >= 0;
[L2543]                    assume DType[this] == EscrowVault;
[L2544]                    gas := gas - 53000;
[L2545]        CALL        call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L265]                     havoc __exception;
[L266]                     revert := false;
[L267]         COND FALSE  !(__exception)
[L287]         CALL        call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1293]        CALL        call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1112]        CALL        call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1091]                    assume msgsender_MSG != null;
[L1092]                    Balance[this] := 0;
[L1093]                    owner_Ownable[this] := null;
[L1094]                    owner_Ownable[this] := msgsender_MSG;
[L1112]        RET         call Ownable_Ownable_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1113]        COND FALSE  !(revert)
[L1293]        RET         call Ownable_Ownable__success(this, msgsender_MSG, msgvalue_MSG);
[L1294]        COND FALSE  !(revert)
[L1299]        CALL        call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1224]                    assume msgsender_MSG != null;
[L1225]                    Balance[this] := 0;
[L1226]        CALL        call __var_4 := FreshRefGenerator__success();
[L833]                     havoc newRef;
[L834]                     assume Alloc[newRef] == false;
[L835]                     Alloc[newRef] := true;
[L836]                     assume newRef != null;
[L1226]        RET         call __var_4 := FreshRefGenerator__success();
[L1227]        COND FALSE  !(revert)
[L1232]                    deposited_EscrowVault[this] := __var_4;
[L1233]                    M_Ref_int_deposited0[deposited_EscrowVault[this]] := zeroRefIntArr();
[L1234]                    sum_deposited0[deposited_EscrowVault[this]] := 0;
[L1235]                    beneficiary_EscrowVault[this] := null;
[L1236]                    superOwner_EscrowVault[this] := null;
[L1237]                    __var_2 := null;
[L1238]        COND FALSE  !(!(_beneficiary_s224 != null))
[L1244]                    __var_3 := null;
[L1245]        COND FALSE  !(!(_superOwner_s224 != null))
[L1251]                    beneficiary_EscrowVault[this] := _beneficiary_s224;
[L1252]                    superOwner_EscrowVault[this] := _superOwner_s224;
[L1253]                    state_EscrowVault[this] := 0;
[L1299]        RET         call EscrowVault_EscrowVault_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L1300]        COND FALSE  !(revert)
[L287]         RET         call EscrowVault_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L288]                     assume !revert && gas >= 0;
[L2545]        RET         call EscrowVault_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _superOwner_s224, _beneficiary_s224);
[L2546]                    assume !revert && gas >= 0;
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND TRUE   choice == 6
[L2476]                    gas := gas - 21000;
[L2477]        COND TRUE   gas >= 0
[L2479]                    assume msgvalue_MSG == 0;
[L2480]        CALL        call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L341]                     havoc __exception;
[L342]                     revert := false;
[L343]         COND FALSE  !(__exception)
[L363]         CALL        call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1413]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1413]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1414]        COND FALSE  !(revert)
[L1419]                    gas := gas - 367;
[L1420]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1426]                    gas := gas - 20337;
[L1427]                    state_EscrowVault[this] := 2;
[L1428]                    assert { :EventEmitted "GoalReached_EscrowVault" } true;
[L363]         RET         call setGoalReached_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L364]                     assume !revert && gas >= 0;
[L2480]        RET         call setGoalReached_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND TRUE   choice == 3
[L2503]                    gas := gas - 21000;
[L2504]        COND TRUE   gas >= 0
[L2506]                    assume msgvalue_MSG == 0;
[L2507]        CALL        call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L455]                     havoc __exception;
[L456]                     revert := false;
[L457]         COND FALSE  !(__exception)
[L477]         CALL        call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1661]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1661]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1662]        COND FALSE  !(revert)
[L1667]                    gas := gas - 367;
[L1668]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1674]                    gas := gas - 15;
[L1675]        CALL        call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1591]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1591]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1592]        COND FALSE  !(revert)
[L1597]                    gas := gas - 367;
[L1598]        COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1604]                    gas := gas - 416;
[L1605]                    assume balance_s349 >= 0;
[L1606]                    __var_9 := this;
[L1607]                    assume Balance[this] >= 0;
[L1608]                    balance_s349 := Balance[this];
[L1609]                    assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L1610]                    gas := gas - 36020;
[L1611]                    __var_10 := gas;
[L1612]        COND FALSE  !(gas > 2300)
[L1617]                    __var_10 := __var_10 - gas;
[L1618]                    assume balance_s349 >= 0;
[L1619]        CALL        call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND FALSE  !(DType[to] == EscrowVault)
[L1852]        COND FALSE  !(DType[to] == Ownable)
[L1858]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]                    assume Balance[from] >= amount;
[L2036]                    Balance[from] := Balance[from] - amount;
[L2037]                    Balance[to] := Balance[to] + amount;
[L2038]        COND FALSE  !(choice == 0)
[L2044]        COND TRUE   gas < 21000
[L1858]        RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]        COND FALSE  !(revert)
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                       revert := revert_hold;
[L1619]        RET         call __var_11 := send__success(this, beneficiary_EscrowVault[this], balance_s349);
[L1620]        COND FALSE  !(!__var_11)
[L1626]                    gas := __var_10 + gas;
[L1675]        RET         call withdrawAll_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1676]        COND FALSE  !(revert)
[L1681]                    gas := gas - 20337;
[L1682]                    state_EscrowVault[this] := 3;
[L1683]                    assert { :EventEmitted "Close_EscrowVault" } true;
[L477]         RET         call close_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L478]                     assume !revert && gas >= 0;
[L2507]        RET         call close_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND FALSE  !(choice == 2)
[L2519]        COND TRUE   choice == 1
[L2521]                    gas := gas - 21000;
[L2522]        COND TRUE   gas >= 0
[L2524]                    assume msgvalue_MSG == 0;
[L2525]        CALL        call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L531]                     havoc __exception;
[L532]                     revert := false;
[L533]         COND FALSE  !(__exception)
[L553]         CALL        call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L1784]                    gas := gas - 367;
[L1785]        COND FALSE  !(!(state_EscrowVault[this] == 1))
[L1791]                    gas := gas - 307;
[L1792]                    assume depositedValue_s430 >= 0;
[L1793]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1794]                    depositedValue_s430 := M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1795]                    gas := gas - 5104;
[L1796]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] >= 0;
[L1797-L1798]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1799]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431] := 0;
[L1800-L1801]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s431];
[L1802]                    gas := gas - 35787;
[L1803]                    __var_12 := gas;
[L1804]        COND TRUE   gas > 2300
[L1806]                    gas := 2300;
[L1809]                    __var_12 := __var_12 - gas;
[L1810]                    assume depositedValue_s430 >= 0;
[L1811]        CALL        call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L2253]                    havoc __exception;
[L2254]        COND FALSE  !(__exception)
[L2280]        COND TRUE   Balance[from] >= amount
[L2282]        CALL        call FallbackDispatch__success(from, to, amount);
[L1848]        COND TRUE   DType[to] == EscrowVault
[L1850]                    assume amount == 0;
[L2282]        RET         call FallbackDispatch__success(from, to, amount);
[L2283]                    success := true;
[L2290]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_EscrowVault_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1811]        RET         call __var_13 := send__success(this, investor_s431, depositedValue_s430);
[L1812]        COND FALSE  !(!__var_13)
[L1818]                    gas := __var_12 + gas;
[L1819]                    assert { :EventEmitted "Refunded_EscrowVault" } true;
[L553]         RET         call refund_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L554]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s431 == user;
[L7]                       success_refund_EscrowVault0 := true;
[L7]                       success_refund_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2525]        RET         call refund_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s431);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND TRUE   choice == 7
[L2467]                    gas := gas - 21000;
[L2468]        COND TRUE   gas >= 0
[L2470]                    assume msgvalue_MSG >= 0;
[L2471]        CALL        call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L303]                     havoc __exception;
[L304]                     revert := false;
[L305]         COND FALSE  !(__exception)
[L325]         CALL        call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L1354]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L1355]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L1356]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L1357]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1357]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1358]        COND FALSE  !(revert)
[L1363]                    gas := gas - 733;
[L1364]        COND FALSE  !(!(state_EscrowVault[this] == 0 || state_EscrowVault[this] == 2))
[L1370]                    gas := gas - 20438;
[L1371]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1372]                    assume M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] >= 0;
[L1373]                    assume msgvalue_MSG >= 0;
[L1374]        CALL        call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1055]                    gas := gas - 3;
[L1056]                    gas := gas - 17;
[L1057]                    assume c_s95 >= 0;
[L1058]                    assume a_s96 >= 0;
[L1059]                    assume b_s96 >= 0;
[L1060]                    assume a_s96 + b_s96 >= 0;
[L1061]                    c_s95 := a_s96 + b_s96;
[L1062]                    gas := gas - 32;
[L1063]                    assume c_s95 >= 0;
[L1064]                    assume a_s96 >= 0;
[L1065]        COND FALSE  !(!(c_s95 >= a_s96))
[L1071]                    gas := gas - 10;
[L1072]                    assume c_s95 >= 0;
[L1073]                    __ret_0_ := c_s95;
[L1374]        RET         call __var_5 := add_SafeMath__success(this, this, 0, M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256], msgvalue_MSG);
[L1375]        COND FALSE  !(revert)
[L1380-L1381]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] - M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1382]                    M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256] := __var_5;
[L1383-L1384]              sum_deposited0[deposited_EscrowVault[this]] := sum_deposited0[deposited_EscrowVault[this]] + M_Ref_int_deposited0[deposited_EscrowVault[this]][investor_s256];
[L1385]                    assume __var_5 >= 0;
[L325]         RET         call deposit_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L326]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume investor_s256 == user;
[L7]                       success_deposit_EscrowVault0 := true;
[L7]                       success_deposit_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume investor_s256 == user;
[L7]                       fsum_deposit_EscrowVault_2_0 := fsum_deposit_EscrowVault_2_0 + msgvalue_MSG;
[L2471]        RET         call deposit_EscrowVault(this, msgsender_MSG, msgvalue_MSG, investor_s256);
[L2549]        RET         call CorralChoice_EscrowVault(this);
[L2549]        CALL        call CorralChoice_EscrowVault(this);
[L2436]                    havoc msgsender_MSG;
[L2437]                    havoc msgvalue_MSG;
[L2438]                    havoc choice;
[L2439]                    havoc newOwner_s150;
[L2440]                    havoc _superOwner_s224;
[L2441]                    havoc _beneficiary_s224;
[L2442]                    havoc investor_s256;
[L2443]                    havoc _amount_s320;
[L2444]                    havoc investor_s431;
[L2445]                    havoc tmpNow;
[L2446]                    havoc gas;
[L2447]                    assume gas > 4000000 && gas <= 8000000;
[L2448]                    tmpNow := now;
[L2449]                    havoc now;
[L2450]                    assume now > tmpNow;
[L2451]                    assume msgsender_MSG != null;
[L2452]                    assume DType[msgsender_MSG] != SafeMath;
[L2453]                    assume DType[msgsender_MSG] != Ownable;
[L2454]                    assume DType[msgsender_MSG] != EscrowVault;
[L2455]                    Alloc[msgsender_MSG] := true;
[L2456]        COND FALSE  !(choice == 8)
[L2465]        COND FALSE  !(choice == 7)
[L2474]        COND FALSE  !(choice == 6)
[L2483]        COND FALSE  !(choice == 5)
[L2492]        COND FALSE  !(choice == 4)
[L2501]        COND FALSE  !(choice == 3)
[L2510]        COND TRUE   choice == 2
[L2512]                    gas := gas - 21000;
[L2513]        COND TRUE   gas >= 0
[L2515]                    assume msgvalue_MSG == 0;
[L2516]        CALL        call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L493]                     havoc __exception;
[L494]                     revert := false;
[L495]         COND FALSE  !(__exception)
[L515]         CALL        call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L1711]        CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2310]                    gas := gas - 1932;
[L2311]        COND FALSE  !(!(msgsender_MSG == owner_Ownable[this]))
[L1711]        RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1712]        COND FALSE  !(revert)
[L1717]                    gas := gas - 367;
[L1718]        COND FALSE  !(!(state_EscrowVault[this] == 0))
[L1724]                    gas := gas - 20337;
[L1725]                    state_EscrowVault[this] := 1;
[L1726]                    assert { :EventEmitted "RefundsEnabled_EscrowVault" } true;
[L515]         RET         call enableRefunds_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG);
[L516]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_EscrowVault0 := true;
[L7]                       success_enableRefunds_EscrowVault0 := false;
[L7]                       revert := revert_hold;
[L2516]        RET         call enableRefunds_EscrowVault(this, msgsender_MSG, msgvalue_MSG);
[L2549]        RET         call CorralChoice_EscrowVault(this);

Loop:
[L2549]  CALL        call CorralChoice_EscrowVault(this);
[L2436]              havoc msgsender_MSG;
[L2437]              havoc msgvalue_MSG;
[L2438]              havoc choice;
[L2439]              havoc newOwner_s150;
[L2440]              havoc _superOwner_s224;
[L2441]              havoc _beneficiary_s224;
[L2442]              havoc investor_s256;
[L2443]              havoc _amount_s320;
[L2444]              havoc investor_s431;
[L2445]              havoc tmpNow;
[L2446]              havoc gas;
[L2447]              assume gas > 4000000 && gas <= 8000000;
[L2448]              tmpNow := now;
[L2449]              havoc now;
[L2450]              assume now > tmpNow;
[L2451]              assume msgsender_MSG != null;
[L2452]              assume DType[msgsender_MSG] != SafeMath;
[L2453]              assume DType[msgsender_MSG] != Ownable;
[L2454]              assume DType[msgsender_MSG] != EscrowVault;
[L2455]              Alloc[msgsender_MSG] := true;
[L2456]  COND FALSE  !(choice == 8)
[L2465]  COND FALSE  !(choice == 7)
[L2474]  COND FALSE  !(choice == 6)
[L2483]  COND TRUE   choice == 5
[L2485]              gas := gas - 21000;
[L2486]  COND TRUE   gas >= 0
[L2488]              assume msgvalue_MSG == 0;
[L2489]  CALL        call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L379]               havoc __exception;
[L380]               revert := false;
[L381]   COND FALSE  !(__exception)
[L401]   CALL        call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L1491]              gas := gas - 276;
[L1492]  COND FALSE  !(!(msgsender_MSG == superOwner_EscrowVault[this]))
[L1498]              gas := gas - 367;
[L1499]  COND FALSE  !(!(state_EscrowVault[this] == 2))
[L1505]              gas := gas - 468;
[L1506]              assume _amount_s320 >= 0;
[L1507]              __var_6 := this;
[L1508]              assume Balance[this] >= 0;
[L1509]              assume _amount_s320 >= 0;
[L1510]  COND FALSE  !(!(_amount_s320 <= Balance[this] && _amount_s320 > 0))
[L1516]              gas := gas - 36029;
[L1517]              __var_7 := gas;
[L1518]  COND FALSE  !(gas > 2300)
[L1523]              __var_7 := __var_7 - gas;
[L1524]              assume _amount_s320 >= 0;
[L1525]  CALL        call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L2253]              havoc __exception;
[L2254]  COND FALSE  !(__exception)
[L2280]  COND TRUE   Balance[from] >= amount
[L2282]  CALL        call FallbackDispatch__success(from, to, amount);
[L1848]  COND FALSE  !(DType[to] == EscrowVault)
[L1852]  COND FALSE  !(DType[to] == Ownable)
[L1858]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2035]              assume Balance[from] >= amount;
[L2036]              Balance[from] := Balance[from] - amount;
[L2037]              Balance[to] := Balance[to] + amount;
[L2038]  COND FALSE  !(choice == 0)
[L2044]  COND TRUE   gas < 21000
[L1858]  RET         call Fallback_UnknownType__success(from, to, amount);
[L1859]  COND FALSE  !(revert)
[L2282]  RET         call FallbackDispatch__success(from, to, amount);
[L2283]              success := true;
[L2290]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == user && amount == fsum_deposit_EscrowVault_2_0);
[L7]                 revert := revert_hold;
[L1525]  RET         call __var_8 := send__success(this, beneficiary_EscrowVault[this], _amount_s320);
[L1526]  COND FALSE  !(!__var_8)
[L1532]              gas := __var_7 + gas;
[L1533]              assert { :EventEmitted "Withdrawal_EscrowVault" } true;
[L401]   RET         call withdraw_EscrowVault__success(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L402]               assume !revert && gas >= 0;
[L2489]  RET         call withdraw_EscrowVault(this, msgsender_MSG, msgvalue_MSG, _amount_s320);
[L2549]  RET         call CorralChoice_EscrowVault(this);

[2020-05-30 23:35:51,360 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 23:35:51,361 INFO  L82        PathProgramCache]: Analyzing trace with hash 294454343, now seen corresponding path program 1 times
[2020-05-30 23:35:51,361 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 23:35:51,376 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 23:35:51,460 INFO  L134       CoverageAnalysis]: Checked inductivity of 116 backedges. 56 proven. 0 refuted. 0 times theorem prover too weak. 60 trivial. 0 not checked.
[2020-05-30 23:35:51,460 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 23:35:51,460 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [11] imperfect sequences [] total 11
[2020-05-30 23:35:51,460 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 23:35:51,460 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 23:35:51,461 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 23:35:51,461 INFO  L87              Difference]: Start difference. First operand 20190 states and 25936 transitions. cyclomatic complexity: 5838 Second operand 11 states.
[2020-05-30 23:35:52,106 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 23:35:52,106 INFO  L93              Difference]: Finished difference Result 8068 states and 9610 transitions.
[2020-05-30 23:35:52,106 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 23:35:52,106 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8068 states and 9610 transitions.
[2020-05-30 23:35:52,185 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 23:35:52,186 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8068 states to 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 23:35:52,186 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 23:35:52,186 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 23:35:52,186 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L445         BuchiCegarLoop]: ======== Iteration 34============
[2020-05-30 23:35:52,186 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 23:35:52,186 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 23:35:52,187 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 23:35:52,191 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 11:35:52 BasicIcfg
[2020-05-30 23:35:52,191 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 23:35:52,191 INFO  L168              Benchmark]: Toolchain (without parser) took 412257.45 ms. Allocated memory was 514.9 MB in the beginning and 5.5 GB in the end (delta: 5.0 GB). Free memory was 460.2 MB in the beginning and 5.0 GB in the end (delta: -4.6 GB). Peak memory consumption was 439.4 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,193 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,193 INFO  L168              Benchmark]: Boogie Preprocessor took 66.95 ms. Allocated memory is still 514.9 MB. Free memory was 460.2 MB in the beginning and 453.5 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,194 INFO  L168              Benchmark]: UtopiaSpecLang took 42.46 ms. Allocated memory is still 514.9 MB. Free memory was 453.5 MB in the beginning and 449.4 MB in the end (delta: 4.0 MB). Peak memory consumption was 4.0 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,194 INFO  L168              Benchmark]: Boogie Printer took 11.02 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 448.1 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,194 INFO  L168              Benchmark]: RCFGBuilder took 424.21 ms. Allocated memory is still 514.9 MB. Free memory was 448.1 MB in the beginning and 391.4 MB in the end (delta: 56.7 MB). Peak memory consumption was 56.7 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,195 INFO  L168              Benchmark]: UtopiaLTL2Aut took 46.49 ms. Allocated memory is still 514.9 MB. Free memory was 391.4 MB in the beginning and 386.9 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,195 INFO  L168              Benchmark]: Büchi Program Product took 3940.41 ms. Allocated memory was 514.9 MB in the beginning and 1.0 GB in the end (delta: 521.1 MB). Free memory was 386.9 MB in the beginning and 246.0 MB in the end (delta: 140.9 MB). Peak memory consumption was 676.6 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,195 INFO  L168              Benchmark]: BlockEncodingV2 took 454.91 ms. Allocated memory was 1.0 GB in the beginning and 1.3 GB in the end (delta: 306.2 MB). Free memory was 246.0 MB in the beginning and 900.0 MB in the end (delta: -654.0 MB). Peak memory consumption was 52.6 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,196 INFO  L168              Benchmark]: BuchiAutomizer took 407267.36 ms. Allocated memory was 1.3 GB in the beginning and 5.5 GB in the end (delta: 4.2 GB). Free memory was 900.0 MB in the beginning and 5.0 GB in the end (delta: -4.1 GB). Peak memory consumption was 51.8 MB. Max. memory is 15.3 GB.
[2020-05-30 23:35:52,200 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    9471 locations, 37928 edges
  - StatisticsResult: Encoded RCFG
    9351 locations, 37246 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 66.95 ms. Allocated memory is still 514.9 MB. Free memory was 460.2 MB in the beginning and 453.5 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 42.46 ms. Allocated memory is still 514.9 MB. Free memory was 453.5 MB in the beginning and 449.4 MB in the end (delta: 4.0 MB). Peak memory consumption was 4.0 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 11.02 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 448.1 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 424.21 ms. Allocated memory is still 514.9 MB. Free memory was 448.1 MB in the beginning and 391.4 MB in the end (delta: 56.7 MB). Peak memory consumption was 56.7 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 46.49 ms. Allocated memory is still 514.9 MB. Free memory was 391.4 MB in the beginning and 386.9 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
 * Büchi Program Product took 3940.41 ms. Allocated memory was 514.9 MB in the beginning and 1.0 GB in the end (delta: 521.1 MB). Free memory was 386.9 MB in the beginning and 246.0 MB in the end (delta: 140.9 MB). Peak memory consumption was 676.6 MB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 454.91 ms. Allocated memory was 1.0 GB in the beginning and 1.3 GB in the end (delta: 306.2 MB). Free memory was 246.0 MB in the beginning and 900.0 MB in the end (delta: -654.0 MB). Peak memory consumption was 52.6 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 407267.36 ms. Allocated memory was 1.3 GB in the beginning and 5.5 GB in the end (delta: 4.2 GB). Free memory was 900.0 MB in the beginning and 5.0 GB in the end (delta: -4.1 GB). Peak memory consumption was 51.8 MB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1006 locations, 1311 edges
  - StatisticsResult: BuchiProgram size
    9471 locations, 37928 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 33 terminating modules (33 trivial, 0 deterministic, 0 nondeterministic). 33 modules have a trivial ranking function, the largest among these consists of 55 locations.
  - StatisticsResult: Timing statistics
    BüchiAutomizer plugin needed 407.2s and 34 iterations.  TraceHistogramMax:3. Analysis of lassos took 7.2s. Construction of modules took 326.5s. Büchi inclusion checks took 62.2s. Highest rank in rank-based complementation 0. Minimization of det autom 33. Minimization of nondet autom 0. Automata minimization 5.4s AutomataMinimizationTime, 32 MinimizatonAttempts, 26622 StatesRemovedByMinimization, 26 NontrivialMinimizations. Non-live state removal took 4.0s Buchi closure took 0.0s. Biggest automaton had 26294 states and ocurred in iteration 22.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 242880 SDtfs, 596573 SDslu, 625563 SDs, 0 SdLazy, 2255000 SolverSat, 107913 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 326.5s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU33 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_EscrowVault0) ) && ( <>(success_refund_EscrowVault0) ) )&& ! ( ( []( (success_enableRefunds_EscrowVault0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
