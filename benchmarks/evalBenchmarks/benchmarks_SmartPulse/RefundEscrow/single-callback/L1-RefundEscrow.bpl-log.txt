This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:24:15,448 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:24:15,450 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:24:15,460 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:24:15,461 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:24:15,462 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:24:15,463 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:24:15,464 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:24:15,466 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:24:15,467 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:24:15,468 INFO  L177        SettingsManager]: Büchi Program Product provides no preferences, ignoring...
[2020-05-30 20:24:15,468 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:24:15,470 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:24:15,471 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:24:15,472 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:24:15,473 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:24:15,474 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:24:15,475 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:24:15,476 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:24:15,478 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:24:15,479 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:24:15,480 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:24:15,482 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:24:15,482 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:24:15,482 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:24:15,483 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:24:15,484 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:24:15,485 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:24:15,485 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:24:15,485 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:24:15,485 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:24:15,486 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:24:15,487 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:24:15,488 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:24:15,489 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:24:15,490 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:24:15,490 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:24:15,491 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:24:15,491 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:24:15,491 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:24:15,493 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:24:15,493 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:24:15,494 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:24:15,502 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:24:15,503 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:24:15,504 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:24:15,504 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:24:15,504 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:24:15,504 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:24:15,505 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:24:15,505 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:24:15,506 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:24:15,506 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:24:15,506 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:24:15,506 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:24:15,506 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:24:15,506 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:24:15,527 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:24:15,538 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:24:15,540 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:24:15,541 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:24:15,541 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:24:15,542 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/single-callback/L1-RefundEscrow.bpl
[2020-05-30 20:24:15,542 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/single-callback/L1-RefundEscrow.bpl'
[2020-05-30 20:24:15,597 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:24:15,598 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:24:15,598 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:24:15,599 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:24:15,599 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:24:15,612 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,614 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,636 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,637 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,651 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,660 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,667 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,675 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:24:15,675 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:24:15,675 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:24:15,677 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:24:15,679 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/1) ...
[2020-05-30 20:24:15,692 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:24:15,697 INFO  L979   opiaSpecLangObserver]: Successfully lexed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:24:15,703 INFO  L981   opiaSpecLangObserver]: Successfully parsed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:24:15,706 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:24:15,708 INFO  L599   opiaSpecLangObserver]: Parsed ( to==user && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[user,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:24:15,709 INFO  L968   opiaSpecLangObserver]: Compiling: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:24:15,709 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_enableRefunds_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:24:15,709 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:24:15,709 INFO  L979   opiaSpecLangObserver]: Successfully lexed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:24:15,709 INFO  L981   opiaSpecLangObserver]: Successfully parsed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:24:15,711 INFO  L599   opiaSpecLangObserver]: Parsed payee_s255==user to BinaryExpression[COMPEQ,IdentifierExpression[payee_s255,<IMPLEMENTATION_INPARAM,withdraw_ConditionalEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:24:15,712 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:24:15,713 INFO  L968   opiaSpecLangObserver]: Compiling: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:24:15,713 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_withdraw_ConditionalEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:24:15,721 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:24:15 PropertyContainer
[2020-05-30 20:24:15,721 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:24:15,721 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:24:15,721 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:24:15,721 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:24:15,722 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/2) ...
[2020-05-30 20:24:15,723 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:24:15,723 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:24:15,733 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:24:15" (2/2) ...
[2020-05-30 20:24:15,734 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:24:15,734 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:24:15,734 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:24:15,734 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:24:15,735 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/2) ...
[2020-05-30 20:24:15,777 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:24:15,777 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:24:15,777 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:24:15,778 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:24:15,778 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:24:15,778 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:24:15,778 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:24:15,778 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:24:15,778 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:24:15,778 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:24:15,779 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:24:15,779 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:24:15,779 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:24:15,779 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:24:15,779 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:24:15,779 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:24:15,779 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:24:15,779 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:24:15,779 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:24:15,779 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:24:15,780 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:24:15,780 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:24:15,780 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:24:15,780 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:24:15,781 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:24:15,782 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:24:15,782 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:24:15,782 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:24:15,783 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:24:15,784 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:24:15,785 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:24:15,786 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:24:15,787 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:24:15,787 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:24:15,787 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:24:15,787 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:24:15,788 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:24:15,789 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:24:15,790 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:24:15,791 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:24:15,792 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:24:15,793 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:24:15,794 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:24:15,794 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:24:15,903 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:24:15,918 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:24:15,932 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:24:16,135 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:24:16,135 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:24:16,266 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:24:16,266 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:24:16,268 INFO  L202        PluginConnector]: Adding new model L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:24:16 BoogieIcfgContainer
[2020-05-30 20:24:16,268 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:24:15" (2/2) ...
[2020-05-30 20:24:16,268 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:24:16,269 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@1c9c5697 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:24:16, skipping insertion in model container
[2020-05-30 20:24:16,269 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:24:16,269 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:24:16,269 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:24:16,270 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:24:16,271 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/3) ...
[2020-05-30 20:24:16,271 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@4b11eed5 and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:24:16, skipping insertion in model container
[2020-05-30 20:24:16,271 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:24:15" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:24:16,319 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:24:16 NWAContainer
[2020-05-30 20:24:16,319 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:24:16,319 INFO  L113        PluginConnector]: ------------------------Büchi Program Product----------------------------
[2020-05-30 20:24:16,319 INFO  L271        PluginConnector]: Initializing Büchi Program Product...
[2020-05-30 20:24:16,320 INFO  L276        PluginConnector]: Büchi Program Product initialized
[2020-05-30 20:24:16,320 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:24:16" (3/4) ...
[2020-05-30 20:24:16,321 INFO  L205        PluginConnector]: Invalid model from Büchi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@2bb08ce8 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:24:16, skipping insertion in model container
[2020-05-30 20:24:16,321 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:24:16" (4/4) ...
[2020-05-30 20:24:16,324 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:24:16,327 INFO  L110   BuchiProductObserver]: Initial RCFG 1571 locations, 2188 edges
[2020-05-30 20:24:16,327 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:24:16,337 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:24:21,729 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:24:21,750 INFO  L110   BuchiProductObserver]: BuchiProgram size 15383 locations, 64142 edges
[2020-05-30 20:24:21,751 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:24:21 BoogieIcfgContainer
[2020-05-30 20:24:21,751 INFO  L132        PluginConnector]: ------------------------ END Büchi Program Product----------------------------
[2020-05-30 20:24:21,751 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:24:21,751 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:24:21,752 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:24:21,753 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:24:21" (1/1) ...
[2020-05-30 20:24:22,021 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,022 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,023 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,023 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,023 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,023 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,023 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,024 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,026 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,027 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,027 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,027 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,027 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,027 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,028 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,028 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,029 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,029 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,029 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,029 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,030 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,030 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,030 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,030 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,030 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,031 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,033 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,033 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,033 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,034 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,034 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,034 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,036 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,036 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,036 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,037 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,037 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,037 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,038 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,038 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,039 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,039 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,039 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,039 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,043 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,043 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,044 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,044 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,044 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,044 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,258 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,258 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,258 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,258 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,258 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,259 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:24:22,290 INFO  L313           BlockEncoder]: Initial Icfg 15383 locations, 64142 edges
[2020-05-30 20:24:22,290 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:24:22,291 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:24:22,291 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:24:22,292 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:24:22,324 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:24:22,345 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:24:22,389 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:24:22,402 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:24:22,417 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:24:22,417 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:24:22,429 INFO  L313           BlockEncoder]: Encoded RCFG 15159 locations, 62812 edges
[2020-05-30 20:24:22,430 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:24:22 BasicIcfg
[2020-05-30 20:24:22,430 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:24:22,430 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:24:22,430 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:24:22,432 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:24:22,432 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,432 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:24:15" (1/6) ...
[2020-05-30 20:24:22,434 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@571cdc25 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:24:22, skipping insertion in model container
[2020-05-30 20:24:22,434 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,434 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:24:15" (2/6) ...
[2020-05-30 20:24:22,434 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@571cdc25 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:24:22, skipping insertion in model container
[2020-05-30 20:24:22,434 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,434 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:24:16" (3/6) ...
[2020-05-30 20:24:22,434 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@571cdc25 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:24:22, skipping insertion in model container
[2020-05-30 20:24:22,434 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,434 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:24:16" (4/6) ...
[2020-05-30 20:24:22,435 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@571cdc25 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:24:22, skipping insertion in model container
[2020-05-30 20:24:22,435 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,435 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:24:21" (5/6) ...
[2020-05-30 20:24:22,435 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@571cdc25 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:24:22, skipping insertion in model container
[2020-05-30 20:24:22,435 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:24:22,435 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:24:22" (6/6) ...
[2020-05-30 20:24:22,436 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L1-RefundEscrow.bpl_BEv2
[2020-05-30 20:24:22,467 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:24:22,468 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:24:22,468 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:24:22,468 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:24:22,468 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:24:22,468 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:24:22,468 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:24:22,468 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:24:22,468 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:24:22,600 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15159 states.
[2020-05-30 20:24:22,770 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:22,771 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:22,771 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:22,780 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:22,780 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:22,780 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:24:22,781 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15159 states.
[2020-05-30 20:24:22,869 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:22,869 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:22,869 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:22,871 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:22,871 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:22,884 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:22,884 INFO  L82        PathProgramCache]: Analyzing trace with hash 169053210, now seen corresponding path program 1 times
[2020-05-30 20:24:22,888 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:22,906 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:22,947 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:24:22,949 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:22,949 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:24:23,670 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:23,687 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:24:23,687 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:24:23,689 INFO  L87              Difference]: Start difference. First operand 15159 states. Second operand 3 states.
[2020-05-30 20:24:24,877 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:24,877 INFO  L93              Difference]: Finished difference Result 11755 states and 30247 transitions.
[2020-05-30 20:24:24,877 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:24:24,879 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11755 states and 30247 transitions.
[2020-05-30 20:24:24,968 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:25,131 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11755 states to 11755 states and 30247 transitions.
[2020-05-30 20:24:25,132 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:24:25,135 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 361
[2020-05-30 20:24:25,136 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11755 states and 30247 transitions.
[2020-05-30 20:24:25,177 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:25,178 INFO  L728         BuchiCegarLoop]: Abstraction has 11755 states and 30247 transitions.
[2020-05-30 20:24:25,208 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11755 states and 30247 transitions.
[2020-05-30 20:24:25,413 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11755 to 11755.
[2020-05-30 20:24:25,414 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11755 states.
[2020-05-30 20:24:25,447 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11755 states to 11755 states and 30247 transitions.
[2020-05-30 20:24:25,448 INFO  L751         BuchiCegarLoop]: Abstraction has 11755 states and 30247 transitions.
[2020-05-30 20:24:25,448 INFO  L631         BuchiCegarLoop]: Abstraction has 11755 states and 30247 transitions.
[2020-05-30 20:24:25,448 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:24:25,448 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11755 states and 30247 transitions.
[2020-05-30 20:24:25,475 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:25,475 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:25,475 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:25,479 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:25,479 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND TRUE   choice == 2
[L3784]              gas := gas - 21000;
[L3785]  COND TRUE   gas >= 0
[L3787]              assume msgvalue_MSG == 0;
[L3788]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3788]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND TRUE   choice == 2
[L3784]              gas := gas - 21000;
[L3785]  COND TRUE   gas >= 0
[L3787]              assume msgvalue_MSG == 0;
[L3788]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3788]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:25,484 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:25,484 INFO  L82        PathProgramCache]: Analyzing trace with hash -805370262, now seen corresponding path program 1 times
[2020-05-30 20:24:25,485 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:25,492 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:25,507 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:24:25,507 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:25,507 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:24:25,508 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:25,509 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:24:25,509 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:24:25,509 INFO  L87              Difference]: Start difference. First operand 11755 states and 30247 transitions. cyclomatic complexity: 18516 Second operand 4 states.
[2020-05-30 20:24:28,864 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:28,864 INFO  L93              Difference]: Finished difference Result 11341 states and 20243 transitions.
[2020-05-30 20:24:28,865 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:24:28,865 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11341 states and 20243 transitions.
[2020-05-30 20:24:28,890 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:28,935 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11341 states to 11341 states and 20243 transitions.
[2020-05-30 20:24:28,935 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 361
[2020-05-30 20:24:28,936 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 361
[2020-05-30 20:24:28,936 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11341 states and 20243 transitions.
[2020-05-30 20:24:28,948 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:28,948 INFO  L728         BuchiCegarLoop]: Abstraction has 11341 states and 20243 transitions.
[2020-05-30 20:24:28,959 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11341 states and 20243 transitions.
[2020-05-30 20:24:29,051 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11341 to 11341.
[2020-05-30 20:24:29,051 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11341 states.
[2020-05-30 20:24:29,069 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11341 states to 11341 states and 20243 transitions.
[2020-05-30 20:24:29,070 INFO  L751         BuchiCegarLoop]: Abstraction has 11341 states and 20243 transitions.
[2020-05-30 20:24:29,070 INFO  L631         BuchiCegarLoop]: Abstraction has 11341 states and 20243 transitions.
[2020-05-30 20:24:29,070 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:24:29,070 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11341 states and 20243 transitions.
[2020-05-30 20:24:29,085 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:29,085 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:29,085 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:29,087 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:29,087 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND TRUE   choice == 7
[L3739]              gas := gas - 21000;
[L3740]  COND TRUE   gas >= 0
[L3742]              assume msgvalue_MSG == 0;
[L3743]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3743]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND TRUE   choice == 2
[L3784]              gas := gas - 21000;
[L3785]  COND TRUE   gas >= 0
[L3787]              assume msgvalue_MSG == 0;
[L3788]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3788]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND TRUE   choice == 7
[L3739]              gas := gas - 21000;
[L3740]  COND TRUE   gas >= 0
[L3742]              assume msgvalue_MSG == 0;
[L3743]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3743]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:29,090 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:29,090 INFO  L82        PathProgramCache]: Analyzing trace with hash -1038908706, now seen corresponding path program 1 times
[2020-05-30 20:24:29,090 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:29,096 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:29,117 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:24:29,117 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:29,117 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:24:29,117 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:29,117 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:24:29,118 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:24:29,118 INFO  L87              Difference]: Start difference. First operand 11341 states and 20243 transitions. cyclomatic complexity: 8926 Second operand 4 states.
[2020-05-30 20:24:33,191 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:33,191 INFO  L93              Difference]: Finished difference Result 11134 states and 13958 transitions.
[2020-05-30 20:24:33,192 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:24:33,192 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11134 states and 13958 transitions.
[2020-05-30 20:24:33,217 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:33,248 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11134 states to 11134 states and 13958 transitions.
[2020-05-30 20:24:33,248 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 361
[2020-05-30 20:24:33,248 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 361
[2020-05-30 20:24:33,249 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11134 states and 13958 transitions.
[2020-05-30 20:24:33,257 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:33,257 INFO  L728         BuchiCegarLoop]: Abstraction has 11134 states and 13958 transitions.
[2020-05-30 20:24:33,268 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11134 states and 13958 transitions.
[2020-05-30 20:24:33,330 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11134 to 11134.
[2020-05-30 20:24:33,330 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11134 states.
[2020-05-30 20:24:33,341 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11134 states to 11134 states and 13958 transitions.
[2020-05-30 20:24:33,341 INFO  L751         BuchiCegarLoop]: Abstraction has 11134 states and 13958 transitions.
[2020-05-30 20:24:33,341 INFO  L631         BuchiCegarLoop]: Abstraction has 11134 states and 13958 transitions.
[2020-05-30 20:24:33,341 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:24:33,341 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11134 states and 13958 transitions.
[2020-05-30 20:24:33,351 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:24:33,351 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:33,351 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:33,353 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:33,353 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3811]              assume null == 0;
[L3812]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3812]  RET         call this := FreshRefGenerator__success();
[L3813]              assume now >= 0;
[L3814]              assume DType[this] == RefundEscrow;
[L3815]              gas := gas - 53000;
[L3816]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3816]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]              assume !revert && gas >= 0;
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND TRUE   choice == 7
[L3739]              gas := gas - 21000;
[L3740]  COND TRUE   gas >= 0
[L3742]              assume msgvalue_MSG == 0;
[L3743]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3743]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND TRUE   choice == 2
[L3784]              gas := gas - 21000;
[L3785]  COND TRUE   gas >= 0
[L3787]              assume msgvalue_MSG == 0;
[L3788]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3788]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND TRUE   choice == 8
[L3730]              gas := gas - 21000;
[L3731]  COND TRUE   gas >= 0
[L3733]              assume msgvalue_MSG >= 0;
[L3734]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3734]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:33,356 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:33,356 INFO  L82        PathProgramCache]: Analyzing trace with hash 1551024197, now seen corresponding path program 1 times
[2020-05-30 20:24:33,356 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:33,362 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:33,388 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:24:33,388 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:33,388 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:24:33,388 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:33,389 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:24:33,389 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:24:33,389 INFO  L87              Difference]: Start difference. First operand 11134 states and 13958 transitions. cyclomatic complexity: 2848 Second operand 3 states.
[2020-05-30 20:24:33,611 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:33,612 INFO  L93              Difference]: Finished difference Result 14078 states and 17562 transitions.
[2020-05-30 20:24:33,612 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:24:33,612 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14078 states and 17562 transitions.
[2020-05-30 20:24:33,648 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:33,697 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14078 states to 13092 states and 16020 transitions.
[2020-05-30 20:24:33,698 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 389
[2020-05-30 20:24:33,698 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 389
[2020-05-30 20:24:33,698 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13092 states and 16020 transitions.
[2020-05-30 20:24:33,710 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:33,710 INFO  L728         BuchiCegarLoop]: Abstraction has 13092 states and 16020 transitions.
[2020-05-30 20:24:33,724 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13092 states and 16020 transitions.
[2020-05-30 20:24:33,840 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13092 to 12397.
[2020-05-30 20:24:33,841 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12397 states.
[2020-05-30 20:24:33,856 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12397 states to 12397 states and 15150 transitions.
[2020-05-30 20:24:33,856 INFO  L751         BuchiCegarLoop]: Abstraction has 12397 states and 15150 transitions.
[2020-05-30 20:24:33,856 INFO  L631         BuchiCegarLoop]: Abstraction has 12397 states and 15150 transitions.
[2020-05-30 20:24:33,856 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:24:33,857 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12397 states and 15150 transitions.
[2020-05-30 20:24:33,871 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:33,871 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:33,872 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:33,874 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:33,874 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:33,880 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:33,880 INFO  L82        PathProgramCache]: Analyzing trace with hash -164608755, now seen corresponding path program 1 times
[2020-05-30 20:24:33,881 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:33,893 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:34,042 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:24:34,042 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:34,042 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:24:34,043 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:34,043 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:24:34,043 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:24:34,043 INFO  L87              Difference]: Start difference. First operand 12397 states and 15150 transitions. cyclomatic complexity: 2777 Second operand 4 states.
[2020-05-30 20:24:36,910 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:36,910 INFO  L93              Difference]: Finished difference Result 14292 states and 17260 transitions.
[2020-05-30 20:24:36,910 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:24:36,910 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14292 states and 17260 transitions.
[2020-05-30 20:24:36,940 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:24:36,984 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14292 states to 14092 states and 16873 transitions.
[2020-05-30 20:24:36,984 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 437
[2020-05-30 20:24:36,985 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 437
[2020-05-30 20:24:36,985 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14092 states and 16873 transitions.
[2020-05-30 20:24:36,994 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:36,994 INFO  L728         BuchiCegarLoop]: Abstraction has 14092 states and 16873 transitions.
[2020-05-30 20:24:37,006 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14092 states and 16873 transitions.
[2020-05-30 20:24:37,106 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14092 to 12188.
[2020-05-30 20:24:37,106 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12188 states.
[2020-05-30 20:24:37,120 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12188 states to 12188 states and 14424 transitions.
[2020-05-30 20:24:37,120 INFO  L751         BuchiCegarLoop]: Abstraction has 12188 states and 14424 transitions.
[2020-05-30 20:24:37,120 INFO  L631         BuchiCegarLoop]: Abstraction has 12188 states and 14424 transitions.
[2020-05-30 20:24:37,120 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:24:37,120 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12188 states and 14424 transitions.
[2020-05-30 20:24:37,133 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:37,133 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:37,133 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:37,135 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:37,135 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:37,140 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:37,140 INFO  L82        PathProgramCache]: Analyzing trace with hash 1790744995, now seen corresponding path program 1 times
[2020-05-30 20:24:37,141 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:37,158 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:37,223 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:24:37,224 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:37,224 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:24:37,224 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:37,224 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:24:37,224 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:24:37,224 INFO  L87              Difference]: Start difference. First operand 12188 states and 14424 transitions. cyclomatic complexity: 2260 Second operand 3 states.
[2020-05-30 20:24:37,372 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:37,372 INFO  L93              Difference]: Finished difference Result 12220 states and 14456 transitions.
[2020-05-30 20:24:37,372 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:24:37,372 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12220 states and 14456 transitions.
[2020-05-30 20:24:37,392 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:37,423 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12220 states to 12220 states and 14456 transitions.
[2020-05-30 20:24:37,423 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 368
[2020-05-30 20:24:37,424 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 368
[2020-05-30 20:24:37,424 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12220 states and 14456 transitions.
[2020-05-30 20:24:37,431 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:37,431 INFO  L728         BuchiCegarLoop]: Abstraction has 12220 states and 14456 transitions.
[2020-05-30 20:24:37,442 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12220 states and 14456 transitions.
[2020-05-30 20:24:37,518 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12220 to 12212.
[2020-05-30 20:24:37,518 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12212 states.
[2020-05-30 20:24:37,532 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12212 states to 12212 states and 14448 transitions.
[2020-05-30 20:24:37,532 INFO  L751         BuchiCegarLoop]: Abstraction has 12212 states and 14448 transitions.
[2020-05-30 20:24:37,532 INFO  L631         BuchiCegarLoop]: Abstraction has 12212 states and 14448 transitions.
[2020-05-30 20:24:37,532 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:24:37,532 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12212 states and 14448 transitions.
[2020-05-30 20:24:37,544 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:37,544 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:37,544 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:37,546 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:37,546 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:37,550 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:37,551 INFO  L82        PathProgramCache]: Analyzing trace with hash -2134067866, now seen corresponding path program 1 times
[2020-05-30 20:24:37,551 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:37,567 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:37,658 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:24:37,659 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:37,659 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [5] imperfect sequences [] total 5
[2020-05-30 20:24:37,659 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:37,659 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:24:37,659 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:24:37,660 INFO  L87              Difference]: Start difference. First operand 12212 states and 14448 transitions. cyclomatic complexity: 2260 Second operand 6 states.
[2020-05-30 20:24:38,298 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:38,298 INFO  L93              Difference]: Finished difference Result 12356 states and 14616 transitions.
[2020-05-30 20:24:38,299 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:24:38,299 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12356 states and 14616 transitions.
[2020-05-30 20:24:38,325 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:38,355 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12356 states to 12252 states and 14496 transitions.
[2020-05-30 20:24:38,356 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 370
[2020-05-30 20:24:38,356 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 370
[2020-05-30 20:24:38,356 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12252 states and 14496 transitions.
[2020-05-30 20:24:38,364 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:38,364 INFO  L728         BuchiCegarLoop]: Abstraction has 12252 states and 14496 transitions.
[2020-05-30 20:24:38,375 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12252 states and 14496 transitions.
[2020-05-30 20:24:38,441 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12252 to 12252.
[2020-05-30 20:24:38,441 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12252 states.
[2020-05-30 20:24:38,454 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12252 states to 12252 states and 14496 transitions.
[2020-05-30 20:24:38,454 INFO  L751         BuchiCegarLoop]: Abstraction has 12252 states and 14496 transitions.
[2020-05-30 20:24:38,454 INFO  L631         BuchiCegarLoop]: Abstraction has 12252 states and 14496 transitions.
[2020-05-30 20:24:38,454 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:24:38,455 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12252 states and 14496 transitions.
[2020-05-30 20:24:38,467 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:24:38,467 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:38,467 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:38,468 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:38,468 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:38,472 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:38,473 INFO  L82        PathProgramCache]: Analyzing trace with hash 1460906970, now seen corresponding path program 1 times
[2020-05-30 20:24:38,473 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:38,489 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:38,642 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:24:38,643 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:38,643 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:24:38,643 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:38,643 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:24:38,643 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:24:38,644 INFO  L87              Difference]: Start difference. First operand 12252 states and 14496 transitions. cyclomatic complexity: 2268 Second operand 10 states.
[2020-05-30 20:24:49,657 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:49,657 INFO  L93              Difference]: Finished difference Result 14350 states and 17251 transitions.
[2020-05-30 20:24:49,658 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:24:49,658 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14350 states and 17251 transitions.
[2020-05-30 20:24:49,697 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:24:49,742 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14350 states to 14294 states and 17187 transitions.
[2020-05-30 20:24:49,742 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 471
[2020-05-30 20:24:49,743 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 471
[2020-05-30 20:24:49,743 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14294 states and 17187 transitions.
[2020-05-30 20:24:49,757 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:49,757 INFO  L728         BuchiCegarLoop]: Abstraction has 14294 states and 17187 transitions.
[2020-05-30 20:24:49,771 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14294 states and 17187 transitions.
[2020-05-30 20:24:49,889 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14294 to 13880.
[2020-05-30 20:24:49,890 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13880 states.
[2020-05-30 20:24:49,912 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13880 states to 13880 states and 16591 transitions.
[2020-05-30 20:24:49,912 INFO  L751         BuchiCegarLoop]: Abstraction has 13880 states and 16591 transitions.
[2020-05-30 20:24:49,912 INFO  L631         BuchiCegarLoop]: Abstraction has 13880 states and 16591 transitions.
[2020-05-30 20:24:49,912 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:24:49,912 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13880 states and 16591 transitions.
[2020-05-30 20:24:49,965 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:24:49,965 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:49,965 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:49,967 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:49,967 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND FALSE  !(Balance[from] >= amount)
[L3277]                    success := false;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:50,026 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:50,026 INFO  L82        PathProgramCache]: Analyzing trace with hash 1846802080, now seen corresponding path program 1 times
[2020-05-30 20:24:50,027 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:50,041 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:50,106 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:24:50,106 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:50,107 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:24:50,107 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:50,107 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:24:50,107 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:24:50,107 INFO  L87              Difference]: Start difference. First operand 13880 states and 16591 transitions. cyclomatic complexity: 2735 Second operand 4 states.
[2020-05-30 20:24:50,180 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:24:50,181 INFO  L93              Difference]: Finished difference Result 13960 states and 16675 transitions.
[2020-05-30 20:24:50,181 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:24:50,181 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13960 states and 16675 transitions.
[2020-05-30 20:24:50,211 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:24:50,246 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13960 states to 13944 states and 16659 transitions.
[2020-05-30 20:24:50,246 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 478
[2020-05-30 20:24:50,247 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 478
[2020-05-30 20:24:50,247 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13944 states and 16659 transitions.
[2020-05-30 20:24:50,256 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:24:50,256 INFO  L728         BuchiCegarLoop]: Abstraction has 13944 states and 16659 transitions.
[2020-05-30 20:24:50,266 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13944 states and 16659 transitions.
[2020-05-30 20:24:50,342 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13944 to 13944.
[2020-05-30 20:24:50,343 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13944 states.
[2020-05-30 20:24:50,360 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13944 states to 13944 states and 16659 transitions.
[2020-05-30 20:24:50,360 INFO  L751         BuchiCegarLoop]: Abstraction has 13944 states and 16659 transitions.
[2020-05-30 20:24:50,360 INFO  L631         BuchiCegarLoop]: Abstraction has 13944 states and 16659 transitions.
[2020-05-30 20:24:50,360 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:24:50,360 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13944 states and 16659 transitions.
[2020-05-30 20:24:50,374 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:24:50,375 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:24:50,375 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:24:50,376 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:24:50,376 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND TRUE   choice == 11
[L3703]              gas := gas - 21000;
[L3704]  COND FALSE  !(gas >= 0)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:24:50,380 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:24:50,380 INFO  L82        PathProgramCache]: Analyzing trace with hash -1644301225, now seen corresponding path program 1 times
[2020-05-30 20:24:50,380 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:24:50,399 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:24:50,522 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:24:50,522 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:24:50,522 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [16] imperfect sequences [] total 16
[2020-05-30 20:24:50,523 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:24:50,523 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 16 interpolants.
[2020-05-30 20:24:50,523 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=76, Invalid=164, Unknown=0, NotChecked=0, Total=240
[2020-05-30 20:24:50,523 INFO  L87              Difference]: Start difference. First operand 13944 states and 16659 transitions. cyclomatic complexity: 2739 Second operand 16 states.
[2020-05-30 20:25:00,621 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:25:00,621 INFO  L93              Difference]: Finished difference Result 18241 states and 21930 transitions.
[2020-05-30 20:25:00,621 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 20 states. 
[2020-05-30 20:25:00,622 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 18241 states and 21930 transitions.
[2020-05-30 20:25:00,655 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 16
[2020-05-30 20:25:00,705 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 18241 states to 18241 states and 21930 transitions.
[2020-05-30 20:25:00,705 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 699
[2020-05-30 20:25:00,705 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 699
[2020-05-30 20:25:00,705 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18241 states and 21930 transitions.
[2020-05-30 20:25:00,717 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:25:00,717 INFO  L728         BuchiCegarLoop]: Abstraction has 18241 states and 21930 transitions.
[2020-05-30 20:25:00,727 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18241 states and 21930 transitions.
[2020-05-30 20:25:00,818 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18241 to 13978.
[2020-05-30 20:25:00,818 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13978 states.
[2020-05-30 20:25:00,835 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13978 states to 13978 states and 16513 transitions.
[2020-05-30 20:25:00,835 INFO  L751         BuchiCegarLoop]: Abstraction has 13978 states and 16513 transitions.
[2020-05-30 20:25:00,835 INFO  L631         BuchiCegarLoop]: Abstraction has 13978 states and 16513 transitions.
[2020-05-30 20:25:00,835 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:25:00,835 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13978 states and 16513 transitions.
[2020-05-30 20:25:00,849 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:25:00,849 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:25:00,849 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:25:00,851 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:25:00,851 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:25:00,854 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:25:00,854 INFO  L82        PathProgramCache]: Analyzing trace with hash 1964937597, now seen corresponding path program 1 times
[2020-05-30 20:25:00,855 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:25:00,875 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:25:01,109 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:25:01,109 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:25:01,109 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [29] imperfect sequences [] total 29
[2020-05-30 20:25:01,109 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:25:01,110 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 30 interpolants.
[2020-05-30 20:25:01,110 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=73, Invalid=797, Unknown=0, NotChecked=0, Total=870
[2020-05-30 20:25:01,110 INFO  L87              Difference]: Start difference. First operand 13978 states and 16513 transitions. cyclomatic complexity: 2559 Second operand 30 states.
[2020-05-30 20:25:43,705 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:25:43,706 INFO  L93              Difference]: Finished difference Result 29986 states and 36059 transitions.
[2020-05-30 20:25:43,706 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 53 states. 
[2020-05-30 20:25:43,706 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 29986 states and 36059 transitions.
[2020-05-30 20:25:43,776 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:25:43,868 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 29986 states to 29986 states and 36059 transitions.
[2020-05-30 20:25:43,868 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1248
[2020-05-30 20:25:43,869 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1248
[2020-05-30 20:25:43,869 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 29986 states and 36059 transitions.
[2020-05-30 20:25:43,891 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:25:43,891 INFO  L728         BuchiCegarLoop]: Abstraction has 29986 states and 36059 transitions.
[2020-05-30 20:25:43,907 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 29986 states and 36059 transitions.
[2020-05-30 20:25:44,136 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 29986 to 29038.
[2020-05-30 20:25:44,137 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 29038 states.
[2020-05-30 20:25:44,176 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 29038 states to 29038 states and 34707 transitions.
[2020-05-30 20:25:44,176 INFO  L751         BuchiCegarLoop]: Abstraction has 29038 states and 34707 transitions.
[2020-05-30 20:25:44,176 INFO  L631         BuchiCegarLoop]: Abstraction has 29038 states and 34707 transitions.
[2020-05-30 20:25:44,176 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:25:44,176 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 29038 states and 34707 transitions.
[2020-05-30 20:25:44,208 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:25:44,208 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:25:44,208 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:25:44,209 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:25:44,210 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:25:44,213 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:25:44,213 INFO  L82        PathProgramCache]: Analyzing trace with hash 806488149, now seen corresponding path program 1 times
[2020-05-30 20:25:44,214 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:25:44,227 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:25:44,311 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:25:44,311 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:25:44,311 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:25:44,312 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:25:44,312 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:25:44,312 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:25:44,312 INFO  L87              Difference]: Start difference. First operand 29038 states and 34707 transitions. cyclomatic complexity: 5717 Second operand 13 states.
[2020-05-30 20:25:52,324 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:25:52,324 INFO  L93              Difference]: Finished difference Result 29290 states and 35178 transitions.
[2020-05-30 20:25:52,324 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 15 states. 
[2020-05-30 20:25:52,324 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 29290 states and 35178 transitions.
[2020-05-30 20:25:52,395 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:25:52,490 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 29290 states to 29290 states and 35178 transitions.
[2020-05-30 20:25:52,490 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1151
[2020-05-30 20:25:52,491 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1151
[2020-05-30 20:25:52,491 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 29290 states and 35178 transitions.
[2020-05-30 20:25:52,515 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:25:52,515 INFO  L728         BuchiCegarLoop]: Abstraction has 29290 states and 35178 transitions.
[2020-05-30 20:25:52,532 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 29290 states and 35178 transitions.
[2020-05-30 20:25:52,773 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 29290 to 29072.
[2020-05-30 20:25:52,773 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 29072 states.
[2020-05-30 20:25:52,820 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 29072 states to 29072 states and 34804 transitions.
[2020-05-30 20:25:52,821 INFO  L751         BuchiCegarLoop]: Abstraction has 29072 states and 34804 transitions.
[2020-05-30 20:25:52,821 INFO  L631         BuchiCegarLoop]: Abstraction has 29072 states and 34804 transitions.
[2020-05-30 20:25:52,821 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:25:52,821 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 29072 states and 34804 transitions.
[2020-05-30 20:25:52,853 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:25:52,854 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:25:52,854 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:25:52,856 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:25:52,856 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND FALSE  !(gas < 21000)
[L2846]        COND TRUE   DType[from] == RefundEscrow
[L2848]        COND FALSE  !(choice == 11)
[L2861]        COND FALSE  !(choice == 10)
[L2874]        COND FALSE  !(choice == 9)
[L2887]        COND FALSE  !(choice == 8)
[L2900]        COND FALSE  !(choice == 7)
[L2913]        COND FALSE  !(choice == 6)
[L2926]        COND FALSE  !(choice == 5)
[L2939]        COND FALSE  !(choice == 4)
[L2952]        COND FALSE  !(choice == 3)
[L2965]        COND TRUE   choice == 2
[L2967]                    gas := gas - 21000;
[L2968]        COND TRUE   gas >= 0
[L2970]                    assume msgvalue_MSG == 0;
[L2971]        CALL        call enableRefunds_RefundEscrow__success(from, to, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L2971]        RET         call enableRefunds_RefundEscrow__success(from, to, msgvalue_MSG);
[L2972]        COND FALSE  !(revert)
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:25:52,860 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:25:52,860 INFO  L82        PathProgramCache]: Analyzing trace with hash 1704089187, now seen corresponding path program 1 times
[2020-05-30 20:25:52,861 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:25:52,877 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:25:52,973 INFO  L134       CoverageAnalysis]: Checked inductivity of 163 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 163 trivial. 0 not checked.
[2020-05-30 20:25:52,974 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:25:52,974 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 20:25:52,974 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:25:52,974 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:25:52,974 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=11, Invalid=19, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:25:52,975 INFO  L87              Difference]: Start difference. First operand 29072 states and 34804 transitions. cyclomatic complexity: 5782 Second operand 6 states.
[2020-05-30 20:25:55,004 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:25:55,004 INFO  L93              Difference]: Finished difference Result 20116 states and 22817 transitions.
[2020-05-30 20:25:55,005 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 20:25:55,005 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20116 states and 22817 transitions.
[2020-05-30 20:25:55,054 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 24
[2020-05-30 20:25:55,106 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20116 states to 18996 states and 21453 transitions.
[2020-05-30 20:25:55,106 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 690
[2020-05-30 20:25:55,109 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2356
[2020-05-30 20:25:55,109 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18996 states and 21453 transitions.
[2020-05-30 20:25:55,122 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:25:55,122 INFO  L728         BuchiCegarLoop]: Abstraction has 18996 states and 21453 transitions.
[2020-05-30 20:25:55,133 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18996 states and 21453 transitions.
[2020-05-30 20:25:55,243 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18996 to 17824.
[2020-05-30 20:25:55,243 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 17824 states.
[2020-05-30 20:25:55,265 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 17824 states to 17824 states and 19796 transitions.
[2020-05-30 20:25:55,265 INFO  L751         BuchiCegarLoop]: Abstraction has 17824 states and 19796 transitions.
[2020-05-30 20:25:55,265 INFO  L631         BuchiCegarLoop]: Abstraction has 17824 states and 19796 transitions.
[2020-05-30 20:25:55,265 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:25:55,265 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 17824 states and 19796 transitions.
[2020-05-30 20:25:55,285 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:25:55,285 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:25:55,285 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:25:55,287 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:25:55,287 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:25:55,291 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:25:55,291 INFO  L82        PathProgramCache]: Analyzing trace with hash -1879259949, now seen corresponding path program 1 times
[2020-05-30 20:25:55,292 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:25:55,308 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:25:55,416 INFO  L134       CoverageAnalysis]: Checked inductivity of 158 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:25:55,416 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:25:55,416 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:25:55,417 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:25:55,417 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:25:55,417 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:25:55,417 INFO  L87              Difference]: Start difference. First operand 17824 states and 19796 transitions. cyclomatic complexity: 1990 Second operand 11 states.
[2020-05-30 20:25:58,294 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:25:58,294 INFO  L93              Difference]: Finished difference Result 16646 states and 18282 transitions.
[2020-05-30 20:25:58,294 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:25:58,294 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16646 states and 18282 transitions.
[2020-05-30 20:25:58,330 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:25:58,352 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16646 states to 11383 states and 12428 transitions.
[2020-05-30 20:25:58,352 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1736
[2020-05-30 20:25:58,353 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1764
[2020-05-30 20:25:58,353 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11383 states and 12428 transitions.
[2020-05-30 20:25:58,358 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:25:58,358 INFO  L728         BuchiCegarLoop]: Abstraction has 11383 states and 12428 transitions.
[2020-05-30 20:25:58,363 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11383 states and 12428 transitions.
[2020-05-30 20:25:58,418 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11383 to 11365.
[2020-05-30 20:25:58,418 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11365 states.
[2020-05-30 20:25:58,429 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11365 states to 11365 states and 12408 transitions.
[2020-05-30 20:25:58,429 INFO  L751         BuchiCegarLoop]: Abstraction has 11365 states and 12408 transitions.
[2020-05-30 20:25:58,429 INFO  L631         BuchiCegarLoop]: Abstraction has 11365 states and 12408 transitions.
[2020-05-30 20:25:58,429 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:25:58,429 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11365 states and 12408 transitions.
[2020-05-30 20:25:58,441 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:25:58,441 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:25:58,441 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:25:58,442 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:25:58,443 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:25:58,446 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:25:58,447 INFO  L82        PathProgramCache]: Analyzing trace with hash 1491219336, now seen corresponding path program 1 times
[2020-05-30 20:25:58,447 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:25:58,470 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:25:58,892 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:25:58,892 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:25:58,893 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [44] imperfect sequences [] total 44
[2020-05-30 20:25:58,893 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:25:58,893 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-05-30 20:25:58,894 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=133, Invalid=1847, Unknown=0, NotChecked=0, Total=1980
[2020-05-30 20:25:58,894 INFO  L87              Difference]: Start difference. First operand 11365 states and 12408 transitions. cyclomatic complexity: 1055 Second operand 45 states.
[2020-05-30 20:26:17,898 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:17,898 INFO  L93              Difference]: Finished difference Result 16022 states and 17970 transitions.
[2020-05-30 20:26:17,898 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 84 states. 
[2020-05-30 20:26:17,898 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16022 states and 17970 transitions.
[2020-05-30 20:26:17,930 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:17,969 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16022 states to 15638 states and 17505 transitions.
[2020-05-30 20:26:17,969 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2062
[2020-05-30 20:26:17,970 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2062
[2020-05-30 20:26:17,970 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15638 states and 17505 transitions.
[2020-05-30 20:26:17,978 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:17,978 INFO  L728         BuchiCegarLoop]: Abstraction has 15638 states and 17505 transitions.
[2020-05-30 20:26:17,984 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15638 states and 17505 transitions.
[2020-05-30 20:26:18,073 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15638 to 15156.
[2020-05-30 20:26:18,073 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15156 states.
[2020-05-30 20:26:18,091 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15156 states to 15156 states and 16878 transitions.
[2020-05-30 20:26:18,091 INFO  L751         BuchiCegarLoop]: Abstraction has 15156 states and 16878 transitions.
[2020-05-30 20:26:18,091 INFO  L631         BuchiCegarLoop]: Abstraction has 15156 states and 16878 transitions.
[2020-05-30 20:26:18,091 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:26:18,091 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15156 states and 16878 transitions.
[2020-05-30 20:26:18,108 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:18,108 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:18,108 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:18,109 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:18,109 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND FALSE  !(choice == 2)
[L3791]        COND TRUE   choice == 1
[L3793]                    gas := gas - 21000;
[L3794]        COND TRUE   gas >= 0
[L3796]                    assume msgvalue_MSG == 0;
[L3797]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L3797]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND TRUE   choice == 1
[L3793]              gas := gas - 21000;
[L3794]  COND TRUE   gas >= 0
[L3796]              assume msgvalue_MSG == 0;
[L3797]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3244]              havoc __exception;
[L3245]  COND FALSE  !(__exception)
[L3270]  COND TRUE   Balance[from] >= amount
[L3272]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]              assume Balance[from] >= amount;
[L2833]              Balance[from] := Balance[from] - amount;
[L2834]              Balance[to] := Balance[to] + amount;
[L2835]  COND FALSE  !(choice == 0)
[L2841]  COND TRUE   gas < 21000
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L3272]  RET         call FallbackDispatch__success(from, to, amount);
[L3273]              success := true;
[L3280]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L3797]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:18,114 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:18,114 INFO  L82        PathProgramCache]: Analyzing trace with hash -1925210844, now seen corresponding path program 1 times
[2020-05-30 20:26:18,115 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:18,130 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:18,233 INFO  L134       CoverageAnalysis]: Checked inductivity of 150 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:26:18,234 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:26:18,234 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:26:18,234 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:18,234 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:26:18,234 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:26:18,235 INFO  L87              Difference]: Start difference. First operand 15156 states and 16878 transitions. cyclomatic complexity: 1756 Second operand 11 states.
[2020-05-30 20:26:20,131 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:20,131 INFO  L93              Difference]: Finished difference Result 15307 states and 17040 transitions.
[2020-05-30 20:26:20,131 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 20:26:20,131 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15307 states and 17040 transitions.
[2020-05-30 20:26:20,165 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:20,205 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15307 states to 15307 states and 17040 transitions.
[2020-05-30 20:26:20,205 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2064
[2020-05-30 20:26:20,206 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2064
[2020-05-30 20:26:20,206 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15307 states and 17040 transitions.
[2020-05-30 20:26:20,214 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:20,214 INFO  L728         BuchiCegarLoop]: Abstraction has 15307 states and 17040 transitions.
[2020-05-30 20:26:20,222 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15307 states and 17040 transitions.
[2020-05-30 20:26:20,309 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15307 to 15071.
[2020-05-30 20:26:20,310 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15071 states.
[2020-05-30 20:26:20,325 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15071 states to 15071 states and 16757 transitions.
[2020-05-30 20:26:20,325 INFO  L751         BuchiCegarLoop]: Abstraction has 15071 states and 16757 transitions.
[2020-05-30 20:26:20,325 INFO  L631         BuchiCegarLoop]: Abstraction has 15071 states and 16757 transitions.
[2020-05-30 20:26:20,325 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:26:20,325 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15071 states and 16757 transitions.
[2020-05-30 20:26:20,340 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:20,340 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:20,340 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:20,341 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:20,341 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:20,344 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:20,345 INFO  L82        PathProgramCache]: Analyzing trace with hash -91909323, now seen corresponding path program 1 times
[2020-05-30 20:26:20,345 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:20,376 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:20,578 WARN  L188               SmtUtils]: Spent 111.00 ms on a formula simplification that was a NOOP. DAG size: 20
[2020-05-30 20:26:20,897 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 21 proven. 22 refuted. 0 times theorem prover too weak. 178 trivial. 0 not checked.
[2020-05-30 20:26:20,897 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:26:20,897 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-05-30 20:26:20,898 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:20,898 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-05-30 20:26:20,898 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=103, Invalid=1379, Unknown=0, NotChecked=0, Total=1482
[2020-05-30 20:26:20,898 INFO  L87              Difference]: Start difference. First operand 15071 states and 16757 transitions. cyclomatic complexity: 1720 Second operand 39 states.
[2020-05-30 20:26:33,813 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:33,814 INFO  L93              Difference]: Finished difference Result 15497 states and 17492 transitions.
[2020-05-30 20:26:33,814 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 59 states. 
[2020-05-30 20:26:33,814 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15497 states and 17492 transitions.
[2020-05-30 20:26:33,850 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:33,896 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15497 states to 15497 states and 17492 transitions.
[2020-05-30 20:26:33,896 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2048
[2020-05-30 20:26:33,897 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2048
[2020-05-30 20:26:33,897 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15497 states and 17492 transitions.
[2020-05-30 20:26:33,907 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:33,907 INFO  L728         BuchiCegarLoop]: Abstraction has 15497 states and 17492 transitions.
[2020-05-30 20:26:33,914 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15497 states and 17492 transitions.
[2020-05-30 20:26:34,003 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15497 to 15382.
[2020-05-30 20:26:34,004 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15382 states.
[2020-05-30 20:26:34,023 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15382 states to 15382 states and 17306 transitions.
[2020-05-30 20:26:34,023 INFO  L751         BuchiCegarLoop]: Abstraction has 15382 states and 17306 transitions.
[2020-05-30 20:26:34,023 INFO  L631         BuchiCegarLoop]: Abstraction has 15382 states and 17306 transitions.
[2020-05-30 20:26:34,023 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:26:34,024 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15382 states and 17306 transitions.
[2020-05-30 20:26:34,041 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:26:34,041 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:34,041 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:34,042 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:34,042 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND TRUE   choice == 3
[L3775]                    gas := gas - 21000;
[L3776]        COND TRUE   gas >= 0
[L3778]                    assume msgvalue_MSG == 0;
[L3779]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3779]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND TRUE   choice == 10
[L3712]              gas := gas - 21000;
[L3713]  COND TRUE   gas >= 0
[L3715]              assume msgvalue_MSG == 0;
[L3716]  CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]               havoc __exception;
[L231]               revert := false;
[L232]   COND FALSE  !(__exception)
[L251]   CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]              gas := gas - 2208;
[L3301]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]  COND FALSE  !(revert)
[L1429]              gas := gas - 88;
[L1430]              __var_1 := null;
[L1431]  COND FALSE  !(!(recipient_s113 != null))
[L1437]              gas := gas - 40534;
[L1438]              _primary_Secondary[this] := recipient_s113;
[L1439]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]   RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]               assume !revert && gas >= 0;
[L3716]  RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:34,046 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:34,046 INFO  L82        PathProgramCache]: Analyzing trace with hash -1428917682, now seen corresponding path program 1 times
[2020-05-30 20:26:34,047 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:34,060 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:34,222 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 34 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:26:34,222 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:26:34,222 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:26:34,222 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:34,222 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:26:34,223 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:26:34,223 INFO  L87              Difference]: Start difference. First operand 15382 states and 17306 transitions. cyclomatic complexity: 1977 Second operand 13 states.
[2020-05-30 20:26:35,253 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:35,254 INFO  L93              Difference]: Finished difference Result 10218 states and 11350 transitions.
[2020-05-30 20:26:35,254 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 15 states. 
[2020-05-30 20:26:35,254 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10218 states and 11350 transitions.
[2020-05-30 20:26:35,272 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:35,290 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10218 states to 9488 states and 10564 transitions.
[2020-05-30 20:26:35,290 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:26:35,291 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:26:35,291 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9488 states and 10564 transitions.
[2020-05-30 20:26:35,295 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:35,295 INFO  L728         BuchiCegarLoop]: Abstraction has 9488 states and 10564 transitions.
[2020-05-30 20:26:35,299 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9488 states and 10564 transitions.
[2020-05-30 20:26:35,340 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9488 to 8990.
[2020-05-30 20:26:35,340 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8990 states.
[2020-05-30 20:26:35,348 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8990 states to 8990 states and 9922 transitions.
[2020-05-30 20:26:35,348 INFO  L751         BuchiCegarLoop]: Abstraction has 8990 states and 9922 transitions.
[2020-05-30 20:26:35,348 INFO  L631         BuchiCegarLoop]: Abstraction has 8990 states and 9922 transitions.
[2020-05-30 20:26:35,348 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:26:35,348 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8990 states and 9922 transitions.
[2020-05-30 20:26:35,356 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:35,357 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:35,357 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:35,358 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:35,358 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:35,362 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:35,362 INFO  L82        PathProgramCache]: Analyzing trace with hash -762813464, now seen corresponding path program 1 times
[2020-05-30 20:26:35,362 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:35,389 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:35,869 INFO  L134       CoverageAnalysis]: Checked inductivity of 251 backedges. 11 proven. 57 refuted. 0 times theorem prover too weak. 183 trivial. 0 not checked.
[2020-05-30 20:26:35,869 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:26:35,869 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:26:35,870 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:35,870 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:26:35,871 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=204, Invalid=2448, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:26:35,871 INFO  L87              Difference]: Start difference. First operand 8990 states and 9922 transitions. cyclomatic complexity: 959 Second operand 52 states.
[2020-05-30 20:26:45,335 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:45,335 INFO  L93              Difference]: Finished difference Result 9167 states and 10169 transitions.
[2020-05-30 20:26:45,336 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 20:26:45,336 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9167 states and 10169 transitions.
[2020-05-30 20:26:45,355 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:45,372 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9167 states to 8915 states and 9839 transitions.
[2020-05-30 20:26:45,372 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:26:45,373 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:26:45,373 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8915 states and 9839 transitions.
[2020-05-30 20:26:45,377 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:45,377 INFO  L728         BuchiCegarLoop]: Abstraction has 8915 states and 9839 transitions.
[2020-05-30 20:26:45,381 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8915 states and 9839 transitions.
[2020-05-30 20:26:45,419 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8915 to 8720.
[2020-05-30 20:26:45,419 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8720 states.
[2020-05-30 20:26:45,427 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8720 states to 8720 states and 9602 transitions.
[2020-05-30 20:26:45,427 INFO  L751         BuchiCegarLoop]: Abstraction has 8720 states and 9602 transitions.
[2020-05-30 20:26:45,427 INFO  L631         BuchiCegarLoop]: Abstraction has 8720 states and 9602 transitions.
[2020-05-30 20:26:45,428 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:26:45,428 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8720 states and 9602 transitions.
[2020-05-30 20:26:45,435 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:45,435 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:45,435 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:45,436 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:45,437 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:45,440 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:45,440 INFO  L82        PathProgramCache]: Analyzing trace with hash 1716270285, now seen corresponding path program 1 times
[2020-05-30 20:26:45,440 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:45,452 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:45,577 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 1 proven. 0 refuted. 0 times theorem prover too weak. 220 trivial. 0 not checked.
[2020-05-30 20:26:45,577 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:26:45,578 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:26:45,578 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:45,578 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:26:45,578 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:26:45,579 INFO  L87              Difference]: Start difference. First operand 8720 states and 9602 transitions. cyclomatic complexity: 909 Second operand 3 states.
[2020-05-30 20:26:45,673 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:26:45,674 INFO  L93              Difference]: Finished difference Result 8724 states and 9602 transitions.
[2020-05-30 20:26:45,674 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:26:45,674 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8724 states and 9602 transitions.
[2020-05-30 20:26:45,686 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:45,699 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8724 states to 8724 states and 9602 transitions.
[2020-05-30 20:26:45,699 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1716
[2020-05-30 20:26:45,700 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1716
[2020-05-30 20:26:45,700 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8724 states and 9602 transitions.
[2020-05-30 20:26:45,703 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:26:45,703 INFO  L728         BuchiCegarLoop]: Abstraction has 8724 states and 9602 transitions.
[2020-05-30 20:26:45,706 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8724 states and 9602 transitions.
[2020-05-30 20:26:45,741 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8724 to 8720.
[2020-05-30 20:26:45,741 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8720 states.
[2020-05-30 20:26:45,749 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8720 states to 8720 states and 9597 transitions.
[2020-05-30 20:26:45,749 INFO  L751         BuchiCegarLoop]: Abstraction has 8720 states and 9597 transitions.
[2020-05-30 20:26:45,749 INFO  L631         BuchiCegarLoop]: Abstraction has 8720 states and 9597 transitions.
[2020-05-30 20:26:45,749 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:26:45,750 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8720 states and 9597 transitions.
[2020-05-30 20:26:45,757 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:26:45,757 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:26:45,758 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:26:45,759 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:26:45,759 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:26:45,762 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:26:45,763 INFO  L82        PathProgramCache]: Analyzing trace with hash 544419526, now seen corresponding path program 1 times
[2020-05-30 20:26:45,763 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:26:45,782 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:26:46,178 INFO  L134       CoverageAnalysis]: Checked inductivity of 222 backedges. 62 proven. 33 refuted. 0 times theorem prover too weak. 127 trivial. 0 not checked.
[2020-05-30 20:26:46,179 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:26:46,179 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [44] total 44
[2020-05-30 20:26:46,179 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:26:46,179 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-05-30 20:26:46,179 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=112, Invalid=1868, Unknown=0, NotChecked=0, Total=1980
[2020-05-30 20:26:46,180 INFO  L87              Difference]: Start difference. First operand 8720 states and 9597 transitions. cyclomatic complexity: 904 Second operand 45 states.
[2020-05-30 20:27:05,064 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:27:05,064 INFO  L93              Difference]: Finished difference Result 9676 states and 10844 transitions.
[2020-05-30 20:27:05,064 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 61 states. 
[2020-05-30 20:27:05,065 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9676 states and 10844 transitions.
[2020-05-30 20:27:05,083 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:05,099 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9676 states to 9676 states and 10842 transitions.
[2020-05-30 20:27:05,099 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1736
[2020-05-30 20:27:05,100 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1736
[2020-05-30 20:27:05,100 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9676 states and 10842 transitions.
[2020-05-30 20:27:05,104 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:27:05,104 INFO  L728         BuchiCegarLoop]: Abstraction has 9676 states and 10842 transitions.
[2020-05-30 20:27:05,107 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9676 states and 10842 transitions.
[2020-05-30 20:27:05,149 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9676 to 9441.
[2020-05-30 20:27:05,149 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9441 states.
[2020-05-30 20:27:05,158 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9441 states to 9441 states and 10531 transitions.
[2020-05-30 20:27:05,158 INFO  L751         BuchiCegarLoop]: Abstraction has 9441 states and 10531 transitions.
[2020-05-30 20:27:05,158 INFO  L631         BuchiCegarLoop]: Abstraction has 9441 states and 10531 transitions.
[2020-05-30 20:27:05,158 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:27:05,158 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9441 states and 10531 transitions.
[2020-05-30 20:27:05,167 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:05,167 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:27:05,167 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:27:05,168 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:27:05,168 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:27:05,172 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:27:05,173 INFO  L82        PathProgramCache]: Analyzing trace with hash -135659691, now seen corresponding path program 1 times
[2020-05-30 20:27:05,173 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:27:05,197 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:27:05,727 INFO  L134       CoverageAnalysis]: Checked inductivity of 355 backedges. 25 proven. 79 refuted. 0 times theorem prover too weak. 251 trivial. 0 not checked.
[2020-05-30 20:27:05,727 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:27:05,728 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [42] total 42
[2020-05-30 20:27:05,728 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:27:05,728 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-05-30 20:27:05,728 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1679, Unknown=0, NotChecked=0, Total=1806
[2020-05-30 20:27:05,729 INFO  L87              Difference]: Start difference. First operand 9441 states and 10531 transitions. cyclomatic complexity: 1122 Second operand 43 states.
[2020-05-30 20:27:14,880 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:27:14,880 INFO  L93              Difference]: Finished difference Result 9514 states and 10642 transitions.
[2020-05-30 20:27:14,881 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-30 20:27:14,881 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9514 states and 10642 transitions.
[2020-05-30 20:27:14,903 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:14,922 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9514 states to 9504 states and 10616 transitions.
[2020-05-30 20:27:14,923 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:27:14,923 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:27:14,923 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9504 states and 10616 transitions.
[2020-05-30 20:27:14,928 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:27:14,928 INFO  L728         BuchiCegarLoop]: Abstraction has 9504 states and 10616 transitions.
[2020-05-30 20:27:14,932 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9504 states and 10616 transitions.
[2020-05-30 20:27:14,974 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9504 to 9407.
[2020-05-30 20:27:14,974 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9407 states.
[2020-05-30 20:27:14,984 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9407 states to 9407 states and 10467 transitions.
[2020-05-30 20:27:14,984 INFO  L751         BuchiCegarLoop]: Abstraction has 9407 states and 10467 transitions.
[2020-05-30 20:27:14,984 INFO  L631         BuchiCegarLoop]: Abstraction has 9407 states and 10467 transitions.
[2020-05-30 20:27:14,984 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:27:14,984 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9407 states and 10467 transitions.
[2020-05-30 20:27:14,993 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:14,993 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:27:14,993 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:27:14,994 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:27:14,994 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:27:14,998 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:27:14,998 INFO  L82        PathProgramCache]: Analyzing trace with hash 586364127, now seen corresponding path program 1 times
[2020-05-30 20:27:14,998 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:27:15,023 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:27:15,634 INFO  L134       CoverageAnalysis]: Checked inductivity of 222 backedges. 64 proven. 16 refuted. 0 times theorem prover too weak. 142 trivial. 0 not checked.
[2020-05-30 20:27:15,634 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:27:15,635 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [54] total 54
[2020-05-30 20:27:15,635 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:27:15,635 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 55 interpolants.
[2020-05-30 20:27:15,636 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=166, Invalid=2804, Unknown=0, NotChecked=0, Total=2970
[2020-05-30 20:27:15,636 INFO  L87              Difference]: Start difference. First operand 9407 states and 10467 transitions. cyclomatic complexity: 1087 Second operand 55 states.
[2020-05-30 20:27:29,725 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:27:29,725 INFO  L93              Difference]: Finished difference Result 9669 states and 10844 transitions.
[2020-05-30 20:27:29,726 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 69 states. 
[2020-05-30 20:27:29,726 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9669 states and 10844 transitions.
[2020-05-30 20:27:29,739 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:29,754 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9669 states to 9669 states and 10844 transitions.
[2020-05-30 20:27:29,754 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:27:29,755 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:27:29,755 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9669 states and 10844 transitions.
[2020-05-30 20:27:29,759 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:27:29,759 INFO  L728         BuchiCegarLoop]: Abstraction has 9669 states and 10844 transitions.
[2020-05-30 20:27:29,762 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9669 states and 10844 transitions.
[2020-05-30 20:27:29,801 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9669 to 9474.
[2020-05-30 20:27:29,801 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9474 states.
[2020-05-30 20:27:29,810 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9474 states to 9474 states and 10583 transitions.
[2020-05-30 20:27:29,810 INFO  L751         BuchiCegarLoop]: Abstraction has 9474 states and 10583 transitions.
[2020-05-30 20:27:29,811 INFO  L631         BuchiCegarLoop]: Abstraction has 9474 states and 10583 transitions.
[2020-05-30 20:27:29,811 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:27:29,811 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9474 states and 10583 transitions.
[2020-05-30 20:27:29,819 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:29,819 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:27:29,819 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:27:29,820 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:27:29,821 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:27:29,825 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:27:29,825 INFO  L82        PathProgramCache]: Analyzing trace with hash -936988654, now seen corresponding path program 1 times
[2020-05-30 20:27:29,825 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:27:29,867 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:27:30,407 INFO  L134       CoverageAnalysis]: Checked inductivity of 438 backedges. 42 proven. 77 refuted. 0 times theorem prover too weak. 319 trivial. 0 not checked.
[2020-05-30 20:27:30,407 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:27:30,407 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-30 20:27:30,407 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:27:30,407 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-30 20:27:30,408 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=2225, Unknown=0, NotChecked=0, Total=2352
[2020-05-30 20:27:30,408 INFO  L87              Difference]: Start difference. First operand 9474 states and 10583 transitions. cyclomatic complexity: 1144 Second operand 49 states.
[2020-05-30 20:27:43,399 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:27:43,399 INFO  L93              Difference]: Finished difference Result 9541 states and 10656 transitions.
[2020-05-30 20:27:43,399 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-05-30 20:27:43,399 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9541 states and 10656 transitions.
[2020-05-30 20:27:43,420 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:43,439 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9541 states to 9541 states and 10654 transitions.
[2020-05-30 20:27:43,439 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:27:43,440 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:27:43,440 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9541 states and 10654 transitions.
[2020-05-30 20:27:43,445 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:27:43,445 INFO  L728         BuchiCegarLoop]: Abstraction has 9541 states and 10654 transitions.
[2020-05-30 20:27:43,449 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9541 states and 10654 transitions.
[2020-05-30 20:27:43,494 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9541 to 9363.
[2020-05-30 20:27:43,495 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9363 states.
[2020-05-30 20:27:43,508 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9363 states to 9363 states and 10418 transitions.
[2020-05-30 20:27:43,508 INFO  L751         BuchiCegarLoop]: Abstraction has 9363 states and 10418 transitions.
[2020-05-30 20:27:43,509 INFO  L631         BuchiCegarLoop]: Abstraction has 9363 states and 10418 transitions.
[2020-05-30 20:27:43,509 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:27:43,509 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9363 states and 10418 transitions.
[2020-05-30 20:27:43,523 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:27:43,523 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:27:43,523 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:27:43,525 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:27:43,525 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]  CALL        call CorralChoice_RefundEscrow(this);
[L3674]              havoc msgsender_MSG;
[L3675]              havoc msgvalue_MSG;
[L3676]              havoc choice;
[L3677]              havoc __ret_0_primary;
[L3678]              havoc recipient_s113;
[L3679]              havoc payee_s148;
[L3680]              havoc __ret_0_depositsOf;
[L3681]              havoc refundee_s327;
[L3682]              havoc payee_s255;
[L3683]              havoc __arg_0_withdrawalAllowed;
[L3684]              havoc __ret_0_withdrawalAllowed;
[L3685]              havoc beneficiary_s294;
[L3686]              havoc __ret_0_state;
[L3687]              havoc __ret_0_beneficiary;
[L3688]              havoc tmpNow;
[L3689]              havoc gas;
[L3690]              assume gas > 4000000 && gas <= 8000000;
[L3691]              tmpNow := now;
[L3692]              havoc now;
[L3693]              assume now > tmpNow;
[L3694]              assume msgsender_MSG != null;
[L3695]              assume DType[msgsender_MSG] != SafeMath;
[L3696]              assume DType[msgsender_MSG] != Secondary;
[L3697]              assume DType[msgsender_MSG] != Escrow;
[L3698]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]              assume DType[msgsender_MSG] != RefundEscrow;
[L3700]              Alloc[msgsender_MSG] := true;
[L3701]  COND FALSE  !(choice == 11)
[L3710]  COND FALSE  !(choice == 10)
[L3719]  COND FALSE  !(choice == 9)
[L3728]  COND FALSE  !(choice == 8)
[L3737]  COND FALSE  !(choice == 7)
[L3746]  COND FALSE  !(choice == 6)
[L3755]  COND FALSE  !(choice == 5)
[L3764]  COND FALSE  !(choice == 4)
[L3773]  COND FALSE  !(choice == 3)
[L3782]  COND FALSE  !(choice == 2)
[L3791]  COND FALSE  !(choice == 1)
[L3820]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:27:43,530 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:27:43,530 INFO  L82        PathProgramCache]: Analyzing trace with hash 564404895, now seen corresponding path program 1 times
[2020-05-30 20:27:43,530 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:27:43,601 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:27:44,092 INFO  L134       CoverageAnalysis]: Checked inductivity of 343 backedges. 67 proven. 76 refuted. 0 times theorem prover too weak. 200 trivial. 0 not checked.
[2020-05-30 20:27:44,092 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:27:44,093 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-30 20:27:44,093 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:27:44,093 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-30 20:27:44,093 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=150, Invalid=2202, Unknown=0, NotChecked=0, Total=2352
[2020-05-30 20:27:44,093 INFO  L87              Difference]: Start difference. First operand 9363 states and 10418 transitions. cyclomatic complexity: 1084 Second operand 49 states.
[2020-05-30 20:28:02,663 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:02,663 INFO  L93              Difference]: Finished difference Result 9833 states and 10966 transitions.
[2020-05-30 20:28:02,664 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 66 states. 
[2020-05-30 20:28:02,664 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9833 states and 10966 transitions.
[2020-05-30 20:28:02,685 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:28:02,704 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9833 states to 9833 states and 10964 transitions.
[2020-05-30 20:28:02,704 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1732
[2020-05-30 20:28:02,705 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1732
[2020-05-30 20:28:02,705 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9833 states and 10964 transitions.
[2020-05-30 20:28:02,710 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:02,710 INFO  L728         BuchiCegarLoop]: Abstraction has 9833 states and 10964 transitions.
[2020-05-30 20:28:02,714 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9833 states and 10964 transitions.
[2020-05-30 20:28:02,836 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9833 to 9637.
[2020-05-30 20:28:02,836 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9637 states.
[2020-05-30 20:28:02,849 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9637 states to 9637 states and 10730 transitions.
[2020-05-30 20:28:02,849 INFO  L751         BuchiCegarLoop]: Abstraction has 9637 states and 10730 transitions.
[2020-05-30 20:28:02,849 INFO  L631         BuchiCegarLoop]: Abstraction has 9637 states and 10730 transitions.
[2020-05-30 20:28:02,849 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:28:02,849 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9637 states and 10730 transitions.
[2020-05-30 20:28:02,859 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:28:02,860 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:02,860 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:02,861 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:02,861 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:02,873 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:02,874 INFO  L82        PathProgramCache]: Analyzing trace with hash -2023459713, now seen corresponding path program 1 times
[2020-05-30 20:28:02,874 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:02,906 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:03,664 INFO  L134       CoverageAnalysis]: Checked inductivity of 356 backedges. 68 proven. 73 refuted. 0 times theorem prover too weak. 215 trivial. 0 not checked.
[2020-05-30 20:28:03,664 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:28:03,664 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [59] total 59
[2020-05-30 20:28:03,665 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:03,665 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 60 interpolants.
[2020-05-30 20:28:03,666 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=224, Invalid=3316, Unknown=0, NotChecked=0, Total=3540
[2020-05-30 20:28:03,666 INFO  L87              Difference]: Start difference. First operand 9637 states and 10730 transitions. cyclomatic complexity: 1123 Second operand 60 states.
[2020-05-30 20:28:21,509 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:21,510 INFO  L93              Difference]: Finished difference Result 9893 states and 11112 transitions.
[2020-05-30 20:28:21,510 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 72 states. 
[2020-05-30 20:28:21,510 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9893 states and 11112 transitions.
[2020-05-30 20:28:21,526 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:28:21,543 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9893 states to 9885 states and 11085 transitions.
[2020-05-30 20:28:21,543 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:28:21,544 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:28:21,544 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9885 states and 11085 transitions.
[2020-05-30 20:28:21,548 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:21,548 INFO  L728         BuchiCegarLoop]: Abstraction has 9885 states and 11085 transitions.
[2020-05-30 20:28:21,551 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9885 states and 11085 transitions.
[2020-05-30 20:28:21,591 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9885 to 9683.
[2020-05-30 20:28:21,591 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9683 states.
[2020-05-30 20:28:21,601 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9683 states to 9683 states and 10816 transitions.
[2020-05-30 20:28:21,601 INFO  L751         BuchiCegarLoop]: Abstraction has 9683 states and 10816 transitions.
[2020-05-30 20:28:21,601 INFO  L631         BuchiCegarLoop]: Abstraction has 9683 states and 10816 transitions.
[2020-05-30 20:28:21,601 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:28:21,602 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9683 states and 10816 transitions.
[2020-05-30 20:28:21,610 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:28:21,610 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:28:21,610 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:28:21,612 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:28:21,612 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3811]                    assume null == 0;
[L3812]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3812]        RET         call this := FreshRefGenerator__success();
[L3813]                    assume now >= 0;
[L3814]                    assume DType[this] == RefundEscrow;
[L3815]                    gas := gas - 53000;
[L3816]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3816]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3817]                    assume !revert && gas >= 0;
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND TRUE   choice == 8
[L3730]                    gas := gas - 21000;
[L3731]        COND TRUE   gas >= 0
[L3733]                    assume msgvalue_MSG >= 0;
[L3734]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3734]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND FALSE  !(choice == 7)
[L3746]        COND FALSE  !(choice == 6)
[L3755]        COND FALSE  !(choice == 5)
[L3764]        COND FALSE  !(choice == 4)
[L3773]        COND FALSE  !(choice == 3)
[L3782]        COND TRUE   choice == 2
[L3784]                    gas := gas - 21000;
[L3785]        COND TRUE   gas >= 0
[L3787]                    assume msgvalue_MSG == 0;
[L3788]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3788]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3820]        CALL        call CorralChoice_RefundEscrow(this);
[L3674]                    havoc msgsender_MSG;
[L3675]                    havoc msgvalue_MSG;
[L3676]                    havoc choice;
[L3677]                    havoc __ret_0_primary;
[L3678]                    havoc recipient_s113;
[L3679]                    havoc payee_s148;
[L3680]                    havoc __ret_0_depositsOf;
[L3681]                    havoc refundee_s327;
[L3682]                    havoc payee_s255;
[L3683]                    havoc __arg_0_withdrawalAllowed;
[L3684]                    havoc __ret_0_withdrawalAllowed;
[L3685]                    havoc beneficiary_s294;
[L3686]                    havoc __ret_0_state;
[L3687]                    havoc __ret_0_beneficiary;
[L3688]                    havoc tmpNow;
[L3689]                    havoc gas;
[L3690]                    assume gas > 4000000 && gas <= 8000000;
[L3691]                    tmpNow := now;
[L3692]                    havoc now;
[L3693]                    assume now > tmpNow;
[L3694]                    assume msgsender_MSG != null;
[L3695]                    assume DType[msgsender_MSG] != SafeMath;
[L3696]                    assume DType[msgsender_MSG] != Secondary;
[L3697]                    assume DType[msgsender_MSG] != Escrow;
[L3698]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3699]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3700]                    Alloc[msgsender_MSG] := true;
[L3701]        COND FALSE  !(choice == 11)
[L3710]        COND FALSE  !(choice == 10)
[L3719]        COND FALSE  !(choice == 9)
[L3728]        COND FALSE  !(choice == 8)
[L3737]        COND TRUE   choice == 7
[L3739]                    gas := gas - 21000;
[L3740]        COND TRUE   gas >= 0
[L3742]                    assume msgvalue_MSG == 0;
[L3743]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3300]                    gas := gas - 2208;
[L3301]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3244]                    havoc __exception;
[L3245]        COND FALSE  !(__exception)
[L3270]        COND TRUE   Balance[from] >= amount
[L3272]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2832]                    assume Balance[from] >= amount;
[L2833]                    Balance[from] := Balance[from] - amount;
[L2834]                    Balance[to] := Balance[to] + amount;
[L2835]        COND FALSE  !(choice == 0)
[L2841]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3272]        RET         call FallbackDispatch__success(from, to, amount);
[L3273]                    success := true;
[L3280]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3743]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3820]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:28:21,616 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:28:21,616 INFO  L82        PathProgramCache]: Analyzing trace with hash -809516205, now seen corresponding path program 1 times
[2020-05-30 20:28:21,617 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:28:21,657 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:28:22,368 INFO  L134       CoverageAnalysis]: Checked inductivity of 558 backedges. 71 proven. 89 refuted. 0 times theorem prover too weak. 398 trivial. 0 not checked.
[2020-05-30 20:28:22,368 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:28:22,368 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:28:22,368 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:28:22,369 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:28:22,369 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=166, Invalid=2486, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:28:22,369 INFO  L87              Difference]: Start difference. First operand 9683 states and 10816 transitions. cyclomatic complexity: 1169 Second operand 52 states.
[2020-05-30 20:28:29,469 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:28:29,469 INFO  L93              Difference]: Finished difference Result 8038 states and 9030 transitions.
[2020-05-30 20:28:29,470 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 49 states. 
[2020-05-30 20:28:29,470 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8038 states and 9030 transitions.
[2020-05-30 20:28:29,485 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:28:29,485 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8038 states to 0 states and 0 transitions.
[2020-05-30 20:28:29,485 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:28:29,485 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:28:29,485 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:28:29,485 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:28:29,485 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:28:29,485 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:28:29,485 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:28:29,486 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 20:28:29,486 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:28:29,486 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:28:29,486 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:28:29,489 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:28:29 BasicIcfg
[2020-05-30 20:28:29,490 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:28:29,490 INFO  L168              Benchmark]: Toolchain (without parser) took 253885.42 ms. Allocated memory was 514.9 MB in the beginning and 5.1 GB in the end (delta: 4.5 GB). Free memory was 457.5 MB in the beginning and 3.0 GB in the end (delta: -2.5 GB). Peak memory consumption was 2.0 GB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,491 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.2 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,491 INFO  L168              Benchmark]: Boogie Preprocessor took 76.51 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,491 INFO  L168              Benchmark]: UtopiaSpecLang took 45.78 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,492 INFO  L168              Benchmark]: Boogie Printer took 12.98 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.6 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,492 INFO  L168              Benchmark]: RCFGBuilder took 534.38 ms. Allocated memory is still 514.9 MB. Free memory was 441.3 MB in the beginning and 470.1 MB in the end (delta: -28.8 MB). Peak memory consumption was 99.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,493 INFO  L168              Benchmark]: UtopiaLTL2Aut took 50.33 ms. Allocated memory is still 514.9 MB. Free memory was 470.1 MB in the beginning and 464.4 MB in the end (delta: 5.6 MB). Peak memory consumption was 5.6 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,493 INFO  L168              Benchmark]: Büchi Program Product took 5431.44 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 780.1 MB). Free memory was 464.4 MB in the beginning and 422.2 MB in the end (delta: 42.2 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,493 INFO  L168              Benchmark]: BlockEncodingV2 took 678.68 ms. Allocated memory was 1.3 GB in the beginning and 1.7 GB in the end (delta: 363.9 MB). Free memory was 422.2 MB in the beginning and 1.2 GB in the end (delta: -738.8 MB). Peak memory consumption was 346.2 MB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,494 INFO  L168              Benchmark]: BuchiAutomizer took 247052.56 ms. Allocated memory was 1.7 GB in the beginning and 5.1 GB in the end (delta: 3.4 GB). Free memory was 1.2 GB in the beginning and 3.0 GB in the end (delta: -1.8 GB). Peak memory consumption was 1.6 GB. Max. memory is 15.3 GB.
[2020-05-30 20:28:29,498 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    15383 locations, 64142 edges
  - StatisticsResult: Encoded RCFG
    15159 locations, 62812 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.2 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 76.51 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 45.78 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 12.98 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 442.6 MB in the end (delta: 1.3 MB). Peak memory consumption was 1.3 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 534.38 ms. Allocated memory is still 514.9 MB. Free memory was 441.3 MB in the beginning and 470.1 MB in the end (delta: -28.8 MB). Peak memory consumption was 99.0 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 50.33 ms. Allocated memory is still 514.9 MB. Free memory was 470.1 MB in the beginning and 464.4 MB in the end (delta: 5.6 MB). Peak memory consumption was 5.6 MB. Max. memory is 15.3 GB.
 * Büchi Program Product took 5431.44 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 780.1 MB). Free memory was 464.4 MB in the beginning and 422.2 MB in the end (delta: 42.2 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 678.68 ms. Allocated memory was 1.3 GB in the beginning and 1.7 GB in the end (delta: 363.9 MB). Free memory was 422.2 MB in the beginning and 1.2 GB in the end (delta: -738.8 MB). Peak memory consumption was 346.2 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 247052.56 ms. Allocated memory was 1.7 GB in the beginning and 5.1 GB in the end (delta: 3.4 GB). Free memory was 1.2 GB in the beginning and 3.0 GB in the end (delta: -1.8 GB). Peak memory consumption was 1.6 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1571 locations, 2188 edges
  - StatisticsResult: BuchiProgram size
    15383 locations, 64142 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 27 terminating modules (27 trivial, 0 deterministic, 0 nondeterministic). 27 modules have a trivial ranking function, the largest among these consists of 60 locations.
  - StatisticsResult: Timing statistics
    BüchiAutomizer plugin needed 247.0s and 28 iterations.  TraceHistogramMax:4. Analysis of lassos took 8.6s. Construction of modules took 187.2s. Büchi inclusion checks took 45.0s. Highest rank in rank-based complementation 0. Minimization of det autom 27. Minimization of nondet autom 0. Automata minimization 3.0s AutomataMinimizationTime, 26 MinimizatonAttempts, 12273 StatesRemovedByMinimization, 21 NontrivialMinimizations. Non-live state removal took 1.9s Buchi closure took 0.0s. Biggest automaton had 29072 states and ocurred in iteration 12.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 255817 SDtfs, 389853 SDslu, 574877 SDs, 0 SdLazy, 1860989 SolverSat, 85716 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 187.2s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU27 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_withdraw_(success_enableRefunds_RefundEscrow0)onditionalEscrow0) ) )&& ! ( ( []( (success_enableRefunds_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
