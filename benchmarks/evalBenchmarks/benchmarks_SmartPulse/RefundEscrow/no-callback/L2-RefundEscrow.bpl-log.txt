This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:35:56,726 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:35:56,727 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:35:56,738 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:35:56,738 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:35:56,739 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:35:56,740 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:35:56,742 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:35:56,744 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:35:56,745 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:35:56,746 INFO  L177        SettingsManager]: Büchi Program Product provides no preferences, ignoring...
[2020-05-30 20:35:56,746 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:35:56,747 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:35:56,748 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:35:56,749 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:35:56,750 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:35:56,751 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:35:56,752 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:35:56,753 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:35:56,755 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:35:56,756 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:35:56,757 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:35:56,759 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:35:56,759 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:35:56,759 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:35:56,760 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:35:56,761 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:35:56,762 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:35:56,762 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:35:56,762 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:35:56,762 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:35:56,763 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:35:56,764 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:35:56,765 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:35:56,766 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:35:56,767 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:35:56,767 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:35:56,768 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:35:56,768 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:35:56,769 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:35:56,770 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:35:56,771 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:35:56,771 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:35:56,781 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:35:56,781 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:35:56,782 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:35:56,782 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:35:56,783 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:35:56,783 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:35:56,783 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:35:56,784 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:35:56,784 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:35:56,784 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:35:56,785 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:35:56,785 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:35:56,805 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:35:56,816 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:35:56,818 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:35:56,819 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:35:56,819 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:35:56,820 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/no-callback/L2-RefundEscrow.bpl
[2020-05-30 20:35:56,820 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/no-callback/L2-RefundEscrow.bpl'
[2020-05-30 20:35:56,874 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:35:56,876 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:35:56,877 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:35:56,877 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:35:56,877 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:35:56,890 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,892 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,913 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,913 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,926 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,933 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,939 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,945 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:35:56,946 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:35:56,946 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:35:56,947 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:35:56,950 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/1) ...
[2020-05-30 20:35:56,962 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:35:56,967 INFO  L979   opiaSpecLangObserver]: Successfully lexed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:35:56,974 INFO  L981   opiaSpecLangObserver]: Successfully parsed: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:35:56,976 INFO  L677   opiaSpecLangObserver]: Parsed call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msg.sender, msg.value);  to CallStatement[false,[VariableLHS[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]],beneficiary_RefundEscrow__success,[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgsender_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>],IdentifierExpression[msgvalue_MSG,<IMPLEMENTATION_INPARAM,close_RefundEscrow>]]]
[2020-05-30 20:35:56,977 INFO  L658   opiaSpecLangObserver]: Parsed var __beneficiary_RefundEscrow0: int;  to VariableDeclaration[[VarList[BPL: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/no-callback/L2-RefundEscrow.bpl:7/0-7/4,[__beneficiary_RefundEscrow0],PrimitiveType[int],null]]]
[2020-05-30 20:35:56,977 INFO  L599   opiaSpecLangObserver]: Parsed ben==__beneficiary_RefundEscrow to BinaryExpression[COMPEQ,IdentifierExpression[ben,GLOBAL],IdentifierExpression[__beneficiary_RefundEscrow0,<LOCAL,close_RefundEscrow>]]
[2020-05-30 20:35:56,980 INFO  L599   opiaSpecLangObserver]: Parsed ( to==ben && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[ben,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:35:56,981 INFO  L968   opiaSpecLangObserver]: Compiling: [](finished(RefundEscrow.close, (ben == RefundEscrow.beneficiary())) ==> <>(finished(send(from, to, amt), (to == ben && amt == fsum(RefundEscrow.deposit, 2)))))
[2020-05-30 20:35:56,981 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_close_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:35:56,981 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:35:56,981 INFO  L979   opiaSpecLangObserver]: Successfully lexed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:35:56,981 INFO  L981   opiaSpecLangObserver]: Successfully parsed: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:35:56,982 INFO  L968   opiaSpecLangObserver]: Compiling: <>(finished(RefundEscrow.deposit)) && <>(finished(RefundEscrow.beneficiaryWithdraw))
[2020-05-30 20:35:56,982 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_beneficiaryWithdraw_RefundEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:35:56,989 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:35:56 PropertyContainer
[2020-05-30 20:35:56,989 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:35:56,989 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:35:56,989 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:35:56,989 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:35:56,990 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/2) ...
[2020-05-30 20:35:56,990 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:35:56,990 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:35:57,000 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:35:56" (2/2) ...
[2020-05-30 20:35:57,000 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:35:57,000 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:35:57,000 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:35:57,000 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:35:57,002 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/2) ...
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:35:57,044 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:35:57,044 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:35:57,045 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:35:57,045 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:35:57,045 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:35:57,045 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:35:57,045 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:35:57,046 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:35:57,046 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:35:57,046 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:35:57,046 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:35:57,046 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:35:57,047 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:35:57,048 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:35:57,049 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:35:57,050 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:35:57,051 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:35:57,052 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:35:57,053 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:35:57,053 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:35:57,054 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:35:57,055 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:35:57,056 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:35:57,057 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:35:57,058 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:35:57,059 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:35:57,060 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:35:57,060 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:35:57,061 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:35:57,177 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:35:57,191 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:35:57,347 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:35:57,465 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:35:57,465 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:35:57,466 INFO  L202        PluginConnector]: Adding new model L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:35:57 BoogieIcfgContainer
[2020-05-30 20:35:57,466 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:35:56" (2/2) ...
[2020-05-30 20:35:57,467 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:35:57,467 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@5dd462dd and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:35:57, skipping insertion in model container
[2020-05-30 20:35:57,467 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:35:57,467 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:35:57,467 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:35:57,468 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:35:57,469 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/3) ...
[2020-05-30 20:35:57,469 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@ff0213a and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:35:57, skipping insertion in model container
[2020-05-30 20:35:57,469 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:35:56" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:35:57,513 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:35:57 NWAContainer
[2020-05-30 20:35:57,513 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:35:57,513 INFO  L113        PluginConnector]: ------------------------Büchi Program Product----------------------------
[2020-05-30 20:35:57,513 INFO  L271        PluginConnector]: Initializing Büchi Program Product...
[2020-05-30 20:35:57,514 INFO  L276        PluginConnector]: Büchi Program Product initialized
[2020-05-30 20:35:57,514 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:35:57" (3/4) ...
[2020-05-30 20:35:57,515 INFO  L205        PluginConnector]: Invalid model from Büchi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@1f48dc70 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:35:57, skipping insertion in model container
[2020-05-30 20:35:57,515 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:35:57" (4/4) ...
[2020-05-30 20:35:57,519 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:35:57,522 INFO  L110   BuchiProductObserver]: Initial RCFG 1270 locations, 1641 edges
[2020-05-30 20:35:57,522 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:35:57,533 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:36:01,829 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:36:01,846 INFO  L110   BuchiProductObserver]: BuchiProgram size 12255 locations, 48203 edges
[2020-05-30 20:36:01,847 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:36:01 BoogieIcfgContainer
[2020-05-30 20:36:01,847 INFO  L132        PluginConnector]: ------------------------ END Büchi Program Product----------------------------
[2020-05-30 20:36:01,847 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:36:01,847 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:36:01,848 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:36:01,849 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:36:01" (1/1) ...
[2020-05-30 20:36:02,047 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,047 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,047 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,047 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,048 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,053 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,053 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,054 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,054 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,054 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,054 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,055 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,056 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,056 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,056 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,056 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,056 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,058 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,058 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,058 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,058 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,059 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,059 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,061 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,065 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,066 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,067 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,068 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,078 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:36:02,116 INFO  L313           BlockEncoder]: Initial Icfg 12255 locations, 48203 edges
[2020-05-30 20:36:02,116 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:36:02,117 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:36:02,117 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:36:02,117 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:36:02,149 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:36:02,169 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:36:02,208 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:36:02,221 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:36:02,234 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:36:02,234 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:36:02,246 INFO  L313           BlockEncoder]: Encoded RCFG 12031 locations, 46873 edges
[2020-05-30 20:36:02,247 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:36:02 BasicIcfg
[2020-05-30 20:36:02,247 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:36:02,247 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:36:02,247 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:36:02,249 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:36:02,250 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,250 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:35:56" (1/6) ...
[2020-05-30 20:36:02,251 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@109a9ff6 and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:36:02, skipping insertion in model container
[2020-05-30 20:36:02,251 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,251 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:35:56" (2/6) ...
[2020-05-30 20:36:02,251 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@109a9ff6 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:36:02, skipping insertion in model container
[2020-05-30 20:36:02,251 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,251 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:35:57" (3/6) ...
[2020-05-30 20:36:02,252 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@109a9ff6 and model type L2-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:36:02, skipping insertion in model container
[2020-05-30 20:36:02,252 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,252 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:35:57" (4/6) ...
[2020-05-30 20:36:02,252 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@109a9ff6 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:36:02, skipping insertion in model container
[2020-05-30 20:36:02,252 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,252 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:36:01" (5/6) ...
[2020-05-30 20:36:02,252 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@109a9ff6 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:36:02, skipping insertion in model container
[2020-05-30 20:36:02,252 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:36:02,253 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:36:02" (6/6) ...
[2020-05-30 20:36:02,253 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L2-RefundEscrow.bpl_BEv2
[2020-05-30 20:36:02,285 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:36:02,285 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:36:02,285 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:36:02,286 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:36:02,286 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:36:02,286 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:36:02,286 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:36:02,286 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:36:02,286 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:36:02,509 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12031 states.
[2020-05-30 20:36:02,639 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:02,639 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:02,639 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:02,649 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:02,649 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:02,649 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:36:02,649 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12031 states.
[2020-05-30 20:36:02,719 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:02,719 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:02,719 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:02,721 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:02,722 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND TRUE   choice == 11
[L3003]              gas := gas - 21000;
[L3004]  COND FALSE  !(gas >= 0)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:02,738 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:02,738 INFO  L82        PathProgramCache]: Analyzing trace with hash 1464624638, now seen corresponding path program 1 times
[2020-05-30 20:36:02,742 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:02,759 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:02,801 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:36:02,803 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:02,803 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:36:03,503 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:03,522 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:36:03,523 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:36:03,524 INFO  L87              Difference]: Start difference. First operand 12031 states. Second operand 3 states.
[2020-05-30 20:36:04,433 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:04,434 INFO  L93              Difference]: Finished difference Result 8003 states and 18820 transitions.
[2020-05-30 20:36:04,434 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:36:04,435 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8003 states and 18820 transitions.
[2020-05-30 20:36:04,493 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:04,574 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8003 states to 8003 states and 18820 transitions.
[2020-05-30 20:36:04,576 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:36:04,582 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 895
[2020-05-30 20:36:04,582 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8003 states and 18820 transitions.
[2020-05-30 20:36:04,611 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:04,611 INFO  L728         BuchiCegarLoop]: Abstraction has 8003 states and 18820 transitions.
[2020-05-30 20:36:04,636 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8003 states and 18820 transitions.
[2020-05-30 20:36:04,775 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8003 to 8003.
[2020-05-30 20:36:04,776 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8003 states.
[2020-05-30 20:36:04,800 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8003 states to 8003 states and 18820 transitions.
[2020-05-30 20:36:04,801 INFO  L751         BuchiCegarLoop]: Abstraction has 8003 states and 18820 transitions.
[2020-05-30 20:36:04,802 INFO  L631         BuchiCegarLoop]: Abstraction has 8003 states and 18820 transitions.
[2020-05-30 20:36:04,802 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:36:04,802 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8003 states and 18820 transitions.
[2020-05-30 20:36:04,821 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:04,821 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:04,821 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:04,823 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:04,823 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:04,828 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:04,828 INFO  L82        PathProgramCache]: Analyzing trace with hash 553736539, now seen corresponding path program 1 times
[2020-05-30 20:36:04,829 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:04,836 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:04,850 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:36:04,850 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:04,850 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:36:04,852 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:04,852 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:36:04,852 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:36:04,852 INFO  L87              Difference]: Start difference. First operand 8003 states and 18820 transitions. cyclomatic complexity: 10825 Second operand 3 states.
[2020-05-30 20:36:05,290 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:05,290 INFO  L93              Difference]: Finished difference Result 7589 states and 12323 transitions.
[2020-05-30 20:36:05,290 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:36:05,290 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7589 states and 12323 transitions.
[2020-05-30 20:36:05,316 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:05,357 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7589 states to 7589 states and 12323 transitions.
[2020-05-30 20:36:05,357 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 895
[2020-05-30 20:36:05,358 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 895
[2020-05-30 20:36:05,358 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7589 states and 12323 transitions.
[2020-05-30 20:36:05,369 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:05,369 INFO  L728         BuchiCegarLoop]: Abstraction has 7589 states and 12323 transitions.
[2020-05-30 20:36:05,378 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7589 states and 12323 transitions.
[2020-05-30 20:36:05,458 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7589 to 7589.
[2020-05-30 20:36:05,459 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7589 states.
[2020-05-30 20:36:05,473 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7589 states to 7589 states and 12323 transitions.
[2020-05-30 20:36:05,473 INFO  L751         BuchiCegarLoop]: Abstraction has 7589 states and 12323 transitions.
[2020-05-30 20:36:05,473 INFO  L631         BuchiCegarLoop]: Abstraction has 7589 states and 12323 transitions.
[2020-05-30 20:36:05,473 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:36:05,473 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7589 states and 12323 transitions.
[2020-05-30 20:36:05,492 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:05,492 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:05,492 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:05,494 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:05,495 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND TRUE   choice == 3
[L3075]              gas := gas - 21000;
[L3076]  COND TRUE   gas >= 0
[L3078]              assume msgvalue_MSG == 0;
[L3079]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3079]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:05,499 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:05,499 INFO  L82        PathProgramCache]: Analyzing trace with hash -690561660, now seen corresponding path program 1 times
[2020-05-30 20:36:05,500 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:05,507 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:05,528 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:36:05,529 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:05,529 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:36:05,529 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:05,529 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:36:05,529 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:36:05,529 INFO  L87              Difference]: Start difference. First operand 7589 states and 12323 transitions. cyclomatic complexity: 4742 Second operand 3 states.
[2020-05-30 20:36:05,811 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:05,811 INFO  L93              Difference]: Finished difference Result 7382 states and 8374 transitions.
[2020-05-30 20:36:05,811 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:36:05,812 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7382 states and 8374 transitions.
[2020-05-30 20:36:05,827 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:05,851 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7382 states to 7382 states and 8374 transitions.
[2020-05-30 20:36:05,851 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 895
[2020-05-30 20:36:05,851 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 895
[2020-05-30 20:36:05,851 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7382 states and 8374 transitions.
[2020-05-30 20:36:05,858 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:05,859 INFO  L728         BuchiCegarLoop]: Abstraction has 7382 states and 8374 transitions.
[2020-05-30 20:36:05,868 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7382 states and 8374 transitions.
[2020-05-30 20:36:05,927 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7382 to 7382.
[2020-05-30 20:36:05,927 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7382 states.
[2020-05-30 20:36:05,935 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7382 states to 7382 states and 8374 transitions.
[2020-05-30 20:36:05,935 INFO  L751         BuchiCegarLoop]: Abstraction has 7382 states and 8374 transitions.
[2020-05-30 20:36:05,935 INFO  L631         BuchiCegarLoop]: Abstraction has 7382 states and 8374 transitions.
[2020-05-30 20:36:05,935 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:36:05,935 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7382 states and 8374 transitions.
[2020-05-30 20:36:05,944 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:36:05,944 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:05,944 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:05,946 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:05,946 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND TRUE   choice == 3
[L3075]              gas := gas - 21000;
[L3076]  COND TRUE   gas >= 0
[L3078]              assume msgvalue_MSG == 0;
[L3079]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND TRUE   revert
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3079]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:05,949 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:05,949 INFO  L82        PathProgramCache]: Analyzing trace with hash -102367377, now seen corresponding path program 1 times
[2020-05-30 20:36:05,950 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:05,956 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:06,019 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:36:06,019 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:06,019 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:36:06,020 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:06,020 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:36:06,020 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:36:06,021 INFO  L87              Difference]: Start difference. First operand 7382 states and 8374 transitions. cyclomatic complexity: 1000 Second operand 3 states.
[2020-05-30 20:36:06,242 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:06,242 INFO  L93              Difference]: Finished difference Result 9232 states and 10595 transitions.
[2020-05-30 20:36:06,242 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:36:06,243 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9232 states and 10595 transitions.
[2020-05-30 20:36:06,279 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:06,325 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9232 states to 9232 states and 10595 transitions.
[2020-05-30 20:36:06,325 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1123
[2020-05-30 20:36:06,326 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1123
[2020-05-30 20:36:06,326 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9232 states and 10595 transitions.
[2020-05-30 20:36:06,337 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:06,338 INFO  L728         BuchiCegarLoop]: Abstraction has 9232 states and 10595 transitions.
[2020-05-30 20:36:06,352 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9232 states and 10595 transitions.
[2020-05-30 20:36:06,488 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9232 to 8513.
[2020-05-30 20:36:06,488 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8513 states.
[2020-05-30 20:36:06,497 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8513 states to 8513 states and 9701 transitions.
[2020-05-30 20:36:06,497 INFO  L751         BuchiCegarLoop]: Abstraction has 8513 states and 9701 transitions.
[2020-05-30 20:36:06,497 INFO  L631         BuchiCegarLoop]: Abstraction has 8513 states and 9701 transitions.
[2020-05-30 20:36:06,497 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:36:06,497 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8513 states and 9701 transitions.
[2020-05-30 20:36:06,508 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:06,508 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:06,508 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:06,510 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:06,510 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_close_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc ben;
[L3111]              assume null == 0;
[L3112]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3112]  RET         call this := FreshRefGenerator__success();
[L3113]              assume now >= 0;
[L3114]              assume DType[this] == RefundEscrow;
[L3115]              gas := gas - 53000;
[L3116]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND FALSE  !(revert)
[L2095]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L2095]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]  COND FALSE  !(revert)
[L2101]  CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1887]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]  COND FALSE  !(revert)
[L1893]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L1893]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]  COND FALSE  !(revert)
[L1899]  CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]              assume msgsender_MSG != null;
[L1857]              Balance[this] := 0;
[L1899]  RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]  COND FALSE  !(revert)
[L2101]  RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]  COND FALSE  !(revert)
[L2107]  CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]              assume msgsender_MSG != null;
[L2039]              Balance[this] := 0;
[L2040]              _beneficiary_RefundEscrow[this] := null;
[L2041]              __var_7 := null;
[L2042]  COND TRUE   !(beneficiary_s294 != null)
[L2044]              revert := true;
[L2107]  RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3116]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]              assume !revert && gas >= 0;
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND TRUE   !(_state_RefundEscrow[this] == 2)
[L2344]              revert := true;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND TRUE   choice == 3
[L3075]              gas := gas - 21000;
[L3076]  COND TRUE   gas >= 0
[L3078]              assume msgvalue_MSG == 0;
[L3079]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND FALSE  !(revert)
[L2243]              gas := gas - 317;
[L2244]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2246]              revert := true;
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume ben == __beneficiary_RefundEscrow0;
[L7]                 success_close_RefundEscrow0 := true;
[L7]                 success_close_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3079]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND TRUE   choice == 8
[L3030]              gas := gas - 21000;
[L3031]  COND TRUE   gas >= 0
[L3033]              assume msgvalue_MSG >= 0;
[L3034]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:06,516 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:06,516 INFO  L82        PathProgramCache]: Analyzing trace with hash 1360898400, now seen corresponding path program 1 times
[2020-05-30 20:36:06,517 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:06,527 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:06,595 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:06,595 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:06,595 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:36:06,596 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:06,596 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:36:06,596 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:36:06,596 INFO  L87              Difference]: Start difference. First operand 8513 states and 9701 transitions. cyclomatic complexity: 1196 Second operand 3 states.
[2020-05-30 20:36:06,723 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:06,723 INFO  L93              Difference]: Finished difference Result 9830 states and 11233 transitions.
[2020-05-30 20:36:06,723 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:36:06,723 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9830 states and 11233 transitions.
[2020-05-30 20:36:06,749 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-05-30 20:36:06,784 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9830 states to 9328 states and 10643 transitions.
[2020-05-30 20:36:06,785 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1147
[2020-05-30 20:36:06,785 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1147
[2020-05-30 20:36:06,785 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9328 states and 10643 transitions.
[2020-05-30 20:36:06,796 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:06,796 INFO  L728         BuchiCegarLoop]: Abstraction has 9328 states and 10643 transitions.
[2020-05-30 20:36:06,806 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9328 states and 10643 transitions.
[2020-05-30 20:36:06,889 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9328 to 8032.
[2020-05-30 20:36:06,889 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8032 states.
[2020-05-30 20:36:06,897 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8032 states to 8032 states and 8960 transitions.
[2020-05-30 20:36:06,897 INFO  L751         BuchiCegarLoop]: Abstraction has 8032 states and 8960 transitions.
[2020-05-30 20:36:06,898 INFO  L631         BuchiCegarLoop]: Abstraction has 8032 states and 8960 transitions.
[2020-05-30 20:36:06,898 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:36:06,898 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8032 states and 8960 transitions.
[2020-05-30 20:36:06,908 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:06,908 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:06,908 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:06,911 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:06,911 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND FALSE  !(Balance[from] >= amount)
[L2577]                    success := false;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND FALSE  !(Balance[from] >= amount)
[L2577]              success := false;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:06,915 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:06,916 INFO  L82        PathProgramCache]: Analyzing trace with hash -183107693, now seen corresponding path program 1 times
[2020-05-30 20:36:06,916 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:06,936 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:07,046 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:07,046 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:07,047 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:36:07,047 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:07,047 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:36:07,047 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:36:07,047 INFO  L87              Difference]: Start difference. First operand 8032 states and 8960 transitions. cyclomatic complexity: 936 Second operand 4 states.
[2020-05-30 20:36:07,126 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:07,126 INFO  L93              Difference]: Finished difference Result 8112 states and 9044 transitions.
[2020-05-30 20:36:07,126 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:36:07,126 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8112 states and 9044 transitions.
[2020-05-30 20:36:07,145 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:07,168 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8112 states to 8096 states and 9028 transitions.
[2020-05-30 20:36:07,168 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 992
[2020-05-30 20:36:07,169 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 992
[2020-05-30 20:36:07,169 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8096 states and 9028 transitions.
[2020-05-30 20:36:07,175 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:07,175 INFO  L728         BuchiCegarLoop]: Abstraction has 8096 states and 9028 transitions.
[2020-05-30 20:36:07,185 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8096 states and 9028 transitions.
[2020-05-30 20:36:07,242 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8096 to 8096.
[2020-05-30 20:36:07,243 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8096 states.
[2020-05-30 20:36:07,254 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8096 states to 8096 states and 9028 transitions.
[2020-05-30 20:36:07,254 INFO  L751         BuchiCegarLoop]: Abstraction has 8096 states and 9028 transitions.
[2020-05-30 20:36:07,254 INFO  L631         BuchiCegarLoop]: Abstraction has 8096 states and 9028 transitions.
[2020-05-30 20:36:07,254 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:36:07,254 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8096 states and 9028 transitions.
[2020-05-30 20:36:07,264 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:07,264 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:07,264 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:07,267 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:07,267 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND TRUE   Balance[from] >= amount
[L2572]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L2572]  RET         call FallbackDispatch__success(from, to, amount);
[L2573]              success := true;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:07,272 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:07,272 INFO  L82        PathProgramCache]: Analyzing trace with hash 252829264, now seen corresponding path program 1 times
[2020-05-30 20:36:07,272 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:07,289 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:07,414 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:07,414 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:07,414 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:36:07,414 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:07,415 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:36:07,415 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:36:07,415 INFO  L87              Difference]: Start difference. First operand 8096 states and 9028 transitions. cyclomatic complexity: 940 Second operand 10 states.
[2020-05-30 20:36:10,781 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:10,781 INFO  L93              Difference]: Finished difference Result 8196 states and 9209 transitions.
[2020-05-30 20:36:10,782 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 20:36:10,782 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8196 states and 9209 transitions.
[2020-05-30 20:36:10,801 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:10,826 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8196 states to 8196 states and 9209 transitions.
[2020-05-30 20:36:10,826 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1001
[2020-05-30 20:36:10,826 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1001
[2020-05-30 20:36:10,827 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8196 states and 9209 transitions.
[2020-05-30 20:36:10,835 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:10,835 INFO  L728         BuchiCegarLoop]: Abstraction has 8196 states and 9209 transitions.
[2020-05-30 20:36:10,845 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8196 states and 9209 transitions.
[2020-05-30 20:36:10,902 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8196 to 7938.
[2020-05-30 20:36:10,902 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7938 states.
[2020-05-30 20:36:10,911 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7938 states to 7938 states and 8816 transitions.
[2020-05-30 20:36:10,911 INFO  L751         BuchiCegarLoop]: Abstraction has 7938 states and 8816 transitions.
[2020-05-30 20:36:10,911 INFO  L631         BuchiCegarLoop]: Abstraction has 7938 states and 8816 transitions.
[2020-05-30 20:36:10,911 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:36:10,911 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7938 states and 8816 transitions.
[2020-05-30 20:36:10,920 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:10,920 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:10,920 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:10,922 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:10,922 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND TRUE   choice == 3
[L3075]              gas := gas - 21000;
[L3076]  COND TRUE   gas >= 0
[L3078]              assume msgvalue_MSG == 0;
[L3079]  CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]               havoc __exception;
[L676]               revert := false;
[L677]   COND FALSE  !(__exception)
[L696]   CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]              gas := gas - 2208;
[L2601]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]  COND FALSE  !(revert)
[L2243]              gas := gas - 317;
[L2244]  COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]              gas := gas - 20287;
[L2251]              _state_RefundEscrow[this] := 2;
[L2252]              assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]   RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L1]     CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]              gas := gas - 3;
[L2149]              gas := gas - 294;
[L2150]              __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]     RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                 assume !(ben == __beneficiary_RefundEscrow0);
[L7]                 revert := revert_hold;
[L3079]  RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:10,928 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:10,928 INFO  L82        PathProgramCache]: Analyzing trace with hash 1664498613, now seen corresponding path program 1 times
[2020-05-30 20:36:10,929 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:10,947 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:11,140 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:11,141 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:11,141 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [9] imperfect sequences [] total 9
[2020-05-30 20:36:11,141 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:11,142 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:36:11,142 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:36:11,142 INFO  L87              Difference]: Start difference. First operand 7938 states and 8816 transitions. cyclomatic complexity: 888 Second operand 10 states.
[2020-05-30 20:36:15,006 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:15,006 INFO  L93              Difference]: Finished difference Result 9304 states and 10636 transitions.
[2020-05-30 20:36:15,006 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:36:15,006 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9304 states and 10636 transitions.
[2020-05-30 20:36:15,029 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:36:15,058 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9304 states to 9248 states and 10572 transitions.
[2020-05-30 20:36:15,058 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1190
[2020-05-30 20:36:15,059 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1190
[2020-05-30 20:36:15,059 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9248 states and 10572 transitions.
[2020-05-30 20:36:15,065 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:15,066 INFO  L728         BuchiCegarLoop]: Abstraction has 9248 states and 10572 transitions.
[2020-05-30 20:36:15,075 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9248 states and 10572 transitions.
[2020-05-30 20:36:15,132 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9248 to 8688.
[2020-05-30 20:36:15,132 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8688 states.
[2020-05-30 20:36:15,141 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8688 states to 8688 states and 9747 transitions.
[2020-05-30 20:36:15,141 INFO  L751         BuchiCegarLoop]: Abstraction has 8688 states and 9747 transitions.
[2020-05-30 20:36:15,141 INFO  L631         BuchiCegarLoop]: Abstraction has 8688 states and 9747 transitions.
[2020-05-30 20:36:15,141 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:36:15,141 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8688 states and 9747 transitions.
[2020-05-30 20:36:15,150 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:15,150 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:15,150 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:15,151 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:15,151 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND FALSE  !(gas > 2300)
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND FALSE  !(gas > 2300)
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND TRUE   Balance[from] >= amount
[L2572]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L2572]  RET         call FallbackDispatch__success(from, to, amount);
[L2573]              success := true;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:15,156 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:15,156 INFO  L82        PathProgramCache]: Analyzing trace with hash -1545199489, now seen corresponding path program 1 times
[2020-05-30 20:36:15,157 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:15,176 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:15,280 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:15,280 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:15,280 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [8] imperfect sequences [] total 8
[2020-05-30 20:36:15,280 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:15,281 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 8 interpolants.
[2020-05-30 20:36:15,281 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=39, Unknown=0, NotChecked=0, Total=56
[2020-05-30 20:36:15,281 INFO  L87              Difference]: Start difference. First operand 8688 states and 9747 transitions. cyclomatic complexity: 1069 Second operand 8 states.
[2020-05-30 20:36:17,306 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:17,306 INFO  L93              Difference]: Finished difference Result 9692 states and 10819 transitions.
[2020-05-30 20:36:17,307 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 11 states. 
[2020-05-30 20:36:17,307 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9692 states and 10819 transitions.
[2020-05-30 20:36:17,328 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-05-30 20:36:17,356 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9692 states to 9524 states and 10635 transitions.
[2020-05-30 20:36:17,356 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1164
[2020-05-30 20:36:17,357 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1164
[2020-05-30 20:36:17,357 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9524 states and 10635 transitions.
[2020-05-30 20:36:17,363 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:17,363 INFO  L728         BuchiCegarLoop]: Abstraction has 9524 states and 10635 transitions.
[2020-05-30 20:36:17,370 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9524 states and 10635 transitions.
[2020-05-30 20:36:17,422 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9524 to 8688.
[2020-05-30 20:36:17,422 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8688 states.
[2020-05-30 20:36:17,431 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8688 states to 8688 states and 9555 transitions.
[2020-05-30 20:36:17,431 INFO  L751         BuchiCegarLoop]: Abstraction has 8688 states and 9555 transitions.
[2020-05-30 20:36:17,431 INFO  L631         BuchiCegarLoop]: Abstraction has 8688 states and 9555 transitions.
[2020-05-30 20:36:17,431 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:36:17,431 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8688 states and 9555 transitions.
[2020-05-30 20:36:17,440 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 4
[2020-05-30 20:36:17,440 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:17,440 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:17,441 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:17,441 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND TRUE   Balance[from] >= amount
[L2572]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND TRUE   DType[to] == RefundEscrow
[L2426]              assume amount == 0;
[L2572]  RET         call FallbackDispatch__success(from, to, amount);
[L2573]              success := true;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:17,445 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:17,445 INFO  L82        PathProgramCache]: Analyzing trace with hash 1350811365, now seen corresponding path program 1 times
[2020-05-30 20:36:17,445 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:17,462 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:17,795 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:17,795 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:17,795 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [34] imperfect sequences [] total 34
[2020-05-30 20:36:17,796 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:17,796 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 35 interpolants.
[2020-05-30 20:36:17,796 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=101, Invalid=1089, Unknown=0, NotChecked=0, Total=1190
[2020-05-30 20:36:17,796 INFO  L87              Difference]: Start difference. First operand 8688 states and 9555 transitions. cyclomatic complexity: 877 Second operand 35 states.
[2020-05-30 20:36:50,382 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:36:50,382 INFO  L93              Difference]: Finished difference Result 18734 states and 22310 transitions.
[2020-05-30 20:36:50,382 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 75 states. 
[2020-05-30 20:36:50,382 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 18734 states and 22310 transitions.
[2020-05-30 20:36:50,434 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 20
[2020-05-30 20:36:50,498 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 18734 states to 18734 states and 22310 transitions.
[2020-05-30 20:36:50,498 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2269
[2020-05-30 20:36:50,499 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2269
[2020-05-30 20:36:50,499 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 18734 states and 22310 transitions.
[2020-05-30 20:36:50,513 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:36:50,513 INFO  L728         BuchiCegarLoop]: Abstraction has 18734 states and 22310 transitions.
[2020-05-30 20:36:50,522 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 18734 states and 22310 transitions.
[2020-05-30 20:36:50,692 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 18734 to 18388.
[2020-05-30 20:36:50,692 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 18388 states.
[2020-05-30 20:36:50,719 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 18388 states to 18388 states and 21046 transitions.
[2020-05-30 20:36:50,719 INFO  L751         BuchiCegarLoop]: Abstraction has 18388 states and 21046 transitions.
[2020-05-30 20:36:50,719 INFO  L631         BuchiCegarLoop]: Abstraction has 18388 states and 21046 transitions.
[2020-05-30 20:36:50,719 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:36:50,719 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 18388 states and 21046 transitions.
[2020-05-30 20:36:50,738 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 20
[2020-05-30 20:36:50,738 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:36:50,738 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:36:50,740 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:36:50,740 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND TRUE   Balance[from] >= amount
[L2572]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]              assume Balance[from] >= amount;
[L2464]              Balance[from] := Balance[from] - amount;
[L2465]              Balance[to] := Balance[to] + amount;
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L2572]  RET         call FallbackDispatch__success(from, to, amount);
[L2573]              success := true;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:36:50,743 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:36:50,744 INFO  L82        PathProgramCache]: Analyzing trace with hash 859115096, now seen corresponding path program 1 times
[2020-05-30 20:36:50,744 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:36:50,764 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:36:51,044 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:36:51,044 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:36:51,044 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [31] imperfect sequences [] total 31
[2020-05-30 20:36:51,045 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:36:51,045 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 32 interpolants.
[2020-05-30 20:36:51,045 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=91, Invalid=901, Unknown=0, NotChecked=0, Total=992
[2020-05-30 20:36:51,045 INFO  L87              Difference]: Start difference. First operand 18388 states and 21046 transitions. cyclomatic complexity: 2696 Second operand 32 states.
[2020-05-30 20:37:06,642 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:06,642 INFO  L93              Difference]: Finished difference Result 23501 states and 27912 transitions.
[2020-05-30 20:37:06,642 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 62 states. 
[2020-05-30 20:37:06,642 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 23501 states and 27912 transitions.
[2020-05-30 20:37:06,705 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 32
[2020-05-30 20:37:06,784 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 23501 states to 23501 states and 27912 transitions.
[2020-05-30 20:37:06,784 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2268
[2020-05-30 20:37:06,785 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2268
[2020-05-30 20:37:06,785 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 23501 states and 27912 transitions.
[2020-05-30 20:37:06,803 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:06,804 INFO  L728         BuchiCegarLoop]: Abstraction has 23501 states and 27912 transitions.
[2020-05-30 20:37:06,814 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 23501 states and 27912 transitions.
[2020-05-30 20:37:06,985 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 23501 to 23259.
[2020-05-30 20:37:06,985 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 23259 states.
[2020-05-30 20:37:07,022 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 23259 states to 23259 states and 27070 transitions.
[2020-05-30 20:37:07,022 INFO  L751         BuchiCegarLoop]: Abstraction has 23259 states and 27070 transitions.
[2020-05-30 20:37:07,023 INFO  L631         BuchiCegarLoop]: Abstraction has 23259 states and 27070 transitions.
[2020-05-30 20:37:07,023 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:37:07,023 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 23259 states and 27070 transitions.
[2020-05-30 20:37:07,046 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 32
[2020-05-30 20:37:07,046 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:07,046 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:07,047 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:07,048 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:07,051 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:07,051 INFO  L82        PathProgramCache]: Analyzing trace with hash -761685144, now seen corresponding path program 1 times
[2020-05-30 20:37:07,052 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:07,064 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:07,149 INFO  L134       CoverageAnalysis]: Checked inductivity of 154 backedges. 33 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:37:07,149 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:37:07,149 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:37:07,150 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:07,150 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:37:07,150 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:37:07,151 INFO  L87              Difference]: Start difference. First operand 23259 states and 27070 transitions. cyclomatic complexity: 3885 Second operand 10 states.
[2020-05-30 20:37:11,074 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:11,075 INFO  L93              Difference]: Finished difference Result 24937 states and 28896 transitions.
[2020-05-30 20:37:11,075 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:37:11,075 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 24937 states and 28896 transitions.
[2020-05-30 20:37:11,133 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 24
[2020-05-30 20:37:11,176 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 24937 states to 15657 states and 17805 transitions.
[2020-05-30 20:37:11,176 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2170
[2020-05-30 20:37:11,177 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2170
[2020-05-30 20:37:11,177 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15657 states and 17805 transitions.
[2020-05-30 20:37:11,187 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:11,187 INFO  L728         BuchiCegarLoop]: Abstraction has 15657 states and 17805 transitions.
[2020-05-30 20:37:11,194 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15657 states and 17805 transitions.
[2020-05-30 20:37:11,282 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15657 to 13460.
[2020-05-30 20:37:11,283 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13460 states.
[2020-05-30 20:37:11,298 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13460 states to 13460 states and 15310 transitions.
[2020-05-30 20:37:11,298 INFO  L751         BuchiCegarLoop]: Abstraction has 13460 states and 15310 transitions.
[2020-05-30 20:37:11,298 INFO  L631         BuchiCegarLoop]: Abstraction has 13460 states and 15310 transitions.
[2020-05-30 20:37:11,298 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:37:11,298 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13460 states and 15310 transitions.
[2020-05-30 20:37:11,312 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 24
[2020-05-30 20:37:11,312 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:11,312 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:11,313 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:11,313 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:11,317 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:11,317 INFO  L82        PathProgramCache]: Analyzing trace with hash 153361137, now seen corresponding path program 1 times
[2020-05-30 20:37:11,318 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:11,330 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:11,413 INFO  L134       CoverageAnalysis]: Checked inductivity of 159 backedges. 42 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:37:11,413 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:37:11,413 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:37:11,413 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:11,413 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:37:11,414 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=17, Invalid=73, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:37:11,414 INFO  L87              Difference]: Start difference. First operand 13460 states and 15310 transitions. cyclomatic complexity: 1890 Second operand 10 states.
[2020-05-30 20:37:14,916 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:14,916 INFO  L93              Difference]: Finished difference Result 13408 states and 15166 transitions.
[2020-05-30 20:37:14,916 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:37:14,916 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13408 states and 15166 transitions.
[2020-05-30 20:37:14,952 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 24
[2020-05-30 20:37:14,987 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13408 states to 13408 states and 15166 transitions.
[2020-05-30 20:37:14,987 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2150
[2020-05-30 20:37:14,988 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2150
[2020-05-30 20:37:14,988 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13408 states and 15166 transitions.
[2020-05-30 20:37:14,997 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:14,997 INFO  L728         BuchiCegarLoop]: Abstraction has 13408 states and 15166 transitions.
[2020-05-30 20:37:15,003 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13408 states and 15166 transitions.
[2020-05-30 20:37:15,083 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13408 to 13401.
[2020-05-30 20:37:15,083 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13401 states.
[2020-05-30 20:37:15,101 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13401 states to 13401 states and 15144 transitions.
[2020-05-30 20:37:15,101 INFO  L751         BuchiCegarLoop]: Abstraction has 13401 states and 15144 transitions.
[2020-05-30 20:37:15,101 INFO  L631         BuchiCegarLoop]: Abstraction has 13401 states and 15144 transitions.
[2020-05-30 20:37:15,101 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:37:15,101 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13401 states and 15144 transitions.
[2020-05-30 20:37:15,116 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 24
[2020-05-30 20:37:15,117 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:15,117 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:15,118 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:15,118 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume !(ben == __beneficiary_RefundEscrow0);
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:15,122 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:15,122 INFO  L82        PathProgramCache]: Analyzing trace with hash -1654244099, now seen corresponding path program 1 times
[2020-05-30 20:37:15,123 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:15,138 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:15,271 INFO  L134       CoverageAnalysis]: Checked inductivity of 203 backedges. 4 proven. 2 refuted. 0 times theorem prover too weak. 197 trivial. 0 not checked.
[2020-05-30 20:37:15,271 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:37:15,271 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:37:15,272 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:15,272 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:37:15,272 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=19, Invalid=91, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:37:15,272 INFO  L87              Difference]: Start difference. First operand 13401 states and 15144 transitions. cyclomatic complexity: 1783 Second operand 11 states.
[2020-05-30 20:37:15,516 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:15,516 INFO  L93              Difference]: Finished difference Result 15700 states and 18041 transitions.
[2020-05-30 20:37:15,516 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:37:15,516 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15700 states and 18041 transitions.
[2020-05-30 20:37:15,549 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 40
[2020-05-30 20:37:15,586 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15700 states to 14548 states and 16466 transitions.
[2020-05-30 20:37:15,586 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2680
[2020-05-30 20:37:15,587 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2680
[2020-05-30 20:37:15,587 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14548 states and 16466 transitions.
[2020-05-30 20:37:15,596 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:15,597 INFO  L728         BuchiCegarLoop]: Abstraction has 14548 states and 16466 transitions.
[2020-05-30 20:37:15,603 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14548 states and 16466 transitions.
[2020-05-30 20:37:15,689 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14548 to 14409.
[2020-05-30 20:37:15,689 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 14409 states.
[2020-05-30 20:37:15,710 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 14409 states to 14409 states and 16280 transitions.
[2020-05-30 20:37:15,710 INFO  L751         BuchiCegarLoop]: Abstraction has 14409 states and 16280 transitions.
[2020-05-30 20:37:15,710 INFO  L631         BuchiCegarLoop]: Abstraction has 14409 states and 16280 transitions.
[2020-05-30 20:37:15,711 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:37:15,711 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 14409 states and 16280 transitions.
[2020-05-30 20:37:15,727 INFO  L131   ngComponentsAnalysis]: Automaton has 9 accepting balls. 40
[2020-05-30 20:37:15,728 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:15,728 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:15,729 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:15,729 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == ben && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:15,734 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:15,735 INFO  L82        PathProgramCache]: Analyzing trace with hash -1803837344, now seen corresponding path program 1 times
[2020-05-30 20:37:15,735 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:15,753 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:15,895 INFO  L134       CoverageAnalysis]: Checked inductivity of 285 backedges. 79 proven. 39 refuted. 0 times theorem prover too weak. 167 trivial. 0 not checked.
[2020-05-30 20:37:15,895 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:37:15,895 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:37:15,895 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:15,895 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:37:15,895 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:37:15,896 INFO  L87              Difference]: Start difference. First operand 14409 states and 16280 transitions. cyclomatic complexity: 1918 Second operand 11 states.
[2020-05-30 20:37:17,662 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:17,662 INFO  L93              Difference]: Finished difference Result 12615 states and 14013 transitions.
[2020-05-30 20:37:17,662 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:37:17,662 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12615 states and 14013 transitions.
[2020-05-30 20:37:17,688 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 8
[2020-05-30 20:37:17,712 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12615 states to 11976 states and 13174 transitions.
[2020-05-30 20:37:17,712 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1756
[2020-05-30 20:37:17,713 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1762
[2020-05-30 20:37:17,713 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11976 states and 13174 transitions.
[2020-05-30 20:37:17,719 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:17,719 INFO  L728         BuchiCegarLoop]: Abstraction has 11976 states and 13174 transitions.
[2020-05-30 20:37:17,724 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11976 states and 13174 transitions.
[2020-05-30 20:37:17,778 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11976 to 10128.
[2020-05-30 20:37:17,779 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10128 states.
[2020-05-30 20:37:17,790 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10128 states to 10128 states and 11159 transitions.
[2020-05-30 20:37:17,790 INFO  L751         BuchiCegarLoop]: Abstraction has 10128 states and 11159 transitions.
[2020-05-30 20:37:17,790 INFO  L631         BuchiCegarLoop]: Abstraction has 10128 states and 11159 transitions.
[2020-05-30 20:37:17,790 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:37:17,790 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10128 states and 11159 transitions.
[2020-05-30 20:37:17,800 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:37:17,800 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:17,800 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:17,801 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:17,801 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:17,804 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:17,805 INFO  L82        PathProgramCache]: Analyzing trace with hash -1842956810, now seen corresponding path program 1 times
[2020-05-30 20:37:17,805 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:17,823 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:18,190 INFO  L134       CoverageAnalysis]: Checked inductivity of 163 backedges. 0 proven. 44 refuted. 0 times theorem prover too weak. 119 trivial. 0 not checked.
[2020-05-30 20:37:18,190 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:37:18,190 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [37] total 37
[2020-05-30 20:37:18,191 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:18,191 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 38 interpolants.
[2020-05-30 20:37:18,192 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=105, Invalid=1301, Unknown=0, NotChecked=0, Total=1406
[2020-05-30 20:37:18,192 INFO  L87              Difference]: Start difference. First operand 10128 states and 11159 transitions. cyclomatic complexity: 1058 Second operand 38 states.
[2020-05-30 20:37:42,649 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:37:42,650 INFO  L93              Difference]: Finished difference Result 16663 states and 18924 transitions.
[2020-05-30 20:37:42,650 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 20:37:42,650 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16663 states and 18924 transitions.
[2020-05-30 20:37:42,689 INFO  L131   ngComponentsAnalysis]: Automaton has 13 accepting balls. 28
[2020-05-30 20:37:42,733 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16663 states to 16663 states and 18924 transitions.
[2020-05-30 20:37:42,733 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1922
[2020-05-30 20:37:42,734 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1922
[2020-05-30 20:37:42,734 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 16663 states and 18924 transitions.
[2020-05-30 20:37:42,744 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:37:42,745 INFO  L728         BuchiCegarLoop]: Abstraction has 16663 states and 18924 transitions.
[2020-05-30 20:37:42,751 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 16663 states and 18924 transitions.
[2020-05-30 20:37:42,852 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 16663 to 16422.
[2020-05-30 20:37:42,852 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 16422 states.
[2020-05-30 20:37:42,873 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 16422 states to 16422 states and 18363 transitions.
[2020-05-30 20:37:42,873 INFO  L751         BuchiCegarLoop]: Abstraction has 16422 states and 18363 transitions.
[2020-05-30 20:37:42,874 INFO  L631         BuchiCegarLoop]: Abstraction has 16422 states and 18363 transitions.
[2020-05-30 20:37:42,874 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:37:42,874 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 16422 states and 18363 transitions.
[2020-05-30 20:37:42,892 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:37:42,892 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:37:42,892 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:37:42,893 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:37:42,893 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND TRUE   choice == 10
[L3012]                    gas := gas - 21000;
[L3013]        COND TRUE   gas >= 0
[L3015]                    assume msgvalue_MSG == 0;
[L3016]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3016]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:37:42,898 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:37:42,898 INFO  L82        PathProgramCache]: Analyzing trace with hash 1507037912, now seen corresponding path program 1 times
[2020-05-30 20:37:42,898 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:37:42,915 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:37:43,198 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 4 proven. 32 refuted. 0 times theorem prover too weak. 119 trivial. 0 not checked.
[2020-05-30 20:37:43,199 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:37:43,199 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-05-30 20:37:43,199 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:37:43,199 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-05-30 20:37:43,200 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=119, Invalid=1363, Unknown=0, NotChecked=0, Total=1482
[2020-05-30 20:37:43,200 INFO  L87              Difference]: Start difference. First operand 16422 states and 18363 transitions. cyclomatic complexity: 1993 Second operand 39 states.
[2020-05-30 20:38:08,547 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:08,548 INFO  L93              Difference]: Finished difference Result 24679 states and 28436 transitions.
[2020-05-30 20:38:08,548 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 77 states. 
[2020-05-30 20:38:08,548 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 24679 states and 28436 transitions.
[2020-05-30 20:38:08,684 INFO  L131   ngComponentsAnalysis]: Automaton has 22 accepting balls. 44
[2020-05-30 20:38:08,750 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 24679 states to 24679 states and 28436 transitions.
[2020-05-30 20:38:08,750 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3824
[2020-05-30 20:38:08,751 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3824
[2020-05-30 20:38:08,751 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 24679 states and 28436 transitions.
[2020-05-30 20:38:08,768 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:08,768 INFO  L728         BuchiCegarLoop]: Abstraction has 24679 states and 28436 transitions.
[2020-05-30 20:38:08,778 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 24679 states and 28436 transitions.
[2020-05-30 20:38:08,954 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 24679 to 24035.
[2020-05-30 20:38:08,954 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 24035 states.
[2020-05-30 20:38:08,985 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 24035 states to 24035 states and 26806 transitions.
[2020-05-30 20:38:08,985 INFO  L751         BuchiCegarLoop]: Abstraction has 24035 states and 26806 transitions.
[2020-05-30 20:38:08,985 INFO  L631         BuchiCegarLoop]: Abstraction has 24035 states and 26806 transitions.
[2020-05-30 20:38:08,985 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:38:08,985 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 24035 states and 26806 transitions.
[2020-05-30 20:38:09,013 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 20:38:09,013 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:09,013 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:09,015 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:09,015 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:09,021 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:09,021 INFO  L82        PathProgramCache]: Analyzing trace with hash 1615970475, now seen corresponding path program 1 times
[2020-05-30 20:38:09,022 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:09,037 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:09,134 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 4 proven. 0 refuted. 0 times theorem prover too weak. 167 trivial. 0 not checked.
[2020-05-30 20:38:09,134 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:38:09,134 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [6] imperfect sequences [] total 6
[2020-05-30 20:38:09,134 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:09,135 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:38:09,135 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:38:09,135 INFO  L87              Difference]: Start difference. First operand 24035 states and 26806 transitions. cyclomatic complexity: 2844 Second operand 6 states.
[2020-05-30 20:38:09,306 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:09,306 INFO  L93              Difference]: Finished difference Result 24557 states and 27314 transitions.
[2020-05-30 20:38:09,306 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:38:09,306 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 24557 states and 27314 transitions.
[2020-05-30 20:38:09,351 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 20:38:09,409 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 24557 states to 23827 states and 26496 transitions.
[2020-05-30 20:38:09,409 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3726
[2020-05-30 20:38:09,410 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3726
[2020-05-30 20:38:09,411 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 23827 states and 26496 transitions.
[2020-05-30 20:38:09,424 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:09,425 INFO  L728         BuchiCegarLoop]: Abstraction has 23827 states and 26496 transitions.
[2020-05-30 20:38:09,434 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 23827 states and 26496 transitions.
[2020-05-30 20:38:09,575 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 23827 to 23827.
[2020-05-30 20:38:09,575 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 23827 states.
[2020-05-30 20:38:09,605 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 23827 states to 23827 states and 26496 transitions.
[2020-05-30 20:38:09,605 INFO  L751         BuchiCegarLoop]: Abstraction has 23827 states and 26496 transitions.
[2020-05-30 20:38:09,605 INFO  L631         BuchiCegarLoop]: Abstraction has 23827 states and 26496 transitions.
[2020-05-30 20:38:09,606 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:38:09,606 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 23827 states and 26496 transitions.
[2020-05-30 20:38:09,632 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 20:38:09,633 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:09,633 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:09,634 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:09,634 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:09,638 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:09,639 INFO  L82        PathProgramCache]: Analyzing trace with hash 505571984, now seen corresponding path program 1 times
[2020-05-30 20:38:09,639 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:09,652 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:09,759 INFO  L134       CoverageAnalysis]: Checked inductivity of 171 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 134 trivial. 0 not checked.
[2020-05-30 20:38:09,759 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:09,759 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-30 20:38:09,760 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:09,760 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:38:09,760 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=22, Invalid=110, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:38:09,761 INFO  L87              Difference]: Start difference. First operand 23827 states and 26496 transitions. cyclomatic complexity: 2742 Second operand 12 states.
[2020-05-30 20:38:12,447 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:12,448 INFO  L93              Difference]: Finished difference Result 23929 states and 26625 transitions.
[2020-05-30 20:38:12,448 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 14 states. 
[2020-05-30 20:38:12,448 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 23929 states and 26625 transitions.
[2020-05-30 20:38:12,499 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 20:38:12,559 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 23929 states to 23213 states and 25839 transitions.
[2020-05-30 20:38:12,559 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 3366
[2020-05-30 20:38:12,561 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 3366
[2020-05-30 20:38:12,561 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 23213 states and 25839 transitions.
[2020-05-30 20:38:12,574 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:12,574 INFO  L728         BuchiCegarLoop]: Abstraction has 23213 states and 25839 transitions.
[2020-05-30 20:38:12,584 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 23213 states and 25839 transitions.
[2020-05-30 20:38:12,720 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 23213 to 19785.
[2020-05-30 20:38:12,720 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19785 states.
[2020-05-30 20:38:12,746 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19785 states to 19785 states and 22062 transitions.
[2020-05-30 20:38:12,746 INFO  L751         BuchiCegarLoop]: Abstraction has 19785 states and 22062 transitions.
[2020-05-30 20:38:12,746 INFO  L631         BuchiCegarLoop]: Abstraction has 19785 states and 22062 transitions.
[2020-05-30 20:38:12,747 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:38:12,747 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19785 states and 22062 transitions.
[2020-05-30 20:38:12,798 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:38:12,798 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:12,798 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:12,799 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:12,799 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND TRUE   choice == 10
[L3012]                    gas := gas - 21000;
[L3013]        COND TRUE   gas >= 0
[L3015]                    assume msgvalue_MSG == 0;
[L3016]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3016]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:12,807 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:12,807 INFO  L82        PathProgramCache]: Analyzing trace with hash 1265849477, now seen corresponding path program 1 times
[2020-05-30 20:38:12,808 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:12,827 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:13,061 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 4 proven. 32 refuted. 0 times theorem prover too weak. 119 trivial. 0 not checked.
[2020-05-30 20:38:13,061 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:13,061 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-30 20:38:13,062 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:13,062 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-30 20:38:13,062 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=108, Invalid=1152, Unknown=0, NotChecked=0, Total=1260
[2020-05-30 20:38:13,062 INFO  L87              Difference]: Start difference. First operand 19785 states and 22062 transitions. cyclomatic complexity: 2338 Second operand 36 states.
[2020-05-30 20:38:28,592 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:28,592 INFO  L93              Difference]: Finished difference Result 20850 states and 24003 transitions.
[2020-05-30 20:38:28,593 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 69 states. 
[2020-05-30 20:38:28,593 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20850 states and 24003 transitions.
[2020-05-30 20:38:28,641 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 20
[2020-05-30 20:38:28,701 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20850 states to 20582 states and 23685 transitions.
[2020-05-30 20:38:28,701 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:38:28,702 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:38:28,702 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20582 states and 23685 transitions.
[2020-05-30 20:38:28,716 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:28,716 INFO  L728         BuchiCegarLoop]: Abstraction has 20582 states and 23685 transitions.
[2020-05-30 20:38:28,725 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20582 states and 23685 transitions.
[2020-05-30 20:38:28,866 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20582 to 19783.
[2020-05-30 20:38:28,866 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19783 states.
[2020-05-30 20:38:28,893 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19783 states to 19783 states and 22068 transitions.
[2020-05-30 20:38:28,893 INFO  L751         BuchiCegarLoop]: Abstraction has 19783 states and 22068 transitions.
[2020-05-30 20:38:28,893 INFO  L631         BuchiCegarLoop]: Abstraction has 19783 states and 22068 transitions.
[2020-05-30 20:38:28,893 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:38:28,893 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19783 states and 22068 transitions.
[2020-05-30 20:38:28,914 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:38:28,914 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:28,915 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:28,916 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:28,916 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:28,920 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:28,920 INFO  L82        PathProgramCache]: Analyzing trace with hash -508710233, now seen corresponding path program 1 times
[2020-05-30 20:38:28,920 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:28,943 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:29,248 INFO  L134       CoverageAnalysis]: Checked inductivity of 163 backedges. 3 proven. 41 refuted. 0 times theorem prover too weak. 119 trivial. 0 not checked.
[2020-05-30 20:38:29,248 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:29,248 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-05-30 20:38:29,248 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:29,248 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-05-30 20:38:29,249 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=102, Invalid=1158, Unknown=0, NotChecked=0, Total=1260
[2020-05-30 20:38:29,249 INFO  L87              Difference]: Start difference. First operand 19783 states and 22068 transitions. cyclomatic complexity: 2348 Second operand 36 states.
[2020-05-30 20:38:45,425 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:45,425 INFO  L93              Difference]: Finished difference Result 20752 states and 23363 transitions.
[2020-05-30 20:38:45,425 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 61 states. 
[2020-05-30 20:38:45,425 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20752 states and 23363 transitions.
[2020-05-30 20:38:45,470 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:38:45,524 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20752 states to 20494 states and 23045 transitions.
[2020-05-30 20:38:45,524 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1716
[2020-05-30 20:38:45,525 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1716
[2020-05-30 20:38:45,525 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 20494 states and 23045 transitions.
[2020-05-30 20:38:45,535 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:45,535 INFO  L728         BuchiCegarLoop]: Abstraction has 20494 states and 23045 transitions.
[2020-05-30 20:38:45,543 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 20494 states and 23045 transitions.
[2020-05-30 20:38:45,665 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 20494 to 19836.
[2020-05-30 20:38:45,665 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 19836 states.
[2020-05-30 20:38:45,691 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 19836 states to 19836 states and 22133 transitions.
[2020-05-30 20:38:45,692 INFO  L751         BuchiCegarLoop]: Abstraction has 19836 states and 22133 transitions.
[2020-05-30 20:38:45,692 INFO  L631         BuchiCegarLoop]: Abstraction has 19836 states and 22133 transitions.
[2020-05-30 20:38:45,692 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:38:45,692 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 19836 states and 22133 transitions.
[2020-05-30 20:38:45,713 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 10
[2020-05-30 20:38:45,713 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:45,713 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:45,714 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:45,714 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:45,717 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:45,717 INFO  L82        PathProgramCache]: Analyzing trace with hash 670454131, now seen corresponding path program 1 times
[2020-05-30 20:38:45,718 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:45,726 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:45,781 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:38:45,782 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:38:45,782 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:38:45,782 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:45,782 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:38:45,782 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:38:45,782 INFO  L87              Difference]: Start difference. First operand 19836 states and 22133 transitions. cyclomatic complexity: 2362 Second operand 4 states.
[2020-05-30 20:38:46,302 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:46,302 INFO  L93              Difference]: Finished difference Result 10744 states and 12370 transitions.
[2020-05-30 20:38:46,302 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:38:46,303 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10744 states and 12370 transitions.
[2020-05-30 20:38:46,326 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 12
[2020-05-30 20:38:46,348 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10744 states to 10263 states and 11843 transitions.
[2020-05-30 20:38:46,348 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1962
[2020-05-30 20:38:46,348 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1962
[2020-05-30 20:38:46,348 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10263 states and 11843 transitions.
[2020-05-30 20:38:46,354 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:46,354 INFO  L728         BuchiCegarLoop]: Abstraction has 10263 states and 11843 transitions.
[2020-05-30 20:38:46,357 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10263 states and 11843 transitions.
[2020-05-30 20:38:46,404 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10263 to 7050.
[2020-05-30 20:38:46,404 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 7050 states.
[2020-05-30 20:38:46,410 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 7050 states to 7050 states and 7681 transitions.
[2020-05-30 20:38:46,410 INFO  L751         BuchiCegarLoop]: Abstraction has 7050 states and 7681 transitions.
[2020-05-30 20:38:46,410 INFO  L631         BuchiCegarLoop]: Abstraction has 7050 states and 7681 transitions.
[2020-05-30 20:38:46,410 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:38:46,410 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 7050 states and 7681 transitions.
[2020-05-30 20:38:46,416 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:38:46,416 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:46,416 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:46,417 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:46,417 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:46,421 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:46,421 INFO  L82        PathProgramCache]: Analyzing trace with hash -1744158703, now seen corresponding path program 1 times
[2020-05-30 20:38:46,421 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:46,434 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:46,533 INFO  L134       CoverageAnalysis]: Checked inductivity of 158 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:38:46,533 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:46,534 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-30 20:38:46,534 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:46,534 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:38:46,534 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=23, Invalid=109, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:38:46,535 INFO  L87              Difference]: Start difference. First operand 7050 states and 7681 transitions. cyclomatic complexity: 651 Second operand 12 states.
[2020-05-30 20:38:48,708 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:48,708 INFO  L93              Difference]: Finished difference Result 6930 states and 7503 transitions.
[2020-05-30 20:38:48,708 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:38:48,708 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6930 states and 7503 transitions.
[2020-05-30 20:38:48,717 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:38:48,725 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6930 states to 6739 states and 7296 transitions.
[2020-05-30 20:38:48,725 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1512
[2020-05-30 20:38:48,725 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1512
[2020-05-30 20:38:48,725 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6739 states and 7296 transitions.
[2020-05-30 20:38:48,728 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:48,728 INFO  L728         BuchiCegarLoop]: Abstraction has 6739 states and 7296 transitions.
[2020-05-30 20:38:48,730 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6739 states and 7296 transitions.
[2020-05-30 20:38:48,755 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6739 to 6729.
[2020-05-30 20:38:48,755 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6729 states.
[2020-05-30 20:38:48,760 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6729 states to 6729 states and 7284 transitions.
[2020-05-30 20:38:48,760 INFO  L751         BuchiCegarLoop]: Abstraction has 6729 states and 7284 transitions.
[2020-05-30 20:38:48,761 INFO  L631         BuchiCegarLoop]: Abstraction has 6729 states and 7284 transitions.
[2020-05-30 20:38:48,761 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:38:48,761 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6729 states and 7284 transitions.
[2020-05-30 20:38:48,766 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:38:48,766 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:48,766 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:48,768 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:48,768 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND TRUE   choice == 2
[L3084]                    gas := gas - 21000;
[L3085]        COND TRUE   gas >= 0
[L3087]                    assume msgvalue_MSG == 0;
[L3088]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L3088]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:48,771 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:48,771 INFO  L82        PathProgramCache]: Analyzing trace with hash -349641339, now seen corresponding path program 1 times
[2020-05-30 20:38:48,772 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:48,788 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:48,911 INFO  L134       CoverageAnalysis]: Checked inductivity of 244 backedges. 78 proven. 2 refuted. 0 times theorem prover too weak. 164 trivial. 0 not checked.
[2020-05-30 20:38:48,911 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:48,911 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:38:48,912 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:48,912 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:38:48,912 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:38:48,912 INFO  L87              Difference]: Start difference. First operand 6729 states and 7284 transitions. cyclomatic complexity: 573 Second operand 11 states.
[2020-05-30 20:38:50,062 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:38:50,063 INFO  L93              Difference]: Finished difference Result 5184 states and 5617 transitions.
[2020-05-30 20:38:50,063 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:38:50,063 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 5184 states and 5617 transitions.
[2020-05-30 20:38:50,071 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:38:50,076 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 5184 states to 4029 states and 4331 transitions.
[2020-05-30 20:38:50,076 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 742
[2020-05-30 20:38:50,076 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 742
[2020-05-30 20:38:50,076 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 4029 states and 4331 transitions.
[2020-05-30 20:38:50,077 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:38:50,078 INFO  L728         BuchiCegarLoop]: Abstraction has 4029 states and 4331 transitions.
[2020-05-30 20:38:50,080 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 4029 states and 4331 transitions.
[2020-05-30 20:38:50,091 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 4029 to 4029.
[2020-05-30 20:38:50,091 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 4029 states.
[2020-05-30 20:38:50,094 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 4029 states to 4029 states and 4331 transitions.
[2020-05-30 20:38:50,094 INFO  L751         BuchiCegarLoop]: Abstraction has 4029 states and 4331 transitions.
[2020-05-30 20:38:50,094 INFO  L631         BuchiCegarLoop]: Abstraction has 4029 states and 4331 transitions.
[2020-05-30 20:38:50,094 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:38:50,094 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 4029 states and 4331 transitions.
[2020-05-30 20:38:50,097 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:38:50,098 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:38:50,098 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:38:50,099 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:38:50,099 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND TRUE   choice == 10
[L3012]                    gas := gas - 21000;
[L3013]        COND TRUE   gas >= 0
[L3015]                    assume msgvalue_MSG == 0;
[L3016]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3016]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:38:50,102 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:38:50,102 INFO  L82        PathProgramCache]: Analyzing trace with hash 2001865315, now seen corresponding path program 1 times
[2020-05-30 20:38:50,102 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:38:50,122 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:38:50,692 INFO  L134       CoverageAnalysis]: Checked inductivity of 239 backedges. 43 proven. 44 refuted. 0 times theorem prover too weak. 152 trivial. 0 not checked.
[2020-05-30 20:38:50,692 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:38:50,692 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [63] total 63
[2020-05-30 20:38:50,692 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:38:50,692 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 64 interpolants.
[2020-05-30 20:38:50,693 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=215, Invalid=3817, Unknown=0, NotChecked=0, Total=4032
[2020-05-30 20:38:50,693 INFO  L87              Difference]: Start difference. First operand 4029 states and 4331 transitions. cyclomatic complexity: 311 Second operand 64 states.
[2020-05-30 20:39:04,882 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:04,882 INFO  L93              Difference]: Finished difference Result 4160 states and 4512 transitions.
[2020-05-30 20:39:04,883 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 88 states. 
[2020-05-30 20:39:04,883 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 4160 states and 4512 transitions.
[2020-05-30 20:39:04,890 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:39:04,896 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 4160 states to 4160 states and 4512 transitions.
[2020-05-30 20:39:04,896 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 777
[2020-05-30 20:39:04,897 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 777
[2020-05-30 20:39:04,897 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 4160 states and 4512 transitions.
[2020-05-30 20:39:04,898 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:04,898 INFO  L728         BuchiCegarLoop]: Abstraction has 4160 states and 4512 transitions.
[2020-05-30 20:39:04,901 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 4160 states and 4512 transitions.
[2020-05-30 20:39:04,915 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 4160 to 4109.
[2020-05-30 20:39:04,915 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 4109 states.
[2020-05-30 20:39:04,918 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 4109 states to 4109 states and 4438 transitions.
[2020-05-30 20:39:04,918 INFO  L751         BuchiCegarLoop]: Abstraction has 4109 states and 4438 transitions.
[2020-05-30 20:39:04,918 INFO  L631         BuchiCegarLoop]: Abstraction has 4109 states and 4438 transitions.
[2020-05-30 20:39:04,918 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:39:04,919 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 4109 states and 4438 transitions.
[2020-05-30 20:39:04,922 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:39:04,922 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:04,922 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:04,923 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:04,923 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND TRUE   choice == 10
[L3012]                    gas := gas - 21000;
[L3013]        COND TRUE   gas >= 0
[L3015]                    assume msgvalue_MSG == 0;
[L3016]        CALL        call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L230]                     havoc __exception;
[L231]                     revert := false;
[L232]         COND FALSE  !(__exception)
[L251]         CALL        call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L1423]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1423]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1424]        COND FALSE  !(revert)
[L1429]                    gas := gas - 88;
[L1430]                    __var_1 := null;
[L1431]        COND FALSE  !(!(recipient_s113 != null))
[L1437]                    gas := gas - 40534;
[L1438]                    _primary_Secondary[this] := recipient_s113;
[L1439]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L251]         RET         call transferPrimary_Secondary__success(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L252]                     assume !revert && gas >= 0;
[L3016]        RET         call transferPrimary_Secondary(this, msgsender_MSG, msgvalue_MSG, recipient_s113);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND TRUE   choice == 1
[L3093]              gas := gas - 21000;
[L3094]  COND TRUE   gas >= 0
[L3096]              assume msgvalue_MSG == 0;
[L3097]  CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]               havoc __exception;
[L750]               revert := false;
[L751]   COND FALSE  !(__exception)
[L770]   CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]              gas := gas - 317;
[L2342]  COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]              gas := gas - 36484;
[L2349]              __var_8 := gas;
[L2350]  COND TRUE   gas > 2300
[L2352]              gas := 2300;
[L2355]              __var_8 := __var_8 - gas;
[L2356]              __var_9 := this;
[L2357]              assume Balance[this] >= 0;
[L2358]  CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]              havoc __exception;
[L2545]  COND FALSE  !(__exception)
[L2570]  COND TRUE   Balance[from] >= amount
[L2572]  CALL        call FallbackDispatch__success(from, to, amount);
[L2424]  COND FALSE  !(DType[to] == RefundEscrow)
[L2428]  COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]  COND FALSE  !(DType[to] == Escrow)
[L2436]  COND FALSE  !(DType[to] == Secondary)
[L2442]  CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]              assume Balance[from] >= amount;
[L2464]              Balance[from] := Balance[from] - amount;
[L2465]              Balance[to] := Balance[to] + amount;
[L2442]  RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]  COND FALSE  !(revert)
[L2572]  RET         call FallbackDispatch__success(from, to, amount);
[L2573]              success := true;
[L2580]              assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                 revert := revert_hold;
[L2358]  RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]  COND FALSE  !(!__var_10)
[L2365]              gas := __var_8 + gas;
[L770]   RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                 success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3097]  RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:04,927 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:04,927 INFO  L82        PathProgramCache]: Analyzing trace with hash 881412122, now seen corresponding path program 1 times
[2020-05-30 20:39:04,928 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:04,947 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:05,326 INFO  L134       CoverageAnalysis]: Checked inductivity of 239 backedges. 39 proven. 41 refuted. 0 times theorem prover too weak. 159 trivial. 0 not checked.
[2020-05-30 20:39:05,326 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:39:05,326 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 20:39:05,327 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:05,327 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 20:39:05,328 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=146, Invalid=1746, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 20:39:05,328 INFO  L87              Difference]: Start difference. First operand 4109 states and 4438 transitions. cyclomatic complexity: 345 Second operand 44 states.
[2020-05-30 20:39:14,200 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:14,200 INFO  L93              Difference]: Finished difference Result 4142 states and 4494 transitions.
[2020-05-30 20:39:14,200 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 58 states. 
[2020-05-30 20:39:14,200 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 4142 states and 4494 transitions.
[2020-05-30 20:39:14,209 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:39:14,215 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 4142 states to 4112 states and 4414 transitions.
[2020-05-30 20:39:14,215 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 775
[2020-05-30 20:39:14,215 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 775
[2020-05-30 20:39:14,215 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 4112 states and 4414 transitions.
[2020-05-30 20:39:14,217 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:14,217 INFO  L728         BuchiCegarLoop]: Abstraction has 4112 states and 4414 transitions.
[2020-05-30 20:39:14,219 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 4112 states and 4414 transitions.
[2020-05-30 20:39:14,233 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 4112 to 4003.
[2020-05-30 20:39:14,233 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 4003 states.
[2020-05-30 20:39:14,236 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 4003 states to 4003 states and 4296 transitions.
[2020-05-30 20:39:14,236 INFO  L751         BuchiCegarLoop]: Abstraction has 4003 states and 4296 transitions.
[2020-05-30 20:39:14,236 INFO  L631         BuchiCegarLoop]: Abstraction has 4003 states and 4296 transitions.
[2020-05-30 20:39:14,236 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:39:14,236 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 4003 states and 4296 transitions.
[2020-05-30 20:39:14,240 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-05-30 20:39:14,240 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:14,240 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:14,241 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:14,241 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_close_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc ben;
[L3111]                    assume null == 0;
[L3112]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3112]        RET         call this := FreshRefGenerator__success();
[L3113]                    assume now >= 0;
[L3114]                    assume DType[this] == RefundEscrow;
[L3115]                    gas := gas - 53000;
[L3116]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3116]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3117]                    assume !revert && gas >= 0;
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND TRUE   choice == 7
[L3039]                    gas := gas - 21000;
[L3040]        COND TRUE   gas >= 0
[L3042]                    assume msgvalue_MSG == 0;
[L3043]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2463]                    assume Balance[from] >= amount;
[L2464]                    Balance[from] := Balance[from] - amount;
[L2465]                    Balance[to] := Balance[to] + amount;
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L3043]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND TRUE   choice == 8
[L3030]                    gas := gas - 21000;
[L3031]        COND TRUE   gas >= 0
[L3033]                    assume msgvalue_MSG >= 0;
[L3034]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3034]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND TRUE   choice == 3
[L3075]                    gas := gas - 21000;
[L3076]        COND TRUE   gas >= 0
[L3078]                    assume msgvalue_MSG == 0;
[L3079]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2600]                    gas := gas - 2208;
[L2601]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L1]           CALL        call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2148]                    gas := gas - 3;
[L2149]                    gas := gas - 294;
[L2150]                    __ret_0_ := _beneficiary_RefundEscrow[this];
[L1]           RET         call __beneficiary_RefundEscrow0 := beneficiary_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L7]                       assume ben == __beneficiary_RefundEscrow0;
[L7]                       success_close_RefundEscrow0 := true;
[L7]                       success_close_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3079]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);
[L3120]        CALL        call CorralChoice_RefundEscrow(this);
[L2974]                    havoc msgsender_MSG;
[L2975]                    havoc msgvalue_MSG;
[L2976]                    havoc choice;
[L2977]                    havoc __ret_0_primary;
[L2978]                    havoc recipient_s113;
[L2979]                    havoc payee_s148;
[L2980]                    havoc __ret_0_depositsOf;
[L2981]                    havoc refundee_s327;
[L2982]                    havoc payee_s255;
[L2983]                    havoc __arg_0_withdrawalAllowed;
[L2984]                    havoc __ret_0_withdrawalAllowed;
[L2985]                    havoc beneficiary_s294;
[L2986]                    havoc __ret_0_state;
[L2987]                    havoc __ret_0_beneficiary;
[L2988]                    havoc tmpNow;
[L2989]                    havoc gas;
[L2990]                    assume gas > 4000000 && gas <= 8000000;
[L2991]                    tmpNow := now;
[L2992]                    havoc now;
[L2993]                    assume now > tmpNow;
[L2994]                    assume msgsender_MSG != null;
[L2995]                    assume DType[msgsender_MSG] != SafeMath;
[L2996]                    assume DType[msgsender_MSG] != Secondary;
[L2997]                    assume DType[msgsender_MSG] != Escrow;
[L2998]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3000]                    Alloc[msgsender_MSG] := true;
[L3001]        COND FALSE  !(choice == 11)
[L3010]        COND FALSE  !(choice == 10)
[L3019]        COND FALSE  !(choice == 9)
[L3028]        COND FALSE  !(choice == 8)
[L3037]        COND FALSE  !(choice == 7)
[L3046]        COND FALSE  !(choice == 6)
[L3055]        COND FALSE  !(choice == 5)
[L3064]        COND FALSE  !(choice == 4)
[L3073]        COND FALSE  !(choice == 3)
[L3082]        COND FALSE  !(choice == 2)
[L3091]        COND TRUE   choice == 1
[L3093]                    gas := gas - 21000;
[L3094]        COND TRUE   gas >= 0
[L3096]                    assume msgvalue_MSG == 0;
[L3097]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2544]                    havoc __exception;
[L2545]        COND FALSE  !(__exception)
[L2570]        COND TRUE   Balance[from] >= amount
[L2572]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L2572]        RET         call FallbackDispatch__success(from, to, amount);
[L2573]                    success := true;
[L2580]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == ben && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := true;
[L7]                       success_beneficiaryWithdraw_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3097]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3120]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3120]  CALL        call CorralChoice_RefundEscrow(this);
[L2974]              havoc msgsender_MSG;
[L2975]              havoc msgvalue_MSG;
[L2976]              havoc choice;
[L2977]              havoc __ret_0_primary;
[L2978]              havoc recipient_s113;
[L2979]              havoc payee_s148;
[L2980]              havoc __ret_0_depositsOf;
[L2981]              havoc refundee_s327;
[L2982]              havoc payee_s255;
[L2983]              havoc __arg_0_withdrawalAllowed;
[L2984]              havoc __ret_0_withdrawalAllowed;
[L2985]              havoc beneficiary_s294;
[L2986]              havoc __ret_0_state;
[L2987]              havoc __ret_0_beneficiary;
[L2988]              havoc tmpNow;
[L2989]              havoc gas;
[L2990]              assume gas > 4000000 && gas <= 8000000;
[L2991]              tmpNow := now;
[L2992]              havoc now;
[L2993]              assume now > tmpNow;
[L2994]              assume msgsender_MSG != null;
[L2995]              assume DType[msgsender_MSG] != SafeMath;
[L2996]              assume DType[msgsender_MSG] != Secondary;
[L2997]              assume DType[msgsender_MSG] != Escrow;
[L2998]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L2999]              assume DType[msgsender_MSG] != RefundEscrow;
[L3000]              Alloc[msgsender_MSG] := true;
[L3001]  COND FALSE  !(choice == 11)
[L3010]  COND FALSE  !(choice == 10)
[L3019]  COND FALSE  !(choice == 9)
[L3028]  COND FALSE  !(choice == 8)
[L3037]  COND FALSE  !(choice == 7)
[L3046]  COND FALSE  !(choice == 6)
[L3055]  COND FALSE  !(choice == 5)
[L3064]  COND FALSE  !(choice == 4)
[L3073]  COND FALSE  !(choice == 3)
[L3082]  COND FALSE  !(choice == 2)
[L3091]  COND FALSE  !(choice == 1)
[L3120]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:14,244 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:14,244 INFO  L82        PathProgramCache]: Analyzing trace with hash 1597970906, now seen corresponding path program 1 times
[2020-05-30 20:39:14,245 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:14,257 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:14,354 INFO  L134       CoverageAnalysis]: Checked inductivity of 154 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:39:14,355 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:39:14,355 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [12] total 12
[2020-05-30 20:39:14,355 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:14,355 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 12 interpolants.
[2020-05-30 20:39:14,355 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=23, Invalid=109, Unknown=0, NotChecked=0, Total=132
[2020-05-30 20:39:14,355 INFO  L87              Difference]: Start difference. First operand 4003 states and 4296 transitions. cyclomatic complexity: 299 Second operand 12 states.
[2020-05-30 20:39:14,782 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:14,782 INFO  L93              Difference]: Finished difference Result 1008 states and 1074 transitions.
[2020-05-30 20:39:14,782 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:39:14,782 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 1008 states and 1074 transitions.
[2020-05-30 20:39:14,783 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:39:14,783 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 1008 states to 0 states and 0 transitions.
[2020-05-30 20:39:14,783 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:39:14,783 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:39:14,783 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:39:14,783 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:14,783 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:39:14,783 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:39:14,783 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:39:14,783 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 20:39:14,784 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:39:14,784 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:39:14,784 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:39:14,786 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:39:14 BasicIcfg
[2020-05-30 20:39:14,786 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:39:14,787 INFO  L168              Benchmark]: Toolchain (without parser) took 197907.06 ms. Allocated memory was 514.9 MB in the beginning and 4.1 GB in the end (delta: 3.6 GB). Free memory was 458.8 MB in the beginning and 3.6 GB in the end (delta: -3.1 GB). Peak memory consumption was 458.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,788 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,788 INFO  L168              Benchmark]: Boogie Preprocessor took 69.02 ms. Allocated memory is still 514.9 MB. Free memory was 458.8 MB in the beginning and 452.1 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,788 INFO  L168              Benchmark]: UtopiaSpecLang took 43.13 ms. Allocated memory is still 514.9 MB. Free memory was 452.1 MB in the beginning and 448.1 MB in the end (delta: 4.0 MB). Peak memory consumption was 4.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,789 INFO  L168              Benchmark]: Boogie Printer took 11.05 ms. Allocated memory is still 514.9 MB. Free memory was 448.1 MB in the beginning and 445.4 MB in the end (delta: 2.7 MB). Peak memory consumption was 2.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,789 INFO  L168              Benchmark]: RCFGBuilder took 466.66 ms. Allocated memory is still 514.9 MB. Free memory was 445.4 MB in the beginning and 375.3 MB in the end (delta: 70.1 MB). Peak memory consumption was 70.1 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,790 INFO  L168              Benchmark]: UtopiaLTL2Aut took 46.15 ms. Allocated memory is still 514.9 MB. Free memory was 375.3 MB in the beginning and 370.7 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,790 INFO  L168              Benchmark]: Büchi Program Product took 4333.38 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 767.6 MB). Free memory was 370.7 MB in the beginning and 531.8 MB in the end (delta: -161.1 MB). Peak memory consumption was 663.5 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,791 INFO  L168              Benchmark]: BlockEncodingV2 took 400.00 ms. Allocated memory is still 1.3 GB. Free memory was 531.8 MB in the beginning and 272.1 MB in the end (delta: 259.7 MB). Peak memory consumption was 259.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,791 INFO  L168              Benchmark]: BuchiAutomizer took 192533.66 ms. Allocated memory was 1.3 GB in the beginning and 4.1 GB in the end (delta: 2.8 GB). Free memory was 272.1 MB in the beginning and 3.6 GB in the end (delta: -3.3 GB). There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:39:14,795 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    12255 locations, 48203 edges
  - StatisticsResult: Encoded RCFG
    12031 locations, 46873 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 69.02 ms. Allocated memory is still 514.9 MB. Free memory was 458.8 MB in the beginning and 452.1 MB in the end (delta: 6.7 MB). Peak memory consumption was 6.7 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 43.13 ms. Allocated memory is still 514.9 MB. Free memory was 452.1 MB in the beginning and 448.1 MB in the end (delta: 4.0 MB). Peak memory consumption was 4.0 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 11.05 ms. Allocated memory is still 514.9 MB. Free memory was 448.1 MB in the beginning and 445.4 MB in the end (delta: 2.7 MB). Peak memory consumption was 2.7 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 466.66 ms. Allocated memory is still 514.9 MB. Free memory was 445.4 MB in the beginning and 375.3 MB in the end (delta: 70.1 MB). Peak memory consumption was 70.1 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 46.15 ms. Allocated memory is still 514.9 MB. Free memory was 375.3 MB in the beginning and 370.7 MB in the end (delta: 4.5 MB). Peak memory consumption was 4.5 MB. Max. memory is 15.3 GB.
 * Büchi Program Product took 4333.38 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 767.6 MB). Free memory was 370.7 MB in the beginning and 531.8 MB in the end (delta: -161.1 MB). Peak memory consumption was 663.5 MB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 400.00 ms. Allocated memory is still 1.3 GB. Free memory was 531.8 MB in the beginning and 272.1 MB in the end (delta: 259.7 MB). Peak memory consumption was 259.7 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 192533.66 ms. Allocated memory was 1.3 GB in the beginning and 4.1 GB in the end (delta: 2.8 GB). Free memory was 272.1 MB in the beginning and 3.6 GB in the end (delta: -3.3 GB). There was no memory consumed. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1270 locations, 1641 edges
  - StatisticsResult: BuchiProgram size
    12255 locations, 48203 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 27 terminating modules (27 trivial, 0 deterministic, 0 nondeterministic). 27 modules have a trivial ranking function, the largest among these consists of 64 locations.
  - StatisticsResult: Timing statistics
    BüchiAutomizer plugin needed 192.5s and 28 iterations.  TraceHistogramMax:4. Analysis of lassos took 5.7s. Construction of modules took 142.9s. Büchi inclusion checks took 37.7s. Highest rank in rank-based complementation 0. Minimization of det autom 27. Minimization of nondet autom 0. Automata minimization 2.9s AutomataMinimizationTime, 26 MinimizatonAttempts, 17601 StatesRemovedByMinimization, 20 NontrivialMinimizations. Non-live state removal took 1.9s Buchi closure took 0.0s. Biggest automaton had 24035 states and ocurred in iteration 17.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 187741 SDtfs, 336601 SDslu, 381022 SDs, 0 SdLazy, 1655088 SolverSat, 67119 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 142.9s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU27 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_beneficiaryWithdraw_RefundEscrow0) ) )&& ! ( ( []( (success_close_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
