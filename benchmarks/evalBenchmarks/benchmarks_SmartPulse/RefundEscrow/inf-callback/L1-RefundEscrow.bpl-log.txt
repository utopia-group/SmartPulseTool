This is Ultimate 0.1.24-9993c5c-m
[2020-05-30 20:39:16,466 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-05-30 20:39:16,467 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-05-30 20:39:16,478 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-05-30 20:39:16,479 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-05-30 20:39:16,480 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-05-30 20:39:16,481 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-05-30 20:39:16,483 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-05-30 20:39:16,485 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-05-30 20:39:16,486 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-05-30 20:39:16,497 INFO  L177        SettingsManager]: Büchi Program Product provides no preferences, ignoring...
[2020-05-30 20:39:16,498 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-05-30 20:39:16,499 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-05-30 20:39:16,500 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-05-30 20:39:16,501 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-05-30 20:39:16,502 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-05-30 20:39:16,503 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-05-30 20:39:16,504 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-05-30 20:39:16,506 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-05-30 20:39:16,507 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-05-30 20:39:16,508 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-05-30 20:39:16,509 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-05-30 20:39:16,511 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-05-30 20:39:16,512 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-05-30 20:39:16,512 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-05-30 20:39:16,513 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-05-30 20:39:16,513 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-05-30 20:39:16,514 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-05-30 20:39:16,514 INFO  L174        SettingsManager]: Resetting UtopiaLiveness preferences to default values
[2020-05-30 20:39:16,515 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-05-30 20:39:16,515 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-05-30 20:39:16,516 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-05-30 20:39:16,517 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-05-30 20:39:16,518 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-05-30 20:39:16,519 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-05-30 20:39:16,520 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-05-30 20:39:16,520 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-05-30 20:39:16,521 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-05-30 20:39:16,521 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-05-30 20:39:16,521 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-05-30 20:39:16,522 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-05-30 20:39:16,522 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-05-30 20:39:16,523 INFO  L98         SettingsManager]: Beginning loading settings from /Users/jon/Documents/Research/masterUltimate/SmartPulse/settings.epf
[2020-05-30 20:39:16,533 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-05-30 20:39:16,533 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-05-30 20:39:16,534 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/Users/jon/Documents/Research/devUltimate/ltl2ba
[2020-05-30 20:39:16,534 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-05-30 20:39:16,534 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-05-30 20:39:16,534 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-05-30 20:39:16,535 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-05-30 20:39:16,535 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-05-30 20:39:16,535 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-05-30 20:39:16,536 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-05-30 20:39:16,555 INFO  L81    nceAwareModelManager]: Repository-Root is: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T
[2020-05-30 20:39:16,566 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-05-30 20:39:16,568 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-05-30 20:39:16,569 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-05-30 20:39:16,569 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-05-30 20:39:16,570 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/inf-callback/L1-RefundEscrow.bpl
[2020-05-30 20:39:16,570 INFO  L111           BoogieParser]: Parsing: '/Users/jon/Documents/Research/masterUltimate/benchmarks/evalBenchmarks/benchmarks/RefundEscrow/inf-callback/L1-RefundEscrow.bpl'
[2020-05-30 20:39:16,624 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-05-30 20:39:16,625 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-05-30 20:39:16,625 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-05-30 20:39:16,625 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-05-30 20:39:16,625 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-05-30 20:39:16,638 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,639 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,663 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,663 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,676 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,685 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,691 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,698 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-05-30 20:39:16,699 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-05-30 20:39:16,699 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-05-30 20:39:16,701 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-05-30 20:39:16,703 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/1) ...
[2020-05-30 20:39:16,716 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:39:16,721 INFO  L979   opiaSpecLangObserver]: Successfully lexed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:39:16,727 INFO  L981   opiaSpecLangObserver]: Successfully parsed: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:39:16,729 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:39:16,732 INFO  L599   opiaSpecLangObserver]: Parsed ( to==user && amount==fsum_deposit_RefundEscrow_2_0 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[to,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[user,GLOBAL]],BinaryExpression[COMPEQ,IdentifierExpression[amount,<IMPLEMENTATION_INPARAM,send__success>],IdentifierExpression[fsum_deposit_RefundEscrow_2_0,GLOBAL]]]
[2020-05-30 20:39:16,733 INFO  L968   opiaSpecLangObserver]: Compiling: []((finished(RefundEscrow.enableRefunds)) ==> (<>(finished(send(from, to, amt), (to == user && amt == fsum(RefundEscrow.deposit(payee), 2, payee == user))))))
[2020-05-30 20:39:16,733 INFO  L970   opiaSpecLangObserver]: Compiled to ( []( AP(success_enableRefunds_RefundEscrow0) ==> ( <>AP(success_send__success0) ) ) )
[2020-05-30 20:39:16,733 INFO  L975   opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:39:16,733 INFO  L979   opiaSpecLangObserver]: Successfully lexed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:39:16,734 INFO  L981   opiaSpecLangObserver]: Successfully parsed: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:39:16,735 INFO  L599   opiaSpecLangObserver]: Parsed payee_s255==user to BinaryExpression[COMPEQ,IdentifierExpression[payee_s255,<IMPLEMENTATION_INPARAM,withdraw_ConditionalEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:39:16,736 INFO  L599   opiaSpecLangObserver]: Parsed refundee_s327==user to BinaryExpression[COMPEQ,IdentifierExpression[refundee_s327,<IMPLEMENTATION_INPARAM,deposit_RefundEscrow>],IdentifierExpression[user,GLOBAL]]
[2020-05-30 20:39:16,737 INFO  L968   opiaSpecLangObserver]: Compiling: (<>(finished(RefundEscrow.deposit(payee), (payee == user)))) && (<>(finished(ConditionalEscrow.withdraw(payee), (payee == user))))
[2020-05-30 20:39:16,737 INFO  L970   opiaSpecLangObserver]: Compiled to ( ( <>AP(success_deposit_RefundEscrow0) ) && ( <>AP(success_withdraw_ConditionalEscrow0) ) )
Executed UtopiaSpecLang
[2020-05-30 20:39:16,745 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:39:16 PropertyContainer
[2020-05-30 20:39:16,745 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-05-30 20:39:16,745 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-05-30 20:39:16,745 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-05-30 20:39:16,745 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-05-30 20:39:16,746 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/2) ...
[2020-05-30 20:39:16,746 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:39:16,747 INFO  L120   oogiePrinterObserver]: Writing to file /var/folders/t6/mxckf6w17qb907fknyrxnkyc0000gp/T/boogiePrinter.bpl
[2020-05-30 20:39:16,757 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:39:16" (2/2) ...
[2020-05-30 20:39:16,757 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-05-30 20:39:16,757 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-05-30 20:39:16,758 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-05-30 20:39:16,758 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-05-30 20:39:16,758 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/2) ...
[2020-05-30 20:39:16,800 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-05-30 20:39:16,800 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-05-30 20:39:16,801 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__success
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__success
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary
[2020-05-30 20:39:16,801 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary
[2020-05-30 20:39:16,801 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary
[2020-05-30 20:39:16,802 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary
[2020-05-30 20:39:16,802 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary
[2020-05-30 20:39:16,802 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary
[2020-05-30 20:39:16,802 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:39:16,802 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow
[2020-05-30 20:39:16,802 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow
[2020-05-30 20:39:16,802 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow
[2020-05-30 20:39:16,802 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow
[2020-05-30 20:39:16,803 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow
[2020-05-30 20:39:16,803 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:39:16,803 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_ConditionalEscrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow
[2020-05-30 20:39:16,803 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:39:16,803 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:39:16,803 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:39:16,804 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__success
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Secondary
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Secondary
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Escrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Escrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_RefundEscrow
[2020-05-30 20:39:16,805 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure sub_SafeMath__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure add_SafeMath__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__success
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure Secondary_Secondary__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__success
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure primary_Secondary__fail
[2020-05-30 20:39:16,806 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__success
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure transferPrimary_Secondary__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__success
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure Escrow_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__success
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure depositsOf_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__success
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__success
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:39:16,807 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure state_RefundEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__success
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure deposit_RefundEscrow__fail
[2020-05-30 20:39:16,808 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__success
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure close_RefundEscrow__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-05-30 20:39:16,809 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyPrimary_pre__fail
[2020-05-30 20:39:16,809 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__fail
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub_SafeMath__success
[2020-05-30 20:39:16,810 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__fail
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure add_SafeMath__success
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__fail
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary_NoBaseCtor__success
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__fail
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure Secondary_Secondary__success
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__fail
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure primary_Secondary__success
[2020-05-30 20:39:16,811 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__fail
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferPrimary_Secondary__success
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__fail
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow_NoBaseCtor__success
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__fail
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure Escrow_Escrow__success
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__fail
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure depositsOf_Escrow__success
[2020-05-30 20:39:16,812 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__fail
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow__success
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__fail
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_Escrow_Escrow__success
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__fail
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow__success
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__fail
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_Escrow_Escrow__success
[2020-05-30 20:39:16,813 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__fail
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure ConditionalEscrow_ConditionalEscrow__success
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__fail
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdraw_ConditionalEscrow__success
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__fail
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow_NoBaseCtor__success
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__fail
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure RefundEscrow_RefundEscrow__success
[2020-05-30 20:39:16,814 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure state_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiary_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure deposit_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure close_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure enableRefunds_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure beneficiaryWithdraw_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure withdrawalAllowed_RefundEscrow__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-05-30 20:39:16,815 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__fail
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyPrimary_pre__success
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Secondary
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Secondary
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Escrow
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Escrow
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ConditionalEscrow
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ConditionalEscrow
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_RefundEscrow
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-05-30 20:39:16,816 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-05-30 20:39:16,816 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-05-30 20:39:16,923 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:39:16,939 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:39:16,951 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:39:17,159 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:39:17,159 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-05-30 20:39:17,293 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-05-30 20:39:17,293 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-05-30 20:39:17,294 INFO  L202        PluginConnector]: Adding new model L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:39:17 BoogieIcfgContainer
[2020-05-30 20:39:17,294 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:39:16" (2/2) ...
[2020-05-30 20:39:17,295 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-05-30 20:39:17,295 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@68114d0a and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:39:17, skipping insertion in model container
[2020-05-30 20:39:17,295 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-05-30 20:39:17,295 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-05-30 20:39:17,295 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-05-30 20:39:17,296 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-05-30 20:39:17,297 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/3) ...
[2020-05-30 20:39:17,297 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@5832543c and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:39:17, skipping insertion in model container
[2020-05-30 20:39:17,297 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:39:16" (2/3) ...
No working directory specified, using /Users/jon/Documents/Research/devUltimate/ltl2ba
Starting monitored process 1 with /Users/jon/Documents/Research/devUltimate/ltl2ba -f  ( ( <>a ) && ( <>b ) ) && ! ( ( [] ( c -> ( <>d ) ) ) )  (exit command is null, workingDir is null)
[2020-05-30 20:39:17,341 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:39:17 NWAContainer
[2020-05-30 20:39:17,341 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-05-30 20:39:17,341 INFO  L113        PluginConnector]: ------------------------Büchi Program Product----------------------------
[2020-05-30 20:39:17,341 INFO  L271        PluginConnector]: Initializing Büchi Program Product...
[2020-05-30 20:39:17,342 INFO  L276        PluginConnector]: Büchi Program Product initialized
[2020-05-30 20:39:17,343 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:39:17" (3/4) ...
[2020-05-30 20:39:17,343 INFO  L205        PluginConnector]: Invalid model from Büchi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@42f68ab7 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:39:17, skipping insertion in model container
[2020-05-30 20:39:17,343 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin Büchi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:39:17" (4/4) ...
[2020-05-30 20:39:17,346 INFO  L104   BuchiProductObserver]: Initial property automaton 8 locations, 27 edges
[2020-05-30 20:39:17,349 INFO  L110   BuchiProductObserver]: Initial RCFG 1609 locations, 2228 edges
[2020-05-30 20:39:17,349 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-05-30 20:39:17,358 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-05-30 20:39:22,988 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-05-30 20:39:23,010 INFO  L110   BuchiProductObserver]: BuchiProgram size 15687 locations, 65222 edges
[2020-05-30 20:39:23,011 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:39:23 BoogieIcfgContainer
[2020-05-30 20:39:23,011 INFO  L132        PluginConnector]: ------------------------ END Büchi Program Product----------------------------
[2020-05-30 20:39:23,011 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-05-30 20:39:23,011 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-05-30 20:39:23,012 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-05-30 20:39:23,013 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:39:23" (1/1) ...
[2020-05-30 20:39:23,468 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,468 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,469 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,469 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,469 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,469 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,473 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,474 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,474 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,474 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,474 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,474 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,476 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,476 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,476 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,476 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,476 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,477 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,478 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,480 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,480 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,481 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,482 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,482 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,482 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,483 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call this := FreshRefGenerator__success();
[2020-05-30 20:39:23,484 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,485 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,486 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,492 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,492 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,492 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,492 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,493 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__success(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,512 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,513 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,513 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,513 WARN  L196         IcfgDuplicator]: Creating raw copy for unreachable call because return is reachable in graph view: call SafeMath_SafeMath__fail(this, msgsender_MSG, msgvalue_MSG);
[2020-05-30 20:39:23,548 INFO  L313           BlockEncoder]: Initial Icfg 15687 locations, 65222 edges
[2020-05-30 20:39:23,548 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-05-30 20:39:23,549 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-05-30 20:39:23,549 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-05-30 20:39:23,549 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-05-30 20:39:23,584 INFO  L70    emoveInfeasibleEdges]: Removed 764 edges and 52 locations because of local infeasibility
[2020-05-30 20:39:23,607 INFO  L70        RemoveSinkStates]: Removed 288 edges and 84 locations by removing sink states
[2020-05-30 20:39:23,654 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-05-30 20:39:23,668 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-05-30 20:39:23,684 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-05-30 20:39:23,685 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-05-30 20:39:23,699 INFO  L313           BlockEncoder]: Encoded RCFG 15463 locations, 63892 edges
[2020-05-30 20:39:23,700 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:39:23 BasicIcfg
[2020-05-30 20:39:23,700 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-05-30 20:39:23,700 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-05-30 20:39:23,700 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-05-30 20:39:23,702 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-05-30 20:39:23,702 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,702 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 30.05 08:39:16" (1/6) ...
[2020-05-30 20:39:23,704 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@3e501142 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:39:23, skipping insertion in model container
[2020-05-30 20:39:23,704 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,704 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 30.05 08:39:16" (2/6) ...
[2020-05-30 20:39:23,704 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@3e501142 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:39:23, skipping insertion in model container
[2020-05-30 20:39:23,704 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,704 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 30.05 08:39:17" (3/6) ...
[2020-05-30 20:39:23,704 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@3e501142 and model type L1-RefundEscrow.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:39:23, skipping insertion in model container
[2020-05-30 20:39:23,704 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,704 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 30.05 08:39:17" (4/6) ...
[2020-05-30 20:39:23,704 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@3e501142 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 30.05 08:39:23, skipping insertion in model container
[2020-05-30 20:39:23,705 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,705 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 30.05 08:39:23" (5/6) ...
[2020-05-30 20:39:23,705 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@3e501142 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 30.05 08:39:23, skipping insertion in model container
[2020-05-30 20:39:23,705 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-05-30 20:39:23,705 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 30.05 08:39:23" (6/6) ...
[2020-05-30 20:39:23,706 INFO  L404   chiAutomizerObserver]: Analyzing ICFG L1-RefundEscrow.bpl_BEv2
[2020-05-30 20:39:23,737 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-05-30 20:39:23,737 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-05-30 20:39:23,737 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-05-30 20:39:23,737 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-05-30 20:39:23,737 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-05-30 20:39:23,737 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-05-30 20:39:23,737 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-05-30 20:39:23,737 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-05-30 20:39:23,737 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-05-30 20:39:23,879 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15463 states.
[2020-05-30 20:39:24,066 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:24,066 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:24,066 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:24,077 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:24,077 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:24,077 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-05-30 20:39:24,077 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15463 states.
[2020-05-30 20:39:24,166 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:24,166 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:24,166 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:24,168 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:24,168 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND TRUE   choice == 11
[L3747]              gas := gas - 21000;
[L3748]  COND FALSE  !(gas >= 0)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:24,182 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:24,182 INFO  L82        PathProgramCache]: Analyzing trace with hash -1306399335, now seen corresponding path program 1 times
[2020-05-30 20:39:24,187 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:24,204 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:24,246 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:39:24,248 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:24,248 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:24,961 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:24,978 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:24,978 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:24,981 INFO  L87              Difference]: Start difference. First operand 15463 states. Second operand 3 states.
[2020-05-30 20:39:26,156 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:26,156 INFO  L93              Difference]: Finished difference Result 12059 states and 30964 transitions.
[2020-05-30 20:39:26,157 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:26,158 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12059 states and 30964 transitions.
[2020-05-30 20:39:26,243 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:26,361 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12059 states to 12059 states and 30964 transitions.
[2020-05-30 20:39:26,361 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 8
[2020-05-30 20:39:26,363 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 123
[2020-05-30 20:39:26,364 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12059 states and 30964 transitions.
[2020-05-30 20:39:26,416 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:26,416 INFO  L728         BuchiCegarLoop]: Abstraction has 12059 states and 30964 transitions.
[2020-05-30 20:39:26,447 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12059 states and 30964 transitions.
[2020-05-30 20:39:26,655 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12059 to 12059.
[2020-05-30 20:39:26,655 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12059 states.
[2020-05-30 20:39:26,684 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12059 states to 12059 states and 30964 transitions.
[2020-05-30 20:39:26,685 INFO  L751         BuchiCegarLoop]: Abstraction has 12059 states and 30964 transitions.
[2020-05-30 20:39:26,685 INFO  L631         BuchiCegarLoop]: Abstraction has 12059 states and 30964 transitions.
[2020-05-30 20:39:26,685 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-05-30 20:39:26,685 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12059 states and 30964 transitions.
[2020-05-30 20:39:26,709 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:26,709 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:26,709 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:26,712 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:26,712 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:26,716 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:26,716 INFO  L82        PathProgramCache]: Analyzing trace with hash 1115904747, now seen corresponding path program 1 times
[2020-05-30 20:39:26,717 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:26,725 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:26,738 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:39:26,738 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:26,738 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:26,740 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:26,740 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:26,740 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:26,740 INFO  L87              Difference]: Start difference. First operand 12059 states and 30964 transitions. cyclomatic complexity: 18929 Second operand 3 states.
[2020-05-30 20:39:27,291 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:27,291 INFO  L93              Difference]: Finished difference Result 11645 states and 20723 transitions.
[2020-05-30 20:39:27,291 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:27,292 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11645 states and 20723 transitions.
[2020-05-30 20:39:27,328 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:27,392 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11645 states to 11645 states and 20723 transitions.
[2020-05-30 20:39:27,392 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 123
[2020-05-30 20:39:27,393 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 123
[2020-05-30 20:39:27,393 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11645 states and 20723 transitions.
[2020-05-30 20:39:27,409 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:27,409 INFO  L728         BuchiCegarLoop]: Abstraction has 11645 states and 20723 transitions.
[2020-05-30 20:39:27,424 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11645 states and 20723 transitions.
[2020-05-30 20:39:27,551 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11645 to 11645.
[2020-05-30 20:39:27,551 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11645 states.
[2020-05-30 20:39:27,578 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11645 states to 11645 states and 20723 transitions.
[2020-05-30 20:39:27,578 INFO  L751         BuchiCegarLoop]: Abstraction has 11645 states and 20723 transitions.
[2020-05-30 20:39:27,578 INFO  L631         BuchiCegarLoop]: Abstraction has 11645 states and 20723 transitions.
[2020-05-30 20:39:27,578 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-05-30 20:39:27,578 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11645 states and 20723 transitions.
[2020-05-30 20:39:27,599 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:27,599 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:27,599 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:27,601 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:27,601 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND TRUE   revert
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND TRUE   choice == 2
[L3828]              gas := gas - 21000;
[L3829]  COND TRUE   gas >= 0
[L3831]              assume msgvalue_MSG == 0;
[L3832]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3832]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:27,604 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:27,604 INFO  L82        PathProgramCache]: Analyzing trace with hash -2019034789, now seen corresponding path program 1 times
[2020-05-30 20:39:27,604 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:27,611 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:27,645 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:39:27,646 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:27,646 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:27,646 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:27,646 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:27,646 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:27,647 INFO  L87              Difference]: Start difference. First operand 11645 states and 20723 transitions. cyclomatic complexity: 9102 Second operand 3 states.
[2020-05-30 20:39:27,943 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:27,943 INFO  L93              Difference]: Finished difference Result 11438 states and 14278 transitions.
[2020-05-30 20:39:27,943 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:27,943 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11438 states and 14278 transitions.
[2020-05-30 20:39:27,960 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:27,988 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11438 states to 11438 states and 14278 transitions.
[2020-05-30 20:39:27,988 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 123
[2020-05-30 20:39:27,988 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 123
[2020-05-30 20:39:27,988 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11438 states and 14278 transitions.
[2020-05-30 20:39:27,996 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:27,996 INFO  L728         BuchiCegarLoop]: Abstraction has 11438 states and 14278 transitions.
[2020-05-30 20:39:28,007 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11438 states and 14278 transitions.
[2020-05-30 20:39:28,074 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11438 to 11438.
[2020-05-30 20:39:28,075 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11438 states.
[2020-05-30 20:39:28,088 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11438 states to 11438 states and 14278 transitions.
[2020-05-30 20:39:28,089 INFO  L751         BuchiCegarLoop]: Abstraction has 11438 states and 14278 transitions.
[2020-05-30 20:39:28,089 INFO  L631         BuchiCegarLoop]: Abstraction has 11438 states and 14278 transitions.
[2020-05-30 20:39:28,089 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-05-30 20:39:28,089 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11438 states and 14278 transitions.
[2020-05-30 20:39:28,100 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 267
[2020-05-30 20:39:28,100 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:28,100 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:28,102 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:28,102 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND TRUE   revert
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND TRUE   choice == 8
[L3774]              gas := gas - 21000;
[L3775]  COND TRUE   gas >= 0
[L3777]              assume msgvalue_MSG >= 0;
[L3778]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3778]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND TRUE   choice == 2
[L3828]              gas := gas - 21000;
[L3829]  COND TRUE   gas >= 0
[L3831]              assume msgvalue_MSG == 0;
[L3832]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND TRUE   revert
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3832]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:28,105 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:28,105 INFO  L82        PathProgramCache]: Analyzing trace with hash -1914248811, now seen corresponding path program 1 times
[2020-05-30 20:39:28,105 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:28,112 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:28,137 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-05-30 20:39:28,138 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:28,138 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:28,138 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:28,138 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:28,138 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:28,138 INFO  L87              Difference]: Start difference. First operand 11438 states and 14278 transitions. cyclomatic complexity: 2864 Second operand 3 states.
[2020-05-30 20:39:28,336 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:28,336 INFO  L93              Difference]: Finished difference Result 14200 states and 17523 transitions.
[2020-05-30 20:39:28,336 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:28,337 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14200 states and 17523 transitions.
[2020-05-30 20:39:28,364 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 295
[2020-05-30 20:39:28,411 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14200 states to 14200 states and 17523 transitions.
[2020-05-30 20:39:28,411 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 180
[2020-05-30 20:39:28,411 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 180
[2020-05-30 20:39:28,412 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14200 states and 17523 transitions.
[2020-05-30 20:39:28,421 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:28,421 INFO  L728         BuchiCegarLoop]: Abstraction has 14200 states and 17523 transitions.
[2020-05-30 20:39:28,434 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14200 states and 17523 transitions.
[2020-05-30 20:39:28,566 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14200 to 13333.
[2020-05-30 20:39:28,566 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13333 states.
[2020-05-30 20:39:28,586 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13333 states to 13333 states and 16465 transitions.
[2020-05-30 20:39:28,586 INFO  L751         BuchiCegarLoop]: Abstraction has 13333 states and 16465 transitions.
[2020-05-30 20:39:28,586 INFO  L631         BuchiCegarLoop]: Abstraction has 13333 states and 16465 transitions.
[2020-05-30 20:39:28,586 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-05-30 20:39:28,586 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13333 states and 16465 transitions.
[2020-05-30 20:39:28,601 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 295
[2020-05-30 20:39:28,601 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:28,601 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:28,604 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:28,604 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                 success_send__success0 := false;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]     CALL        call main();
[L7]                 havoc user;
[L3855]              assume null == 0;
[L3856]  CALL        call this := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L3856]  RET         call this := FreshRefGenerator__success();
[L3857]              assume now >= 0;
[L3858]              assume DType[this] == RefundEscrow;
[L3859]              gas := gas - 53000;
[L3860]  CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]               havoc __exception;
[L528]               revert := false;
[L529]   COND FALSE  !(__exception)
[L548]   CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L2089]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]  COND FALSE  !(revert)
[L2095]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L2095]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]  COND FALSE  !(revert)
[L2101]  CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1887]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]  COND FALSE  !(revert)
[L1893]  CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]  CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]  CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]              assume msgsender_MSG != null;
[L1345]              Balance[this] := 0;
[L1346]              _primary_Secondary[this] := null;
[L1347]              _primary_Secondary[this] := msgsender_MSG;
[L1348]              assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]  RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]  COND FALSE  !(revert)
[L1501]  RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]  COND FALSE  !(revert)
[L1507]  CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]              assume msgsender_MSG != null;
[L1468]              Balance[this] := 0;
[L1469]  CALL        call __var_2 := FreshRefGenerator__success();
[L1178]              havoc newRef;
[L1179]              assume Alloc[newRef] == false;
[L1180]              Alloc[newRef] := true;
[L1181]              assume newRef != null;
[L1469]  RET         call __var_2 := FreshRefGenerator__success();
[L1470]  COND FALSE  !(revert)
[L1475]              _deposits_Escrow[this] := __var_2;
[L1476]              M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]              sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]  RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]  COND FALSE  !(revert)
[L1893]  RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]  COND FALSE  !(revert)
[L1899]  CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]              assume msgsender_MSG != null;
[L1857]              Balance[this] := 0;
[L1899]  RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]  COND FALSE  !(revert)
[L2101]  RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]  COND FALSE  !(revert)
[L2107]  CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]              assume msgsender_MSG != null;
[L2039]              Balance[this] := 0;
[L2040]              _beneficiary_RefundEscrow[this] := null;
[L2041]              __var_7 := null;
[L2042]  COND TRUE   !(beneficiary_s294 != null)
[L2044]              revert := true;
[L2107]  RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]  COND FALSE  !(revert)
[L548]   RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]               assume !revert && gas >= 0;
[L3860]  RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]              assume !revert && gas >= 0;
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND TRUE   choice == 8
[L3774]              gas := gas - 21000;
[L3775]  COND TRUE   gas >= 0
[L3777]              assume msgvalue_MSG >= 0;
[L3778]  CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]               havoc __exception;
[L639]               revert := false;
[L640]   COND FALSE  !(__exception)
[L659]   CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]              assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]              Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]              Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]              gas := gas - 317;
[L2191]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2193]              revert := true;
[L659]   RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume refundee_s327 == user;
[L7]                 success_deposit_RefundEscrow0 := true;
[L7]                 success_deposit_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L7]                 assume !(refundee_s327 == user);
[L3778]  RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND TRUE   choice == 2
[L3828]              gas := gas - 21000;
[L3829]  COND TRUE   gas >= 0
[L3831]              assume msgvalue_MSG == 0;
[L3832]  CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]               havoc __exception;
[L713]               revert := false;
[L714]   COND FALSE  !(__exception)
[L733]   CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]  CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]              gas := gas - 2208;
[L3345]  COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]  RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]  COND FALSE  !(revert)
[L2286]              gas := gas - 317;
[L2287]  COND TRUE   !(_state_RefundEscrow[this] == 0)
[L2289]              revert := true;
[L733]   RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 success_enableRefunds_RefundEscrow0 := true;
[L7]                 success_enableRefunds_RefundEscrow0 := false;
[L7]                 revert := revert_hold;
[L3832]  RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND TRUE   choice == 7
[L3783]              gas := gas - 21000;
[L3784]  COND TRUE   gas >= 0
[L3786]              assume msgvalue_MSG == 0;
[L3787]  CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]               havoc __exception;
[L482]               revert := false;
[L483]   COND FALSE  !(__exception)
[L502]   CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]              gas := gas - 27;
[L1966]  COND FALSE  !(DType[this] == RefundEscrow)
[L1974]  COND TRUE   DType[this] == ConditionalEscrow
[L1983]  COND TRUE   !__var_6
[L1985]              revert := true;
[L502]   RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]               assume !revert && gas >= 0;
[L7]                 revert_hold := revert;
[L7]                 revert := false;
[L7]                 assume payee_s255 == user;
[L7]                 success_withdraw_ConditionalEscrow0 := true;
[L7]                 success_withdraw_ConditionalEscrow0 := false;
[L7]                 revert := revert_hold;
[L3787]  RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:28,609 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:28,609 INFO  L82        PathProgramCache]: Analyzing trace with hash -458546742, now seen corresponding path program 1 times
[2020-05-30 20:39:28,610 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:28,621 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:28,674 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:28,674 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:28,674 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:28,674 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:28,674 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:28,675 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:28,675 INFO  L87              Difference]: Start difference. First operand 13333 states and 16465 transitions. cyclomatic complexity: 3156 Second operand 3 states.
[2020-05-30 20:39:28,872 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:28,872 INFO  L93              Difference]: Finished difference Result 14862 states and 17953 transitions.
[2020-05-30 20:39:28,872 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:28,872 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14862 states and 17953 transitions.
[2020-05-30 20:39:28,912 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 271
[2020-05-30 20:39:28,969 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14862 states to 13920 states and 16755 transitions.
[2020-05-30 20:39:28,969 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 173
[2020-05-30 20:39:28,969 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 173
[2020-05-30 20:39:28,969 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13920 states and 16755 transitions.
[2020-05-30 20:39:28,981 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:28,981 INFO  L728         BuchiCegarLoop]: Abstraction has 13920 states and 16755 transitions.
[2020-05-30 20:39:28,994 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13920 states and 16755 transitions.
[2020-05-30 20:39:29,082 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13920 to 12560.
[2020-05-30 20:39:29,083 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12560 states.
[2020-05-30 20:39:29,097 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12560 states to 12560 states and 15008 transitions.
[2020-05-30 20:39:29,097 INFO  L751         BuchiCegarLoop]: Abstraction has 12560 states and 15008 transitions.
[2020-05-30 20:39:29,097 INFO  L631         BuchiCegarLoop]: Abstraction has 12560 states and 15008 transitions.
[2020-05-30 20:39:29,097 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-05-30 20:39:29,097 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12560 states and 15008 transitions.
[2020-05-30 20:39:29,110 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:39:29,110 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:29,110 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:29,112 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:29,112 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:29,117 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:29,117 INFO  L82        PathProgramCache]: Analyzing trace with hash 475085859, now seen corresponding path program 1 times
[2020-05-30 20:39:29,117 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:29,136 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:29,217 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:29,217 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:29,217 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:29,218 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:29,218 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:29,218 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:29,218 INFO  L87              Difference]: Start difference. First operand 12560 states and 15008 transitions. cyclomatic complexity: 2472 Second operand 3 states.
[2020-05-30 20:39:29,327 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:29,327 INFO  L93              Difference]: Finished difference Result 12592 states and 15040 transitions.
[2020-05-30 20:39:29,327 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:29,327 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12592 states and 15040 transitions.
[2020-05-30 20:39:29,362 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:39:29,408 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12592 states to 12592 states and 15040 transitions.
[2020-05-30 20:39:29,409 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 139
[2020-05-30 20:39:29,409 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 139
[2020-05-30 20:39:29,409 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12592 states and 15040 transitions.
[2020-05-30 20:39:29,419 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:29,419 INFO  L728         BuchiCegarLoop]: Abstraction has 12592 states and 15040 transitions.
[2020-05-30 20:39:29,433 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12592 states and 15040 transitions.
[2020-05-30 20:39:29,538 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12592 to 12584.
[2020-05-30 20:39:29,538 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12584 states.
[2020-05-30 20:39:29,558 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12584 states to 12584 states and 15032 transitions.
[2020-05-30 20:39:29,558 INFO  L751         BuchiCegarLoop]: Abstraction has 12584 states and 15032 transitions.
[2020-05-30 20:39:29,558 INFO  L631         BuchiCegarLoop]: Abstraction has 12584 states and 15032 transitions.
[2020-05-30 20:39:29,558 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-05-30 20:39:29,558 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12584 states and 15032 transitions.
[2020-05-30 20:39:29,577 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 269
[2020-05-30 20:39:29,577 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:29,578 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:29,580 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:29,580 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:29,585 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:29,585 INFO  L82        PathProgramCache]: Analyzing trace with hash -710006077, now seen corresponding path program 1 times
[2020-05-30 20:39:29,586 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:29,607 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:29,728 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:29,729 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:29,729 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:39:29,729 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:29,729 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:39:29,729 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:39:29,730 INFO  L87              Difference]: Start difference. First operand 12584 states and 15032 transitions. cyclomatic complexity: 2472 Second operand 3 states.
[2020-05-30 20:39:29,827 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:29,827 INFO  L93              Difference]: Finished difference Result 12624 states and 15088 transitions.
[2020-05-30 20:39:29,827 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:39:29,827 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12624 states and 15088 transitions.
[2020-05-30 20:39:29,849 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 272
[2020-05-30 20:39:29,880 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12624 states to 12624 states and 15088 transitions.
[2020-05-30 20:39:29,880 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 139
[2020-05-30 20:39:29,880 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 139
[2020-05-30 20:39:29,880 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12624 states and 15088 transitions.
[2020-05-30 20:39:29,888 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:29,888 INFO  L728         BuchiCegarLoop]: Abstraction has 12624 states and 15088 transitions.
[2020-05-30 20:39:29,899 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12624 states and 15088 transitions.
[2020-05-30 20:39:29,975 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12624 to 12608.
[2020-05-30 20:39:29,975 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12608 states.
[2020-05-30 20:39:29,991 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12608 states to 12608 states and 15056 transitions.
[2020-05-30 20:39:29,991 INFO  L751         BuchiCegarLoop]: Abstraction has 12608 states and 15056 transitions.
[2020-05-30 20:39:29,991 INFO  L631         BuchiCegarLoop]: Abstraction has 12608 states and 15056 transitions.
[2020-05-30 20:39:29,991 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-05-30 20:39:29,991 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12608 states and 15056 transitions.
[2020-05-30 20:39:30,005 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 272
[2020-05-30 20:39:30,005 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:30,005 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:30,007 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:30,007 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND FALSE  !(DType[this] == RefundEscrow)
[L1974]        COND TRUE   DType[this] == ConditionalEscrow
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND FALSE  !(DType[this] == RefundEscrow)
[L1998]        COND TRUE   DType[this] == ConditionalEscrow
[L2000]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L2000]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2001]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:30,012 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:30,012 INFO  L82        PathProgramCache]: Analyzing trace with hash 1623641842, now seen corresponding path program 1 times
[2020-05-30 20:39:30,012 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:30,028 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:30,127 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:30,127 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:30,128 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [5] imperfect sequences [] total 5
[2020-05-30 20:39:30,128 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:30,128 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:39:30,128 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=9, Invalid=21, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:39:30,128 INFO  L87              Difference]: Start difference. First operand 12608 states and 15056 transitions. cyclomatic complexity: 2472 Second operand 6 states.
[2020-05-30 20:39:30,425 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:30,425 INFO  L93              Difference]: Finished difference Result 12728 states and 15200 transitions.
[2020-05-30 20:39:30,426 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 6 states. 
[2020-05-30 20:39:30,426 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 12728 states and 15200 transitions.
[2020-05-30 20:39:30,448 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 272
[2020-05-30 20:39:30,477 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 12728 states to 12624 states and 15080 transitions.
[2020-05-30 20:39:30,477 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 139
[2020-05-30 20:39:30,477 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 139
[2020-05-30 20:39:30,477 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 12624 states and 15080 transitions.
[2020-05-30 20:39:30,485 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:30,485 INFO  L728         BuchiCegarLoop]: Abstraction has 12624 states and 15080 transitions.
[2020-05-30 20:39:30,495 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 12624 states and 15080 transitions.
[2020-05-30 20:39:30,552 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 12624 to 12624.
[2020-05-30 20:39:30,552 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 12624 states.
[2020-05-30 20:39:30,566 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 12624 states to 12624 states and 15080 transitions.
[2020-05-30 20:39:30,566 INFO  L751         BuchiCegarLoop]: Abstraction has 12624 states and 15080 transitions.
[2020-05-30 20:39:30,566 INFO  L631         BuchiCegarLoop]: Abstraction has 12624 states and 15080 transitions.
[2020-05-30 20:39:30,566 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-05-30 20:39:30,566 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 12624 states and 15080 transitions.
[2020-05-30 20:39:30,578 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 272
[2020-05-30 20:39:30,578 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:30,578 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:30,579 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:30,579 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:30,583 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:30,583 INFO  L82        PathProgramCache]: Analyzing trace with hash 1891159875, now seen corresponding path program 1 times
[2020-05-30 20:39:30,584 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:30,598 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:30,690 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:30,690 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:30,690 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [10] imperfect sequences [] total 10
[2020-05-30 20:39:30,691 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:30,691 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-05-30 20:39:30,691 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-05-30 20:39:30,691 INFO  L87              Difference]: Start difference. First operand 12624 states and 15080 transitions. cyclomatic complexity: 2480 Second operand 10 states.
[2020-05-30 20:39:42,118 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:42,118 INFO  L93              Difference]: Finished difference Result 16156 states and 19997 transitions.
[2020-05-30 20:39:42,118 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:39:42,119 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16156 states and 19997 transitions.
[2020-05-30 20:39:42,161 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 461
[2020-05-30 20:39:42,213 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16156 states to 16100 states and 19933 transitions.
[2020-05-30 20:39:42,213 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 203
[2020-05-30 20:39:42,214 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 203
[2020-05-30 20:39:42,214 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 16100 states and 19933 transitions.
[2020-05-30 20:39:42,227 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:42,227 INFO  L728         BuchiCegarLoop]: Abstraction has 16100 states and 19933 transitions.
[2020-05-30 20:39:42,239 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 16100 states and 19933 transitions.
[2020-05-30 20:39:42,336 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 16100 to 15636.
[2020-05-30 20:39:42,336 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15636 states.
[2020-05-30 20:39:42,354 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15636 states to 15636 states and 19215 transitions.
[2020-05-30 20:39:42,354 INFO  L751         BuchiCegarLoop]: Abstraction has 15636 states and 19215 transitions.
[2020-05-30 20:39:42,355 INFO  L631         BuchiCegarLoop]: Abstraction has 15636 states and 19215 transitions.
[2020-05-30 20:39:42,355 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-05-30 20:39:42,355 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15636 states and 19215 transitions.
[2020-05-30 20:39:42,368 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 457
[2020-05-30 20:39:42,368 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:42,369 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:42,370 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:42,370 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND FALSE  !(Balance[from] >= amount)
[L3321]                    success := false;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND TRUE   choice == 11
[L3747]              gas := gas - 21000;
[L3748]  COND FALSE  !(gas >= 0)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:42,373 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:42,373 INFO  L82        PathProgramCache]: Analyzing trace with hash -203473424, now seen corresponding path program 1 times
[2020-05-30 20:39:42,374 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:42,390 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:42,512 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:42,513 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:42,513 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:39:42,513 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:42,513 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:39:42,514 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:39:42,514 INFO  L87              Difference]: Start difference. First operand 15636 states and 19215 transitions. cyclomatic complexity: 3603 Second operand 4 states.
[2020-05-30 20:39:42,661 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:39:42,661 INFO  L93              Difference]: Finished difference Result 15716 states and 19299 transitions.
[2020-05-30 20:39:42,661 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:39:42,661 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 15716 states and 19299 transitions.
[2020-05-30 20:39:42,707 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 457
[2020-05-30 20:39:42,755 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 15716 states to 15700 states and 19283 transitions.
[2020-05-30 20:39:42,756 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 208
[2020-05-30 20:39:42,756 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 208
[2020-05-30 20:39:42,756 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 15700 states and 19283 transitions.
[2020-05-30 20:39:42,768 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:39:42,768 INFO  L728         BuchiCegarLoop]: Abstraction has 15700 states and 19283 transitions.
[2020-05-30 20:39:42,781 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 15700 states and 19283 transitions.
[2020-05-30 20:39:42,893 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 15700 to 15700.
[2020-05-30 20:39:42,893 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15700 states.
[2020-05-30 20:39:42,920 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15700 states to 15700 states and 19283 transitions.
[2020-05-30 20:39:42,920 INFO  L751         BuchiCegarLoop]: Abstraction has 15700 states and 19283 transitions.
[2020-05-30 20:39:42,920 INFO  L631         BuchiCegarLoop]: Abstraction has 15700 states and 19283 transitions.
[2020-05-30 20:39:42,920 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-05-30 20:39:42,920 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15700 states and 19283 transitions.
[2020-05-30 20:39:42,942 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 457
[2020-05-30 20:39:42,942 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:39:42,942 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:39:42,944 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:39:42,944 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND FALSE  !(gas > 2300)
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND TRUE   choice == 11
[L3747]              gas := gas - 21000;
[L3748]  COND FALSE  !(gas >= 0)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:39:42,948 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:39:42,948 INFO  L82        PathProgramCache]: Analyzing trace with hash -1926946210, now seen corresponding path program 1 times
[2020-05-30 20:39:42,949 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:39:42,971 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:39:43,136 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:39:43,137 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:39:43,137 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [16] imperfect sequences [] total 16
[2020-05-30 20:39:43,137 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:39:43,137 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 16 interpolants.
[2020-05-30 20:39:43,138 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=76, Invalid=164, Unknown=0, NotChecked=0, Total=240
[2020-05-30 20:39:43,138 INFO  L87              Difference]: Start difference. First operand 15700 states and 19283 transitions. cyclomatic complexity: 3607 Second operand 16 states.
[2020-05-30 20:40:01,000 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:40:01,000 INFO  L93              Difference]: Finished difference Result 29045 states and 38510 transitions.
[2020-05-30 20:40:01,001 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 20 states. 
[2020-05-30 20:40:01,001 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 29045 states and 38510 transitions.
[2020-05-30 20:40:01,069 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 1060
[2020-05-30 20:40:01,165 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 29045 states to 29045 states and 38510 transitions.
[2020-05-30 20:40:01,165 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 411
[2020-05-30 20:40:01,166 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 411
[2020-05-30 20:40:01,166 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 29045 states and 38510 transitions.
[2020-05-30 20:40:01,186 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:40:01,186 INFO  L728         BuchiCegarLoop]: Abstraction has 29045 states and 38510 transitions.
[2020-05-30 20:40:01,199 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 29045 states and 38510 transitions.
[2020-05-30 20:40:01,332 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 29045 to 15734.
[2020-05-30 20:40:01,332 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 15734 states.
[2020-05-30 20:40:01,353 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 15734 states to 15734 states and 19153 transitions.
[2020-05-30 20:40:01,353 INFO  L751         BuchiCegarLoop]: Abstraction has 15734 states and 19153 transitions.
[2020-05-30 20:40:01,353 INFO  L631         BuchiCegarLoop]: Abstraction has 15734 states and 19153 transitions.
[2020-05-30 20:40:01,353 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-05-30 20:40:01,353 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 15734 states and 19153 transitions.
[2020-05-30 20:40:01,368 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 460
[2020-05-30 20:40:01,369 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:40:01,369 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:40:01,370 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:40:01,370 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:40:01,374 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:40:01,374 INFO  L82        PathProgramCache]: Analyzing trace with hash 694503916, now seen corresponding path program 1 times
[2020-05-30 20:40:01,375 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:40:01,393 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:40:01,631 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:40:01,631 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:40:01,631 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [29] imperfect sequences [] total 29
[2020-05-30 20:40:01,632 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:40:01,632 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 30 interpolants.
[2020-05-30 20:40:01,632 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=73, Invalid=797, Unknown=0, NotChecked=0, Total=870
[2020-05-30 20:40:01,632 INFO  L87              Difference]: Start difference. First operand 15734 states and 19153 transitions. cyclomatic complexity: 3443 Second operand 30 states.
[2020-05-30 20:41:17,476 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:41:17,476 INFO  L93              Difference]: Finished difference Result 38882 states and 50318 transitions.
[2020-05-30 20:41:17,476 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-30 20:41:17,477 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 38882 states and 50318 transitions.
[2020-05-30 20:41:17,568 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 1616
[2020-05-30 20:41:17,696 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 38882 states to 38882 states and 50318 transitions.
[2020-05-30 20:41:17,697 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 552
[2020-05-30 20:41:17,697 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 552
[2020-05-30 20:41:17,697 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 38882 states and 50318 transitions.
[2020-05-30 20:41:17,724 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:41:17,724 INFO  L728         BuchiCegarLoop]: Abstraction has 38882 states and 50318 transitions.
[2020-05-30 20:41:17,741 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 38882 states and 50318 transitions.
[2020-05-30 20:41:18,012 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 38882 to 34994.
[2020-05-30 20:41:18,012 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 34994 states.
[2020-05-30 20:41:18,062 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 34994 states to 34994 states and 43955 transitions.
[2020-05-30 20:41:18,062 INFO  L751         BuchiCegarLoop]: Abstraction has 34994 states and 43955 transitions.
[2020-05-30 20:41:18,062 INFO  L631         BuchiCegarLoop]: Abstraction has 34994 states and 43955 transitions.
[2020-05-30 20:41:18,062 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-05-30 20:41:18,062 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 34994 states and 43955 transitions.
[2020-05-30 20:41:18,097 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 1246
[2020-05-30 20:41:18,097 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:41:18,097 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:41:18,099 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:41:18,099 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND FALSE  !(gas < 21000)
[L2869]        COND TRUE   iterate && gas >= 21000
[L2871]                    havoc msgsender_MSG;
[L2872]                    havoc msgvalue_MSG;
[L2873]                    havoc choice;
[L2874]                    havoc __ret_0_primary;
[L2875]                    havoc recipient_s113;
[L2876]                    havoc payee_s148;
[L2877]                    havoc __ret_0_depositsOf;
[L2878]                    havoc payee_s158;
[L2879]                    havoc payee_s197;
[L2880]                    havoc payee_s255;
[L2881]                    havoc payee_s239;
[L2882]                    havoc __ret_0_withdrawalAllowed;
[L2883]                    havoc refundee_s327;
[L2884]                    havoc __arg_0_withdrawalAllowed;
[L2885]                    havoc beneficiary_s294;
[L2886]                    havoc __ret_0_state;
[L2887]                    havoc __ret_0_beneficiary;
[L2888]                    havoc iterate;
[L2889]        COND TRUE   DType[from] == RefundEscrow
[L2891]        COND FALSE  !(choice == 11)
[L2904]        COND FALSE  !(choice == 10)
[L2917]        COND FALSE  !(choice == 9)
[L2930]        COND FALSE  !(choice == 8)
[L2943]        COND FALSE  !(choice == 7)
[L2956]        COND FALSE  !(choice == 6)
[L2969]        COND FALSE  !(choice == 5)
[L2982]        COND FALSE  !(choice == 4)
[L2995]        COND FALSE  !(choice == 3)
[L3008]        COND TRUE   choice == 2
[L3010]                    gas := gas - 21000;
[L3011]        COND TRUE   gas >= 0
[L3013]                    assume msgvalue_MSG == 0;
[L3014]        CALL        call enableRefunds_RefundEscrow__success(from, to, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L3014]        RET         call enableRefunds_RefundEscrow__success(from, to, msgvalue_MSG);
[L3015]        COND FALSE  !(revert)
[L2869]        COND FALSE  !(iterate && gas >= 21000)
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:41:18,103 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:41:18,104 INFO  L82        PathProgramCache]: Analyzing trace with hash 1228401244, now seen corresponding path program 1 times
[2020-05-30 20:41:18,104 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:41:18,118 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:41:18,207 INFO  L134       CoverageAnalysis]: Checked inductivity of 122 backedges. 0 proven. 1 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:41:18,207 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:41:18,207 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [6] total 6
[2020-05-30 20:41:18,208 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:41:18,208 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 6 interpolants.
[2020-05-30 20:41:18,208 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=11, Invalid=19, Unknown=0, NotChecked=0, Total=30
[2020-05-30 20:41:18,208 INFO  L87              Difference]: Start difference. First operand 34994 states and 43955 transitions. cyclomatic complexity: 9009 Second operand 6 states.
[2020-05-30 20:41:19,457 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:41:19,457 INFO  L93              Difference]: Finished difference Result 20178 states and 22767 transitions.
[2020-05-30 20:41:19,457 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 5 states. 
[2020-05-30 20:41:19,457 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 20178 states and 22767 transitions.
[2020-05-30 20:41:19,505 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 24
[2020-05-30 20:41:19,557 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 20178 states to 19058 states and 21403 transitions.
[2020-05-30 20:41:19,557 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 432
[2020-05-30 20:41:19,559 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2356
[2020-05-30 20:41:19,560 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 19058 states and 21403 transitions.
[2020-05-30 20:41:19,572 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:41:19,572 INFO  L728         BuchiCegarLoop]: Abstraction has 19058 states and 21403 transitions.
[2020-05-30 20:41:19,582 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 19058 states and 21403 transitions.
[2020-05-30 20:41:19,693 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 19058 to 17898.
[2020-05-30 20:41:19,693 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 17898 states.
[2020-05-30 20:41:19,715 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 17898 states to 17898 states and 19823 transitions.
[2020-05-30 20:41:19,716 INFO  L751         BuchiCegarLoop]: Abstraction has 17898 states and 19823 transitions.
[2020-05-30 20:41:19,716 INFO  L631         BuchiCegarLoop]: Abstraction has 17898 states and 19823 transitions.
[2020-05-30 20:41:19,716 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-05-30 20:41:19,716 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 17898 states and 19823 transitions.
[2020-05-30 20:41:19,736 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-05-30 20:41:19,736 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:41:19,736 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:41:19,738 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:41:19,738 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:41:19,742 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:41:19,742 INFO  L82        PathProgramCache]: Analyzing trace with hash -1621025039, now seen corresponding path program 1 times
[2020-05-30 20:41:19,742 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:41:19,758 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:41:19,852 INFO  L134       CoverageAnalysis]: Checked inductivity of 158 backedges. 2 proven. 35 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:41:19,852 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:41:19,852 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:41:19,852 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:41:19,853 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:41:19,853 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:41:19,853 INFO  L87              Difference]: Start difference. First operand 17898 states and 19823 transitions. cyclomatic complexity: 1941 Second operand 11 states.
[2020-05-30 20:41:27,370 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:41:27,370 INFO  L93              Difference]: Finished difference Result 16748 states and 18449 transitions.
[2020-05-30 20:41:27,370 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-05-30 20:41:27,370 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 16748 states and 18449 transitions.
[2020-05-30 20:41:27,469 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:41:27,489 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 16748 states to 11485 states and 12588 transitions.
[2020-05-30 20:41:27,489 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1736
[2020-05-30 20:41:27,490 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1764
[2020-05-30 20:41:27,490 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11485 states and 12588 transitions.
[2020-05-30 20:41:27,496 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:41:27,496 INFO  L728         BuchiCegarLoop]: Abstraction has 11485 states and 12588 transitions.
[2020-05-30 20:41:27,501 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11485 states and 12588 transitions.
[2020-05-30 20:41:27,560 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11485 to 11425.
[2020-05-30 20:41:27,560 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11425 states.
[2020-05-30 20:41:27,572 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11425 states to 11425 states and 12430 transitions.
[2020-05-30 20:41:27,572 INFO  L751         BuchiCegarLoop]: Abstraction has 11425 states and 12430 transitions.
[2020-05-30 20:41:27,572 INFO  L631         BuchiCegarLoop]: Abstraction has 11425 states and 12430 transitions.
[2020-05-30 20:41:27,572 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-05-30 20:41:27,572 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11425 states and 12430 transitions.
[2020-05-30 20:41:27,585 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:41:27,585 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:41:27,585 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:41:27,586 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:41:27,586 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:41:27,603 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:41:27,603 INFO  L82        PathProgramCache]: Analyzing trace with hash 491184717, now seen corresponding path program 1 times
[2020-05-30 20:41:27,604 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:41:27,616 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:41:27,693 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:41:27,693 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:41:27,694 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:41:27,694 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:41:27,694 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:41:27,694 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:41:27,694 INFO  L87              Difference]: Start difference. First operand 11425 states and 12430 transitions. cyclomatic complexity: 1015 Second operand 13 states.
[2020-05-30 20:41:30,551 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:41:30,551 INFO  L93              Difference]: Finished difference Result 11512 states and 12665 transitions.
[2020-05-30 20:41:30,551 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 12 states. 
[2020-05-30 20:41:30,552 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 11512 states and 12665 transitions.
[2020-05-30 20:41:30,577 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:41:30,600 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 11512 states to 11512 states and 12665 transitions.
[2020-05-30 20:41:30,600 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1764
[2020-05-30 20:41:30,601 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1764
[2020-05-30 20:41:30,601 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 11512 states and 12665 transitions.
[2020-05-30 20:41:30,606 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:41:30,606 INFO  L728         BuchiCegarLoop]: Abstraction has 11512 states and 12665 transitions.
[2020-05-30 20:41:30,612 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 11512 states and 12665 transitions.
[2020-05-30 20:41:30,670 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 11512 to 11469.
[2020-05-30 20:41:30,670 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 11469 states.
[2020-05-30 20:41:30,682 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 11469 states to 11469 states and 12516 transitions.
[2020-05-30 20:41:30,682 INFO  L751         BuchiCegarLoop]: Abstraction has 11469 states and 12516 transitions.
[2020-05-30 20:41:30,682 INFO  L631         BuchiCegarLoop]: Abstraction has 11469 states and 12516 transitions.
[2020-05-30 20:41:30,682 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-05-30 20:41:30,682 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 11469 states and 12516 transitions.
[2020-05-30 20:41:30,694 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:41:30,694 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:41:30,694 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:41:30,695 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:41:30,696 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:41:30,699 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:41:30,699 INFO  L82        PathProgramCache]: Analyzing trace with hash -108321060, now seen corresponding path program 1 times
[2020-05-30 20:41:30,699 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:41:30,720 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:41:31,266 INFO  L134       CoverageAnalysis]: Checked inductivity of 117 backedges. 7 proven. 0 refuted. 0 times theorem prover too weak. 110 trivial. 0 not checked.
[2020-05-30 20:41:31,266 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:41:31,266 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [49] imperfect sequences [] total 49
[2020-05-30 20:41:31,267 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:41:31,267 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 50 interpolants.
[2020-05-30 20:41:31,268 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=151, Invalid=2299, Unknown=0, NotChecked=0, Total=2450
[2020-05-30 20:41:31,268 INFO  L87              Difference]: Start difference. First operand 11469 states and 12516 transitions. cyclomatic complexity: 1059 Second operand 50 states.
[2020-05-30 20:41:42,251 WARN  L188               SmtUtils]: Spent 108.00 ms on a formula simplification that was a NOOP. DAG size: 61
[2020-05-30 20:41:59,998 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:41:59,998 INFO  L93              Difference]: Finished difference Result 14675 states and 16252 transitions.
[2020-05-30 20:41:59,998 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 96 states. 
[2020-05-30 20:41:59,998 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 14675 states and 16252 transitions.
[2020-05-30 20:42:00,029 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:00,060 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 14675 states to 14291 states and 15802 transitions.
[2020-05-30 20:42:00,060 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1818
[2020-05-30 20:42:00,061 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1818
[2020-05-30 20:42:00,061 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 14291 states and 15802 transitions.
[2020-05-30 20:42:00,068 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:00,068 INFO  L728         BuchiCegarLoop]: Abstraction has 14291 states and 15802 transitions.
[2020-05-30 20:42:00,074 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 14291 states and 15802 transitions.
[2020-05-30 20:42:00,149 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 14291 to 13743.
[2020-05-30 20:42:00,149 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13743 states.
[2020-05-30 20:42:00,163 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13743 states to 13743 states and 15047 transitions.
[2020-05-30 20:42:00,163 INFO  L751         BuchiCegarLoop]: Abstraction has 13743 states and 15047 transitions.
[2020-05-30 20:42:00,163 INFO  L631         BuchiCegarLoop]: Abstraction has 13743 states and 15047 transitions.
[2020-05-30 20:42:00,163 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-05-30 20:42:00,164 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13743 states and 15047 transitions.
[2020-05-30 20:42:00,178 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:00,178 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:00,178 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:00,180 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:00,180 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND FALSE  !(choice == 2)
[L3835]        COND TRUE   choice == 1
[L3837]                    gas := gas - 21000;
[L3838]        COND TRUE   gas >= 0
[L3840]                    assume msgvalue_MSG == 0;
[L3841]        CALL        call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L749]                     havoc __exception;
[L750]                     revert := false;
[L751]         COND FALSE  !(__exception)
[L770]         CALL        call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2341]                    gas := gas - 317;
[L2342]        COND FALSE  !(!(_state_RefundEscrow[this] == 2))
[L2348]                    gas := gas - 36484;
[L2349]                    __var_8 := gas;
[L2350]        COND TRUE   gas > 2300
[L2352]                    gas := 2300;
[L2355]                    __var_8 := __var_8 - gas;
[L2356]                    __var_9 := this;
[L2357]                    assume Balance[this] >= 0;
[L2358]        CALL        call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L2358]        RET         call __var_10 := send__success(this, _beneficiary_RefundEscrow[this], Balance[this]);
[L2359]        COND FALSE  !(!__var_10)
[L2365]                    gas := __var_8 + gas;
[L770]         RET         call beneficiaryWithdraw_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L771]                     assume !revert && gas >= 0;
[L3841]        RET         call beneficiaryWithdraw_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:00,184 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:00,185 INFO  L82        PathProgramCache]: Analyzing trace with hash 1043004229, now seen corresponding path program 1 times
[2020-05-30 20:42:00,185 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:00,201 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:00,304 INFO  L134       CoverageAnalysis]: Checked inductivity of 150 backedges. 1 proven. 32 refuted. 0 times theorem prover too weak. 117 trivial. 0 not checked.
[2020-05-30 20:42:00,304 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:42:00,304 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-05-30 20:42:00,304 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:00,304 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-05-30 20:42:00,304 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=21, Invalid=89, Unknown=0, NotChecked=0, Total=110
[2020-05-30 20:42:00,305 INFO  L87              Difference]: Start difference. First operand 13743 states and 15047 transitions. cyclomatic complexity: 1329 Second operand 11 states.
[2020-05-30 20:42:02,289 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:42:02,289 INFO  L93              Difference]: Finished difference Result 13873 states and 15314 transitions.
[2020-05-30 20:42:02,289 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 10 states. 
[2020-05-30 20:42:02,289 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13873 states and 15314 transitions.
[2020-05-30 20:42:02,311 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:02,335 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13873 states to 13873 states and 15314 transitions.
[2020-05-30 20:42:02,335 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1775
[2020-05-30 20:42:02,336 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1775
[2020-05-30 20:42:02,336 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13873 states and 15314 transitions.
[2020-05-30 20:42:02,342 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:02,342 INFO  L728         BuchiCegarLoop]: Abstraction has 13873 states and 15314 transitions.
[2020-05-30 20:42:02,347 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13873 states and 15314 transitions.
[2020-05-30 20:42:02,416 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13873 to 13641.
[2020-05-30 20:42:02,417 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13641 states.
[2020-05-30 20:42:02,429 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13641 states to 13641 states and 14914 transitions.
[2020-05-30 20:42:02,429 INFO  L751         BuchiCegarLoop]: Abstraction has 13641 states and 14914 transitions.
[2020-05-30 20:42:02,429 INFO  L631         BuchiCegarLoop]: Abstraction has 13641 states and 14914 transitions.
[2020-05-30 20:42:02,429 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-05-30 20:42:02,429 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13641 states and 14914 transitions.
[2020-05-30 20:42:02,442 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:02,442 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:02,442 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:02,443 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:02,443 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:02,447 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:02,447 INFO  L82        PathProgramCache]: Analyzing trace with hash 276077948, now seen corresponding path program 1 times
[2020-05-30 20:42:02,447 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:02,476 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:02,885 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 21 proven. 22 refuted. 0 times theorem prover too weak. 178 trivial. 0 not checked.
[2020-05-30 20:42:02,885 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:42:02,885 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-05-30 20:42:02,886 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:02,886 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-05-30 20:42:02,886 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=103, Invalid=1379, Unknown=0, NotChecked=0, Total=1482
[2020-05-30 20:42:02,887 INFO  L87              Difference]: Start difference. First operand 13641 states and 14914 transitions. cyclomatic complexity: 1298 Second operand 39 states.
[2020-05-30 20:42:25,662 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:42:25,663 INFO  L93              Difference]: Finished difference Result 13962 states and 15418 transitions.
[2020-05-30 20:42:25,663 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 59 states. 
[2020-05-30 20:42:25,663 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 13962 states and 15418 transitions.
[2020-05-30 20:42:25,689 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:25,717 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 13962 states to 13962 states and 15418 transitions.
[2020-05-30 20:42:25,717 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1770
[2020-05-30 20:42:25,718 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1770
[2020-05-30 20:42:25,718 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 13962 states and 15418 transitions.
[2020-05-30 20:42:25,724 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:25,724 INFO  L728         BuchiCegarLoop]: Abstraction has 13962 states and 15418 transitions.
[2020-05-30 20:42:25,729 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 13962 states and 15418 transitions.
[2020-05-30 20:42:25,799 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 13962 to 13735.
[2020-05-30 20:42:25,799 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13735 states.
[2020-05-30 20:42:25,814 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13735 states to 13735 states and 15063 transitions.
[2020-05-30 20:42:25,815 INFO  L751         BuchiCegarLoop]: Abstraction has 13735 states and 15063 transitions.
[2020-05-30 20:42:25,815 INFO  L631         BuchiCegarLoop]: Abstraction has 13735 states and 15063 transitions.
[2020-05-30 20:42:25,815 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-05-30 20:42:25,815 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13735 states and 15063 transitions.
[2020-05-30 20:42:25,829 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:25,830 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:25,830 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:25,831 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:25,831 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND TRUE   __exception
[L531]                     __tmp__Balance := Balance;
[L532]                     __tmp__DType := DType;
[L533]                     __tmp__Alloc := Alloc;
[L534]                     __tmp__balance_ADDR := balance_ADDR;
[L535]                     __tmp__M_Ref_int__deposits0 := M_Ref_int__deposits0;
[L536]                     __tmp__sum__deposits0 := sum__deposits0;
[L537]                     __tmp__Length := Length;
[L538]                     __tmp__now := now;
[L539]                     __tmp___primary_Secondary := _primary_Secondary;
[L540]                     __tmp___deposits_Escrow := _deposits_Escrow;
[L541]                     __tmp___state_RefundEscrow := _state_RefundEscrow;
[L542]                     __tmp___beneficiary_RefundEscrow := _beneficiary_RefundEscrow;
[L543]         CALL        call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2058]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L2058]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L2059]        COND FALSE  !(revert)
[L2064]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L2064]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2065]        COND FALSE  !(revert)
[L2070]        CALL        call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1864]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1864]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1865]        COND FALSE  !(revert)
[L1870]        CALL        call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1484]        CALL        call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1355]        CALL        call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1334]                    assume msgsender_MSG != null;
[L1335]                    __tmp__Balance[this] := 0;
[L1336]                    __tmp___primary_Secondary[this] := null;
[L1337]                    __tmp___primary_Secondary[this] := msgsender_MSG;
[L1355]        RET         call Secondary_Secondary_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1356]        COND FALSE  !(revert)
[L1484]        RET         call Secondary_Secondary__fail(this, msgsender_MSG, msgvalue_MSG);
[L1485]        COND FALSE  !(revert)
[L1490]        CALL        call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1448]                    assume msgsender_MSG != null;
[L1449]                    __tmp__Balance[this] := 0;
[L1450]        CALL        call __var_2 := FreshRefGenerator__fail();
[L1168]                    havoc newRef;
[L1169]                    assume __tmp__Alloc[newRef] == false;
[L1170]                    __tmp__Alloc[newRef] := true;
[L1171]                    assume newRef != null;
[L1450]        RET         call __var_2 := FreshRefGenerator__fail();
[L1451]        COND FALSE  !(revert)
[L1456]                    __tmp___deposits_Escrow[this] := __var_2;
[L1457]                    __tmp__M_Ref_int__deposits0[__tmp___deposits_Escrow[this]] := zeroRefIntArr();
[L1458]                    __tmp__sum__deposits0[__tmp___deposits_Escrow[this]] := 0;
[L1490]        RET         call Escrow_Escrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1491]        COND FALSE  !(revert)
[L1870]        RET         call Escrow_Escrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L1871]        COND FALSE  !(revert)
[L1876]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1848]                    assume msgsender_MSG != null;
[L1849]                    __tmp__Balance[this] := 0;
[L1876]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG);
[L1877]        COND FALSE  !(revert)
[L2070]        RET         call ConditionalEscrow_ConditionalEscrow__fail(this, msgsender_MSG, msgvalue_MSG);
[L2071]        COND FALSE  !(revert)
[L2076]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2018]                    assume msgsender_MSG != null;
[L2019]                    __tmp__Balance[this] := 0;
[L2020]                    __tmp___beneficiary_RefundEscrow[this] := null;
[L2021]                    __var_7 := null;
[L2022]        COND FALSE  !(!(beneficiary_s294 != null))
[L2028]                    __tmp___beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2029]                    __tmp___state_RefundEscrow[this] := 0;
[L2076]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2077]        COND FALSE  !(revert)
[L543]         RET         call RefundEscrow_RefundEscrow__fail(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L544]                     assume revert || gas < 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:25,834 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:25,834 INFO  L82        PathProgramCache]: Analyzing trace with hash -835206703, now seen corresponding path program 1 times
[2020-05-30 20:42:25,835 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:25,844 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:25,905 INFO  L134       CoverageAnalysis]: Checked inductivity of 99 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 99 trivial. 0 not checked.
[2020-05-30 20:42:25,906 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:42:25,906 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-05-30 20:42:25,906 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:25,906 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-05-30 20:42:25,906 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=6, Invalid=6, Unknown=0, NotChecked=0, Total=12
[2020-05-30 20:42:25,907 INFO  L87              Difference]: Start difference. First operand 13735 states and 15063 transitions. cyclomatic complexity: 1358 Second operand 4 states.
[2020-05-30 20:42:26,893 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:42:26,893 INFO  L93              Difference]: Finished difference Result 17195 states and 19928 transitions.
[2020-05-30 20:42:26,893 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-05-30 20:42:26,893 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 17195 states and 19928 transitions.
[2020-05-30 20:42:26,935 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 18
[2020-05-30 20:42:26,984 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 17195 states to 17091 states and 19821 transitions.
[2020-05-30 20:42:26,984 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2245
[2020-05-30 20:42:26,985 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2245
[2020-05-30 20:42:26,985 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 17091 states and 19821 transitions.
[2020-05-30 20:42:26,996 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:26,996 INFO  L728         BuchiCegarLoop]: Abstraction has 17091 states and 19821 transitions.
[2020-05-30 20:42:27,004 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 17091 states and 19821 transitions.
[2020-05-30 20:42:27,101 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 17091 to 13631.
[2020-05-30 20:42:27,102 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 13631 states.
[2020-05-30 20:42:27,117 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 13631 states to 13631 states and 14955 transitions.
[2020-05-30 20:42:27,117 INFO  L751         BuchiCegarLoop]: Abstraction has 13631 states and 14955 transitions.
[2020-05-30 20:42:27,117 INFO  L631         BuchiCegarLoop]: Abstraction has 13631 states and 14955 transitions.
[2020-05-30 20:42:27,117 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-05-30 20:42:27,117 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 13631 states and 14955 transitions.
[2020-05-30 20:42:27,132 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-05-30 20:42:27,132 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:27,132 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:27,133 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:27,133 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND TRUE   choice == 3
[L3819]                    gas := gas - 21000;
[L3820]        COND TRUE   gas >= 0
[L3822]                    assume msgvalue_MSG == 0;
[L3823]        CALL        call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L675]                     havoc __exception;
[L676]                     revert := false;
[L677]         COND FALSE  !(__exception)
[L696]         CALL        call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2237]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2237]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2238]        COND FALSE  !(revert)
[L2243]                    gas := gas - 317;
[L2244]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2250]                    gas := gas - 20287;
[L2251]                    _state_RefundEscrow[this] := 2;
[L2252]                    assert { :EventEmitted "RefundsClosed_RefundEscrow" } true;
[L696]         RET         call close_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L697]                     assume !revert && gas >= 0;
[L3823]        RET         call close_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume to == user && amount == fsum_deposit_RefundEscrow_2_0;
[L7]                       success_send__success0 := true;
[L7]                       success_send__success0 := false;
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:27,137 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:27,137 INFO  L82        PathProgramCache]: Analyzing trace with hash 1286398555, now seen corresponding path program 1 times
[2020-05-30 20:42:27,138 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:27,151 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:27,246 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 34 proven. 0 refuted. 0 times theorem prover too weak. 121 trivial. 0 not checked.
[2020-05-30 20:42:27,246 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:42:27,246 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [13] imperfect sequences [] total 13
[2020-05-30 20:42:27,246 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:27,246 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 13 interpolants.
[2020-05-30 20:42:27,246 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=26, Invalid=130, Unknown=0, NotChecked=0, Total=156
[2020-05-30 20:42:27,247 INFO  L87              Difference]: Start difference. First operand 13631 states and 14955 transitions. cyclomatic complexity: 1354 Second operand 13 states.
[2020-05-30 20:42:30,264 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:42:30,264 INFO  L93              Difference]: Finished difference Result 9084 states and 9919 transitions.
[2020-05-30 20:42:30,264 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 15 states. 
[2020-05-30 20:42:30,264 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9084 states and 9919 transitions.
[2020-05-30 20:42:30,285 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:42:30,301 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9084 states to 8405 states and 9199 transitions.
[2020-05-30 20:42:30,301 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:42:30,302 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:42:30,302 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8405 states and 9199 transitions.
[2020-05-30 20:42:30,306 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:30,306 INFO  L728         BuchiCegarLoop]: Abstraction has 8405 states and 9199 transitions.
[2020-05-30 20:42:30,309 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8405 states and 9199 transitions.
[2020-05-30 20:42:30,344 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8405 to 8306.
[2020-05-30 20:42:30,344 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8306 states.
[2020-05-30 20:42:30,351 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8306 states to 8306 states and 9065 transitions.
[2020-05-30 20:42:30,351 INFO  L751         BuchiCegarLoop]: Abstraction has 8306 states and 9065 transitions.
[2020-05-30 20:42:30,352 INFO  L631         BuchiCegarLoop]: Abstraction has 8306 states and 9065 transitions.
[2020-05-30 20:42:30,352 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-05-30 20:42:30,352 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8306 states and 9065 transitions.
[2020-05-30 20:42:30,359 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:42:30,359 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:30,359 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:30,360 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:30,361 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:30,364 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:30,364 INFO  L82        PathProgramCache]: Analyzing trace with hash -663082172, now seen corresponding path program 1 times
[2020-05-30 20:42:30,364 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:30,385 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:30,883 INFO  L134       CoverageAnalysis]: Checked inductivity of 238 backedges. 4 proven. 44 refuted. 0 times theorem prover too weak. 190 trivial. 0 not checked.
[2020-05-30 20:42:30,883 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:42:30,883 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [50] total 50
[2020-05-30 20:42:30,884 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:30,884 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 51 interpolants.
[2020-05-30 20:42:30,884 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=190, Invalid=2360, Unknown=0, NotChecked=0, Total=2550
[2020-05-30 20:42:30,884 INFO  L87              Difference]: Start difference. First operand 8306 states and 9065 transitions. cyclomatic complexity: 780 Second operand 51 states.
[2020-05-30 20:42:54,955 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:42:54,955 INFO  L93              Difference]: Finished difference Result 8617 states and 9498 transitions.
[2020-05-30 20:42:54,955 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 80 states. 
[2020-05-30 20:42:54,955 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8617 states and 9498 transitions.
[2020-05-30 20:42:54,969 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:42:54,981 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8617 states to 8617 states and 9498 transitions.
[2020-05-30 20:42:54,981 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1772
[2020-05-30 20:42:54,982 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1772
[2020-05-30 20:42:54,982 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8617 states and 9498 transitions.
[2020-05-30 20:42:54,985 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:42:54,985 INFO  L728         BuchiCegarLoop]: Abstraction has 8617 states and 9498 transitions.
[2020-05-30 20:42:54,988 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8617 states and 9498 transitions.
[2020-05-30 20:42:55,025 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8617 to 8385.
[2020-05-30 20:42:55,025 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8385 states.
[2020-05-30 20:42:55,032 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8385 states to 8385 states and 9184 transitions.
[2020-05-30 20:42:55,033 INFO  L751         BuchiCegarLoop]: Abstraction has 8385 states and 9184 transitions.
[2020-05-30 20:42:55,033 INFO  L631         BuchiCegarLoop]: Abstraction has 8385 states and 9184 transitions.
[2020-05-30 20:42:55,033 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-05-30 20:42:55,033 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8385 states and 9184 transitions.
[2020-05-30 20:42:55,040 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:42:55,040 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:42:55,040 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:42:55,042 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:42:55,042 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:42:55,045 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:42:55,046 INFO  L82        PathProgramCache]: Analyzing trace with hash -43436924, now seen corresponding path program 1 times
[2020-05-30 20:42:55,046 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:42:55,071 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:42:55,545 INFO  L134       CoverageAnalysis]: Checked inductivity of 237 backedges. 11 proven. 43 refuted. 0 times theorem prover too weak. 183 trivial. 0 not checked.
[2020-05-30 20:42:55,546 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:42:55,546 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:42:55,547 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:42:55,547 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:42:55,547 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=204, Invalid=2448, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:42:55,547 INFO  L87              Difference]: Start difference. First operand 8385 states and 9184 transitions. cyclomatic complexity: 825 Second operand 52 states.
[2020-05-30 20:43:08,024 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:43:08,024 INFO  L93              Difference]: Finished difference Result 8595 states and 9469 transitions.
[2020-05-30 20:43:08,025 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 20:43:08,025 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8595 states and 9469 transitions.
[2020-05-30 20:43:08,042 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:08,057 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8595 states to 8583 states and 9425 transitions.
[2020-05-30 20:43:08,058 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:43:08,058 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:43:08,058 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8583 states and 9425 transitions.
[2020-05-30 20:43:08,062 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:43:08,062 INFO  L728         BuchiCegarLoop]: Abstraction has 8583 states and 9425 transitions.
[2020-05-30 20:43:08,065 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8583 states and 9425 transitions.
[2020-05-30 20:43:08,101 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8583 to 8355.
[2020-05-30 20:43:08,101 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8355 states.
[2020-05-30 20:43:08,109 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8355 states to 8355 states and 9142 transitions.
[2020-05-30 20:43:08,109 INFO  L751         BuchiCegarLoop]: Abstraction has 8355 states and 9142 transitions.
[2020-05-30 20:43:08,109 INFO  L631         BuchiCegarLoop]: Abstraction has 8355 states and 9142 transitions.
[2020-05-30 20:43:08,109 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-05-30 20:43:08,109 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8355 states and 9142 transitions.
[2020-05-30 20:43:08,116 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:08,117 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:43:08,117 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:43:08,118 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:43:08,118 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:43:08,121 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:43:08,121 INFO  L82        PathProgramCache]: Analyzing trace with hash 1403932749, now seen corresponding path program 1 times
[2020-05-30 20:43:08,122 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:43:08,134 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:43:08,216 INFO  L134       CoverageAnalysis]: Checked inductivity of 221 backedges. 1 proven. 0 refuted. 0 times theorem prover too weak. 220 trivial. 0 not checked.
[2020-05-30 20:43:08,216 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-05-30 20:43:08,216 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-05-30 20:43:08,216 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:43:08,217 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-05-30 20:43:08,217 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-05-30 20:43:08,217 INFO  L87              Difference]: Start difference. First operand 8355 states and 9142 transitions. cyclomatic complexity: 812 Second operand 3 states.
[2020-05-30 20:43:08,243 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:43:08,243 INFO  L93              Difference]: Finished difference Result 8359 states and 9142 transitions.
[2020-05-30 20:43:08,243 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-05-30 20:43:08,243 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8359 states and 9142 transitions.
[2020-05-30 20:43:08,255 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:08,267 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8359 states to 8359 states and 9142 transitions.
[2020-05-30 20:43:08,267 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1716
[2020-05-30 20:43:08,267 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1716
[2020-05-30 20:43:08,267 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8359 states and 9142 transitions.
[2020-05-30 20:43:08,270 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:43:08,270 INFO  L728         BuchiCegarLoop]: Abstraction has 8359 states and 9142 transitions.
[2020-05-30 20:43:08,273 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8359 states and 9142 transitions.
[2020-05-30 20:43:08,306 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8359 to 8355.
[2020-05-30 20:43:08,306 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8355 states.
[2020-05-30 20:43:08,314 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8355 states to 8355 states and 9137 transitions.
[2020-05-30 20:43:08,314 INFO  L751         BuchiCegarLoop]: Abstraction has 8355 states and 9137 transitions.
[2020-05-30 20:43:08,314 INFO  L631         BuchiCegarLoop]: Abstraction has 8355 states and 9137 transitions.
[2020-05-30 20:43:08,314 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-05-30 20:43:08,314 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8355 states and 9137 transitions.
[2020-05-30 20:43:08,322 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:08,322 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:43:08,322 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:43:08,323 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:43:08,323 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:43:08,327 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:43:08,327 INFO  L82        PathProgramCache]: Analyzing trace with hash -691235770, now seen corresponding path program 1 times
[2020-05-30 20:43:08,327 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:43:08,361 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:43:09,132 INFO  L134       CoverageAnalysis]: Checked inductivity of 222 backedges. 51 proven. 32 refuted. 0 times theorem prover too weak. 139 trivial. 0 not checked.
[2020-05-30 20:43:09,132 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:43:09,132 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [58] total 58
[2020-05-30 20:43:09,132 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:43:09,132 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 59 interpolants.
[2020-05-30 20:43:09,133 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=160, Invalid=3262, Unknown=0, NotChecked=0, Total=3422
[2020-05-30 20:43:09,133 INFO  L87              Difference]: Start difference. First operand 8355 states and 9137 transitions. cyclomatic complexity: 807 Second operand 59 states.
[2020-05-30 20:43:38,418 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:43:38,419 INFO  L93              Difference]: Finished difference Result 9770 states and 10980 transitions.
[2020-05-30 20:43:38,419 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 86 states. 
[2020-05-30 20:43:38,419 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9770 states and 10980 transitions.
[2020-05-30 20:43:38,440 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:38,464 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9770 states to 9770 states and 10974 transitions.
[2020-05-30 20:43:38,464 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1774
[2020-05-30 20:43:38,465 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1774
[2020-05-30 20:43:38,465 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9770 states and 10974 transitions.
[2020-05-30 20:43:38,470 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:43:38,470 INFO  L728         BuchiCegarLoop]: Abstraction has 9770 states and 10974 transitions.
[2020-05-30 20:43:38,474 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9770 states and 10974 transitions.
[2020-05-30 20:43:38,515 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9770 to 9639.
[2020-05-30 20:43:38,515 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9639 states.
[2020-05-30 20:43:38,526 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9639 states to 9639 states and 10820 transitions.
[2020-05-30 20:43:38,526 INFO  L751         BuchiCegarLoop]: Abstraction has 9639 states and 10820 transitions.
[2020-05-30 20:43:38,526 INFO  L631         BuchiCegarLoop]: Abstraction has 9639 states and 10820 transitions.
[2020-05-30 20:43:38,526 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-05-30 20:43:38,526 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9639 states and 10820 transitions.
[2020-05-30 20:43:38,535 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:43:38,535 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:43:38,535 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:43:38,536 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:43:38,536 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:43:38,540 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:43:38,541 INFO  L82        PathProgramCache]: Analyzing trace with hash 1264247268, now seen corresponding path program 1 times
[2020-05-30 20:43:38,541 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:43:38,566 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:43:39,155 INFO  L134       CoverageAnalysis]: Checked inductivity of 342 backedges. 22 proven. 66 refuted. 0 times theorem prover too weak. 254 trivial. 0 not checked.
[2020-05-30 20:43:39,156 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:43:39,156 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-05-30 20:43:39,156 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:43:39,156 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-05-30 20:43:39,156 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=136, Invalid=1756, Unknown=0, NotChecked=0, Total=1892
[2020-05-30 20:43:39,157 INFO  L87              Difference]: Start difference. First operand 9639 states and 10820 transitions. cyclomatic complexity: 1226 Second operand 44 states.
[2020-05-30 20:44:02,864 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:44:02,864 INFO  L93              Difference]: Finished difference Result 9732 states and 10956 transitions.
[2020-05-30 20:44:02,864 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 67 states. 
[2020-05-30 20:44:02,864 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9732 states and 10956 transitions.
[2020-05-30 20:44:02,886 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:02,909 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9732 states to 9732 states and 10956 transitions.
[2020-05-30 20:44:02,909 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1732
[2020-05-30 20:44:02,910 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1732
[2020-05-30 20:44:02,910 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9732 states and 10956 transitions.
[2020-05-30 20:44:02,915 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:44:02,915 INFO  L728         BuchiCegarLoop]: Abstraction has 9732 states and 10956 transitions.
[2020-05-30 20:44:02,919 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9732 states and 10956 transitions.
[2020-05-30 20:44:03,018 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9732 to 9641.
[2020-05-30 20:44:03,018 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9641 states.
[2020-05-30 20:44:03,030 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9641 states to 9641 states and 10828 transitions.
[2020-05-30 20:44:03,030 INFO  L751         BuchiCegarLoop]: Abstraction has 9641 states and 10828 transitions.
[2020-05-30 20:44:03,030 INFO  L631         BuchiCegarLoop]: Abstraction has 9641 states and 10828 transitions.
[2020-05-30 20:44:03,030 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-05-30 20:44:03,031 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9641 states and 10828 transitions.
[2020-05-30 20:44:03,041 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:03,041 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:44:03,041 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:44:03,042 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:44:03,042 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:44:03,061 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:44:03,062 INFO  L82        PathProgramCache]: Analyzing trace with hash 1053316116, now seen corresponding path program 1 times
[2020-05-30 20:44:03,062 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:44:03,104 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:44:03,634 INFO  L134       CoverageAnalysis]: Checked inductivity of 355 backedges. 25 proven. 79 refuted. 0 times theorem prover too weak. 251 trivial. 0 not checked.
[2020-05-30 20:44:03,634 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:44:03,635 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [42] total 42
[2020-05-30 20:44:03,635 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:44:03,635 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-05-30 20:44:03,636 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1679, Unknown=0, NotChecked=0, Total=1806
[2020-05-30 20:44:03,636 INFO  L87              Difference]: Start difference. First operand 9641 states and 10828 transitions. cyclomatic complexity: 1233 Second operand 43 states.
[2020-05-30 20:44:15,740 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:44:15,740 INFO  L93              Difference]: Finished difference Result 9719 states and 10956 transitions.
[2020-05-30 20:44:15,741 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 51 states. 
[2020-05-30 20:44:15,741 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9719 states and 10956 transitions.
[2020-05-30 20:44:15,761 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:15,780 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9719 states to 9707 states and 10914 transitions.
[2020-05-30 20:44:15,780 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:44:15,781 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:44:15,781 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9707 states and 10914 transitions.
[2020-05-30 20:44:15,785 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:44:15,785 INFO  L728         BuchiCegarLoop]: Abstraction has 9707 states and 10914 transitions.
[2020-05-30 20:44:15,788 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9707 states and 10914 transitions.
[2020-05-30 20:44:15,829 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9707 to 9620.
[2020-05-30 20:44:15,830 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9620 states.
[2020-05-30 20:44:15,840 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9620 states to 9620 states and 10762 transitions.
[2020-05-30 20:44:15,840 INFO  L751         BuchiCegarLoop]: Abstraction has 9620 states and 10762 transitions.
[2020-05-30 20:44:15,840 INFO  L631         BuchiCegarLoop]: Abstraction has 9620 states and 10762 transitions.
[2020-05-30 20:44:15,840 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-05-30 20:44:15,840 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9620 states and 10762 transitions.
[2020-05-30 20:44:15,849 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:15,849 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:44:15,849 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:44:15,851 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:44:15,851 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:44:15,855 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:44:15,855 INFO  L82        PathProgramCache]: Analyzing trace with hash -440909156, now seen corresponding path program 2 times
[2020-05-30 20:44:15,855 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:44:15,897 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:44:16,769 INFO  L134       CoverageAnalysis]: Checked inductivity of 442 backedges. 145 proven. 43 refuted. 0 times theorem prover too weak. 254 trivial. 0 not checked.
[2020-05-30 20:44:16,769 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:44:16,770 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [60] total 60
[2020-05-30 20:44:16,770 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:44:16,770 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 61 interpolants.
[2020-05-30 20:44:16,771 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=187, Invalid=3473, Unknown=0, NotChecked=0, Total=3660
[2020-05-30 20:44:16,771 INFO  L87              Difference]: Start difference. First operand 9620 states and 10762 transitions. cyclomatic complexity: 1181 Second operand 61 states.
[2020-05-30 20:44:38,682 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:44:38,682 INFO  L93              Difference]: Finished difference Result 9839 states and 11317 transitions.
[2020-05-30 20:44:38,682 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 72 states. 
[2020-05-30 20:44:38,682 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9839 states and 11317 transitions.
[2020-05-30 20:44:38,706 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:38,731 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9839 states to 9839 states and 11317 transitions.
[2020-05-30 20:44:38,731 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1760
[2020-05-30 20:44:38,732 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1760
[2020-05-30 20:44:38,732 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9839 states and 11317 transitions.
[2020-05-30 20:44:38,737 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:44:38,738 INFO  L728         BuchiCegarLoop]: Abstraction has 9839 states and 11317 transitions.
[2020-05-30 20:44:38,741 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9839 states and 11317 transitions.
[2020-05-30 20:44:38,787 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9839 to 9687.
[2020-05-30 20:44:38,787 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9687 states.
[2020-05-30 20:44:38,801 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9687 states to 9687 states and 11020 transitions.
[2020-05-30 20:44:38,801 INFO  L751         BuchiCegarLoop]: Abstraction has 9687 states and 11020 transitions.
[2020-05-30 20:44:38,801 INFO  L631         BuchiCegarLoop]: Abstraction has 9687 states and 11020 transitions.
[2020-05-30 20:44:38,801 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-05-30 20:44:38,801 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9687 states and 11020 transitions.
[2020-05-30 20:44:38,810 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:38,810 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:44:38,810 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:44:38,812 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:44:38,812 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:44:38,816 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:44:38,816 INFO  L82        PathProgramCache]: Analyzing trace with hash 1257298342, now seen corresponding path program 1 times
[2020-05-30 20:44:38,816 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:44:38,862 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:44:39,415 INFO  L134       CoverageAnalysis]: Checked inductivity of 438 backedges. 42 proven. 77 refuted. 0 times theorem prover too weak. 319 trivial. 0 not checked.
[2020-05-30 20:44:39,415 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:44:39,416 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-05-30 20:44:39,416 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:44:39,416 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-05-30 20:44:39,416 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=2225, Unknown=0, NotChecked=0, Total=2352
[2020-05-30 20:44:39,417 INFO  L87              Difference]: Start difference. First operand 9687 states and 11020 transitions. cyclomatic complexity: 1394 Second operand 49 states.
[2020-05-30 20:44:57,982 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:44:57,982 INFO  L93              Difference]: Finished difference Result 9755 states and 11110 transitions.
[2020-05-30 20:44:57,982 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-05-30 20:44:57,982 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9755 states and 11110 transitions.
[2020-05-30 20:44:58,001 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:58,020 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9755 states to 9755 states and 11110 transitions.
[2020-05-30 20:44:58,021 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1726
[2020-05-30 20:44:58,021 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1726
[2020-05-30 20:44:58,021 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9755 states and 11110 transitions.
[2020-05-30 20:44:58,026 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:44:58,026 INFO  L728         BuchiCegarLoop]: Abstraction has 9755 states and 11110 transitions.
[2020-05-30 20:44:58,029 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9755 states and 11110 transitions.
[2020-05-30 20:44:58,070 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9755 to 9560.
[2020-05-30 20:44:58,070 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 9560 states.
[2020-05-30 20:44:58,081 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 9560 states to 9560 states and 10671 transitions.
[2020-05-30 20:44:58,081 INFO  L751         BuchiCegarLoop]: Abstraction has 9560 states and 10671 transitions.
[2020-05-30 20:44:58,081 INFO  L631         BuchiCegarLoop]: Abstraction has 9560 states and 10671 transitions.
[2020-05-30 20:44:58,081 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-05-30 20:44:58,081 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 9560 states and 10671 transitions.
[2020-05-30 20:44:58,090 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:44:58,090 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:44:58,090 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:44:58,091 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:44:58,091 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]  CALL        call CorralChoice_RefundEscrow(this);
[L3718]              havoc msgsender_MSG;
[L3719]              havoc msgvalue_MSG;
[L3720]              havoc choice;
[L3721]              havoc __ret_0_primary;
[L3722]              havoc recipient_s113;
[L3723]              havoc payee_s148;
[L3724]              havoc __ret_0_depositsOf;
[L3725]              havoc refundee_s327;
[L3726]              havoc payee_s255;
[L3727]              havoc __arg_0_withdrawalAllowed;
[L3728]              havoc __ret_0_withdrawalAllowed;
[L3729]              havoc beneficiary_s294;
[L3730]              havoc __ret_0_state;
[L3731]              havoc __ret_0_beneficiary;
[L3732]              havoc tmpNow;
[L3733]              havoc gas;
[L3734]              assume gas > 4000000 && gas <= 8000000;
[L3735]              tmpNow := now;
[L3736]              havoc now;
[L3737]              assume now > tmpNow;
[L3738]              assume msgsender_MSG != null;
[L3739]              assume DType[msgsender_MSG] != SafeMath;
[L3740]              assume DType[msgsender_MSG] != Secondary;
[L3741]              assume DType[msgsender_MSG] != Escrow;
[L3742]              assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]              assume DType[msgsender_MSG] != RefundEscrow;
[L3744]              Alloc[msgsender_MSG] := true;
[L3745]  COND FALSE  !(choice == 11)
[L3754]  COND FALSE  !(choice == 10)
[L3763]  COND FALSE  !(choice == 9)
[L3772]  COND FALSE  !(choice == 8)
[L3781]  COND FALSE  !(choice == 7)
[L3790]  COND FALSE  !(choice == 6)
[L3799]  COND FALSE  !(choice == 5)
[L3808]  COND FALSE  !(choice == 4)
[L3817]  COND FALSE  !(choice == 3)
[L3826]  COND FALSE  !(choice == 2)
[L3835]  COND FALSE  !(choice == 1)
[L3864]  RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:44:58,095 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:44:58,095 INFO  L82        PathProgramCache]: Analyzing trace with hash 612830382, now seen corresponding path program 1 times
[2020-05-30 20:44:58,095 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:44:58,119 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:44:58,633 INFO  L134       CoverageAnalysis]: Checked inductivity of 343 backedges. 66 proven. 77 refuted. 0 times theorem prover too weak. 200 trivial. 0 not checked.
[2020-05-30 20:44:58,633 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:44:58,633 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [49] total 49
[2020-05-30 20:44:58,634 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:44:58,634 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 50 interpolants.
[2020-05-30 20:44:58,634 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=153, Invalid=2297, Unknown=0, NotChecked=0, Total=2450
[2020-05-30 20:44:58,634 INFO  L87              Difference]: Start difference. First operand 9560 states and 10671 transitions. cyclomatic complexity: 1148 Second operand 50 states.
[2020-05-30 20:45:32,029 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:45:32,029 INFO  L93              Difference]: Finished difference Result 10613 states and 12041 transitions.
[2020-05-30 20:45:32,029 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 71 states. 
[2020-05-30 20:45:32,029 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10613 states and 12041 transitions.
[2020-05-30 20:45:32,050 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:45:32,073 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10613 states to 10613 states and 12039 transitions.
[2020-05-30 20:45:32,073 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1736
[2020-05-30 20:45:32,074 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1736
[2020-05-30 20:45:32,074 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10613 states and 12039 transitions.
[2020-05-30 20:45:32,079 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:45:32,079 INFO  L728         BuchiCegarLoop]: Abstraction has 10613 states and 12039 transitions.
[2020-05-30 20:45:32,082 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10613 states and 12039 transitions.
[2020-05-30 20:45:32,127 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10613 to 10443.
[2020-05-30 20:45:32,127 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10443 states.
[2020-05-30 20:45:32,140 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10443 states to 10443 states and 11832 transitions.
[2020-05-30 20:45:32,140 INFO  L751         BuchiCegarLoop]: Abstraction has 10443 states and 11832 transitions.
[2020-05-30 20:45:32,140 INFO  L631         BuchiCegarLoop]: Abstraction has 10443 states and 11832 transitions.
[2020-05-30 20:45:32,140 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-05-30 20:45:32,141 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10443 states and 11832 transitions.
[2020-05-30 20:45:32,150 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:45:32,151 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:45:32,151 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:45:32,152 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:45:32,152 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:45:32,156 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:45:32,156 INFO  L82        PathProgramCache]: Analyzing trace with hash 677066574, now seen corresponding path program 1 times
[2020-05-30 20:45:32,157 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:45:32,186 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:45:32,821 INFO  L134       CoverageAnalysis]: Checked inductivity of 559 backedges. 143 proven. 134 refuted. 0 times theorem prover too weak. 282 trivial. 0 not checked.
[2020-05-30 20:45:32,821 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:45:32,821 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [53] total 53
[2020-05-30 20:45:32,821 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:45:32,821 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 54 interpolants.
[2020-05-30 20:45:32,822 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=183, Invalid=2679, Unknown=0, NotChecked=0, Total=2862
[2020-05-30 20:45:32,822 INFO  L87              Difference]: Start difference. First operand 10443 states and 11832 transitions. cyclomatic complexity: 1435 Second operand 54 states.
[2020-05-30 20:46:06,525 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:06,525 INFO  L93              Difference]: Finished difference Result 10777 states and 12256 transitions.
[2020-05-30 20:46:06,525 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 73 states. 
[2020-05-30 20:46:06,525 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 10777 states and 12256 transitions.
[2020-05-30 20:46:06,551 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:46:06,576 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 10777 states to 10777 states and 12254 transitions.
[2020-05-30 20:46:06,576 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1736
[2020-05-30 20:46:06,576 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1736
[2020-05-30 20:46:06,577 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 10777 states and 12254 transitions.
[2020-05-30 20:46:06,582 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:06,583 INFO  L728         BuchiCegarLoop]: Abstraction has 10777 states and 12254 transitions.
[2020-05-30 20:46:06,586 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 10777 states and 12254 transitions.
[2020-05-30 20:46:06,634 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 10777 to 10636.
[2020-05-30 20:46:06,634 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 10636 states.
[2020-05-30 20:46:06,648 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 10636 states to 10636 states and 12083 transitions.
[2020-05-30 20:46:06,648 INFO  L751         BuchiCegarLoop]: Abstraction has 10636 states and 12083 transitions.
[2020-05-30 20:46:06,648 INFO  L631         BuchiCegarLoop]: Abstraction has 10636 states and 12083 transitions.
[2020-05-30 20:46:06,648 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-05-30 20:46:06,648 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 10636 states and 12083 transitions.
[2020-05-30 20:46:06,658 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-05-30 20:46:06,658 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-05-30 20:46:06,658 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-05-30 20:46:06,659 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-05-30 20:46:06,659 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       fsum_deposit_RefundEscrow_2_0 := 0;
[L7]                       success_send__success0 := false;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]           CALL        call main();
[L7]                       havoc user;
[L3855]                    assume null == 0;
[L3856]        CALL        call this := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L3856]        RET         call this := FreshRefGenerator__success();
[L3857]                    assume now >= 0;
[L3858]                    assume DType[this] == RefundEscrow;
[L3859]                    gas := gas - 53000;
[L3860]        CALL        call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L527]                     havoc __exception;
[L528]                     revert := false;
[L529]         COND FALSE  !(__exception)
[L548]         CALL        call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2089]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L2089]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L2090]        COND FALSE  !(revert)
[L2095]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L2095]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2096]        COND FALSE  !(revert)
[L2101]        CALL        call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1887]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1887]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1888]        COND FALSE  !(revert)
[L1893]        CALL        call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1501]        CALL        call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1366]        CALL        call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1344]                    assume msgsender_MSG != null;
[L1345]                    Balance[this] := 0;
[L1346]                    _primary_Secondary[this] := null;
[L1347]                    _primary_Secondary[this] := msgsender_MSG;
[L1348]                    assert { :EventEmitted "PrimaryTransferred_Secondary" } true;
[L1366]        RET         call Secondary_Secondary_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1367]        COND FALSE  !(revert)
[L1501]        RET         call Secondary_Secondary__success(this, msgsender_MSG, msgvalue_MSG);
[L1502]        COND FALSE  !(revert)
[L1507]        CALL        call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1467]                    assume msgsender_MSG != null;
[L1468]                    Balance[this] := 0;
[L1469]        CALL        call __var_2 := FreshRefGenerator__success();
[L1178]                    havoc newRef;
[L1179]                    assume Alloc[newRef] == false;
[L1180]                    Alloc[newRef] := true;
[L1181]                    assume newRef != null;
[L1469]        RET         call __var_2 := FreshRefGenerator__success();
[L1470]        COND FALSE  !(revert)
[L1475]                    _deposits_Escrow[this] := __var_2;
[L1476]                    M_Ref_int__deposits0[_deposits_Escrow[this]] := zeroRefIntArr();
[L1477]                    sum__deposits0[_deposits_Escrow[this]] := 0;
[L1507]        RET         call Escrow_Escrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1508]        COND FALSE  !(revert)
[L1893]        RET         call Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG);
[L1894]        COND FALSE  !(revert)
[L1899]        CALL        call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1856]                    assume msgsender_MSG != null;
[L1857]                    Balance[this] := 0;
[L1899]        RET         call ConditionalEscrow_ConditionalEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1900]        COND FALSE  !(revert)
[L2101]        RET         call ConditionalEscrow_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2102]        COND FALSE  !(revert)
[L2107]        CALL        call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2038]                    assume msgsender_MSG != null;
[L2039]                    Balance[this] := 0;
[L2040]                    _beneficiary_RefundEscrow[this] := null;
[L2041]                    __var_7 := null;
[L2042]        COND FALSE  !(!(beneficiary_s294 != null))
[L2048]                    _beneficiary_RefundEscrow[this] := beneficiary_s294;
[L2049]                    _state_RefundEscrow[this] := 0;
[L2107]        RET         call RefundEscrow_RefundEscrow_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L2108]        COND FALSE  !(revert)
[L548]         RET         call RefundEscrow_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L549]                     assume !revert && gas >= 0;
[L3860]        RET         call RefundEscrow_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, beneficiary_s294);
[L3861]                    assume !revert && gas >= 0;
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(refundee_s327 == user);
[L7]                       revert := revert_hold;
[L7]                       assume !(refundee_s327 == user);
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND TRUE   choice == 8
[L3774]                    gas := gas - 21000;
[L3775]        COND TRUE   gas >= 0
[L3777]                    assume msgvalue_MSG >= 0;
[L3778]        CALL        call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L638]                     havoc __exception;
[L639]                     revert := false;
[L640]         COND FALSE  !(__exception)
[L659]         CALL        call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2187]                    assume Balance[msgsender_MSG] >= msgvalue_MSG;
[L2188]                    Balance[msgsender_MSG] := Balance[msgsender_MSG] - msgvalue_MSG;
[L2189]                    Balance[this] := Balance[this] + msgvalue_MSG;
[L2190]                    gas := gas - 317;
[L2191]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2197]                    gas := gas - 7;
[L2198]        COND TRUE   DType[this] == RefundEscrow
[L2200]        CALL        call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L1656]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1656]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1657]        COND FALSE  !(revert)
[L1662]                    gas := gas - 20;
[L1663]                    assume amount_s186 >= 0;
[L1664]                    assume msgvalue_MSG >= 0;
[L1665]                    amount_s186 := msgvalue_MSG;
[L1666]                    gas := gas - 40878;
[L1667]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1668]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] >= 0;
[L1669]                    assume amount_s186 >= 0;
[L1670]        CALL        call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1308]                    gas := gas - 6;
[L1309]                    gas := gas - 34;
[L1310]                    assume c_s48 >= 0;
[L1311]                    assume a_s49 >= 0;
[L1312]                    assume b_s49 >= 0;
[L1313]                    assume a_s49 + b_s49 >= 0;
[L1314]                    c_s48 := a_s49 + b_s49;
[L1315]                    gas := gas - 64;
[L1316]                    assume c_s48 >= 0;
[L1317]                    assume a_s49 >= 0;
[L1318]        COND FALSE  !(!(c_s48 >= a_s49))
[L1324]                    gas := gas - 20;
[L1325]                    assume c_s48 >= 0;
[L1326]                    __ret_0_ := c_s48;
[L1670]        RET         call __var_3 := add_SafeMath__success(this, this, 0, M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187], amount_s186);
[L1671]        COND FALSE  !(revert)
[L1676-L1677]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1678]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187] := __var_3;
[L1679-L1680]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s187];
[L1681]                    assume __var_3 >= 0;
[L1682]                    assert { :EventEmitted "Deposited_Escrow" } true;
[L2200]        RET         call deposit_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L2201]        COND FALSE  !(revert)
[L659]         RET         call deposit_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L660]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume refundee_s327 == user;
[L7]                       success_deposit_RefundEscrow0 := true;
[L7]                       success_deposit_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L7]                       assume refundee_s327 == user;
[L7]                       fsum_deposit_RefundEscrow_2_0 := fsum_deposit_RefundEscrow_2_0 + msgvalue_MSG;
[L3778]        RET         call deposit_RefundEscrow(this, msgsender_MSG, msgvalue_MSG, refundee_s327);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND FALSE  !(choice == 7)
[L3790]        COND FALSE  !(choice == 6)
[L3799]        COND FALSE  !(choice == 5)
[L3808]        COND FALSE  !(choice == 4)
[L3817]        COND FALSE  !(choice == 3)
[L3826]        COND TRUE   choice == 2
[L3828]                    gas := gas - 21000;
[L3829]        COND TRUE   gas >= 0
[L3831]                    assume msgvalue_MSG == 0;
[L3832]        CALL        call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L712]                     havoc __exception;
[L713]                     revert := false;
[L714]         COND FALSE  !(__exception)
[L733]         CALL        call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L2280]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L2280]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2281]        COND FALSE  !(revert)
[L2286]                    gas := gas - 317;
[L2287]        COND FALSE  !(!(_state_RefundEscrow[this] == 0))
[L2293]                    gas := gas - 20287;
[L2294]                    _state_RefundEscrow[this] := 1;
[L2295]                    assert { :EventEmitted "RefundsEnabled_RefundEscrow" } true;
[L733]         RET         call enableRefunds_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG);
[L734]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       success_enableRefunds_RefundEscrow0 := true;
[L7]                       success_enableRefunds_RefundEscrow0 := false;
[L7]                       revert := revert_hold;
[L3832]        RET         call enableRefunds_RefundEscrow(this, msgsender_MSG, msgvalue_MSG);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND TRUE   DType[to] == RefundEscrow
[L2426]                    assume amount == 0;
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(payee_s255 == user);
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

Loop:
[L3864]        CALL        call CorralChoice_RefundEscrow(this);
[L3718]                    havoc msgsender_MSG;
[L3719]                    havoc msgvalue_MSG;
[L3720]                    havoc choice;
[L3721]                    havoc __ret_0_primary;
[L3722]                    havoc recipient_s113;
[L3723]                    havoc payee_s148;
[L3724]                    havoc __ret_0_depositsOf;
[L3725]                    havoc refundee_s327;
[L3726]                    havoc payee_s255;
[L3727]                    havoc __arg_0_withdrawalAllowed;
[L3728]                    havoc __ret_0_withdrawalAllowed;
[L3729]                    havoc beneficiary_s294;
[L3730]                    havoc __ret_0_state;
[L3731]                    havoc __ret_0_beneficiary;
[L3732]                    havoc tmpNow;
[L3733]                    havoc gas;
[L3734]                    assume gas > 4000000 && gas <= 8000000;
[L3735]                    tmpNow := now;
[L3736]                    havoc now;
[L3737]                    assume now > tmpNow;
[L3738]                    assume msgsender_MSG != null;
[L3739]                    assume DType[msgsender_MSG] != SafeMath;
[L3740]                    assume DType[msgsender_MSG] != Secondary;
[L3741]                    assume DType[msgsender_MSG] != Escrow;
[L3742]                    assume DType[msgsender_MSG] != ConditionalEscrow;
[L3743]                    assume DType[msgsender_MSG] != RefundEscrow;
[L3744]                    Alloc[msgsender_MSG] := true;
[L3745]        COND FALSE  !(choice == 11)
[L3754]        COND FALSE  !(choice == 10)
[L3763]        COND FALSE  !(choice == 9)
[L3772]        COND FALSE  !(choice == 8)
[L3781]        COND TRUE   choice == 7
[L3783]                    gas := gas - 21000;
[L3784]        COND TRUE   gas >= 0
[L3786]                    assume msgvalue_MSG == 0;
[L3787]        CALL        call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L481]                     havoc __exception;
[L482]                     revert := false;
[L483]         COND FALSE  !(__exception)
[L502]         CALL        call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1965]                    gas := gas - 27;
[L1966]        COND TRUE   DType[this] == RefundEscrow
[L1968]        CALL        call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L2384]                    gas := gas - 3;
[L2385]                    gas := gas - 302;
[L2386]                    __ret_0_ := _state_RefundEscrow[this] == 1;
[L1968]        RET         call __var_6 := withdrawalAllowed_RefundEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1969]        COND FALSE  !(revert)
[L1983]        COND FALSE  !(!__var_6)
[L1989]                    gas := gas - 7;
[L1990]        COND TRUE   DType[this] == RefundEscrow
[L1992]        CALL        call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1807]        CALL        call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3344]                    gas := gas - 2208;
[L3345]        COND FALSE  !(!(msgsender_MSG == _primary_Secondary[this]))
[L1807]        RET         call onlyPrimary_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1808]        COND FALSE  !(revert)
[L1813]                    gas := gas - 614;
[L1814]                    assume payment_s227 >= 0;
[L1815]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1816]                    payment_s227 := M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1817]                    gas := gas - 10208;
[L1818]                    assume M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] >= 0;
[L1819-L1820]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] - M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1821]                    M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228] := 0;
[L1822-L1823]              sum__deposits0[_deposits_Escrow[this]] := sum__deposits0[_deposits_Escrow[this]] + M_Ref_int__deposits0[_deposits_Escrow[this]][payee_s228];
[L1824]                    gas := gas - 71574;
[L1825]                    __var_4 := gas;
[L1826]        COND TRUE   gas > 2300
[L1828]                    gas := 2300;
[L1831]                    __var_4 := __var_4 - gas;
[L1832]                    assume payment_s227 >= 0;
[L1833]        CALL        call __var_5 := send__success(this, payee_s228, payment_s227);
[L3288]                    havoc __exception;
[L3289]        COND FALSE  !(__exception)
[L3314]        COND TRUE   Balance[from] >= amount
[L3316]        CALL        call FallbackDispatch__success(from, to, amount);
[L2424]        COND FALSE  !(DType[to] == RefundEscrow)
[L2428]        COND FALSE  !(DType[to] == ConditionalEscrow)
[L2432]        COND FALSE  !(DType[to] == Escrow)
[L2436]        COND FALSE  !(DType[to] == Secondary)
[L2442]        CALL        call Fallback_UnknownType__success(from, to, amount);
[L2855]                    assume Balance[from] >= amount;
[L2856]                    Balance[from] := Balance[from] - amount;
[L2857]                    Balance[to] := Balance[to] + amount;
[L2858]        COND FALSE  !(choice == 0)
[L2864]        COND TRUE   gas < 21000
[L2442]        RET         call Fallback_UnknownType__success(from, to, amount);
[L2443]        COND FALSE  !(revert)
[L3316]        RET         call FallbackDispatch__success(from, to, amount);
[L3317]                    success := true;
[L3324]                    assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume !(to == user && amount == fsum_deposit_RefundEscrow_2_0);
[L7]                       revert := revert_hold;
[L1833]        RET         call __var_5 := send__success(this, payee_s228, payment_s227);
[L1834]        COND FALSE  !(!__var_5)
[L1840]                    gas := __var_4 + gas;
[L1841]                    assert { :EventEmitted "Withdrawn_Escrow" } true;
[L1992]        RET         call withdraw_Escrow_Escrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L1993]        COND FALSE  !(revert)
[L502]         RET         call withdraw_ConditionalEscrow__success(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L503]                     assume !revert && gas >= 0;
[L7]                       revert_hold := revert;
[L7]                       revert := false;
[L7]                       assume payee_s255 == user;
[L7]                       success_withdraw_ConditionalEscrow0 := true;
[L7]                       success_withdraw_ConditionalEscrow0 := false;
[L7]                       revert := revert_hold;
[L3787]        RET         call withdraw_ConditionalEscrow(this, msgsender_MSG, msgvalue_MSG, payee_s255);
[L3864]        RET         call CorralChoice_RefundEscrow(this);

[2020-05-30 20:46:06,664 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-05-30 20:46:06,664 INFO  L82        PathProgramCache]: Analyzing trace with hash 2068154554, now seen corresponding path program 1 times
[2020-05-30 20:46:06,664 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-05-30 20:46:06,744 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-05-30 20:46:07,477 INFO  L134       CoverageAnalysis]: Checked inductivity of 558 backedges. 32 proven. 132 refuted. 0 times theorem prover too weak. 394 trivial. 0 not checked.
[2020-05-30 20:46:07,477 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-05-30 20:46:07,477 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [51] total 51
[2020-05-30 20:46:07,478 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-05-30 20:46:07,478 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 52 interpolants.
[2020-05-30 20:46:07,478 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=150, Invalid=2502, Unknown=0, NotChecked=0, Total=2652
[2020-05-30 20:46:07,478 INFO  L87              Difference]: Start difference. First operand 10636 states and 12083 transitions. cyclomatic complexity: 1495 Second operand 52 states.
[2020-05-30 20:46:20,866 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-05-30 20:46:20,866 INFO  L93              Difference]: Finished difference Result 8792 states and 10038 transitions.
[2020-05-30 20:46:20,866 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-05-30 20:46:20,866 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8792 states and 10038 transitions.
[2020-05-30 20:46:20,886 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:46:20,886 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8792 states to 0 states and 0 transitions.
[2020-05-30 20:46:20,886 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-05-30 20:46:20,886 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-05-30 20:46:20,887 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-05-30 20:46:20,887 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-05-30 20:46:20,887 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:46:20,887 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:46:20,887 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-05-30 20:46:20,887 INFO  L445         BuchiCegarLoop]: ======== Iteration 32============
[2020-05-30 20:46:20,887 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-05-30 20:46:20,887 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-05-30 20:46:20,887 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-05-30 20:46:20,891 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 30.05 08:46:20 BasicIcfg
[2020-05-30 20:46:20,891 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-05-30 20:46:20,891 INFO  L168              Benchmark]: Toolchain (without parser) took 424279.94 ms. Allocated memory was 514.9 MB in the beginning and 4.5 GB in the end (delta: 4.0 GB). Free memory was 457.5 MB in the beginning and 2.2 GB in the end (delta: -1.7 GB). Peak memory consumption was 2.3 GB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,892 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,892 INFO  L168              Benchmark]: Boogie Preprocessor took 73.53 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,893 INFO  L168              Benchmark]: UtopiaSpecLang took 45.90 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,893 INFO  L168              Benchmark]: Boogie Printer took 12.22 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 441.3 MB in the end (delta: 2.7 MB). Peak memory consumption was 2.7 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,894 INFO  L168              Benchmark]: RCFGBuilder took 537.56 ms. Allocated memory is still 514.9 MB. Free memory was 441.3 MB in the beginning and 468.4 MB in the end (delta: -27.1 MB). Peak memory consumption was 99.0 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,894 INFO  L168              Benchmark]: UtopiaLTL2Aut took 46.01 ms. Allocated memory is still 514.9 MB. Free memory was 468.4 MB in the beginning and 463.5 MB in the end (delta: 4.9 MB). Peak memory consumption was 4.9 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,894 INFO  L168              Benchmark]: Büchi Program Product took 5669.42 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 768.1 MB). Free memory was 463.5 MB in the beginning and 277.0 MB in the end (delta: 186.4 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,895 INFO  L168              Benchmark]: BlockEncodingV2 took 688.74 ms. Allocated memory was 1.3 GB in the beginning and 1.7 GB in the end (delta: 402.7 MB). Free memory was 277.0 MB in the beginning and 1.1 GB in the end (delta: -779.1 MB). Peak memory consumption was 164.4 MB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,895 INFO  L168              Benchmark]: BuchiAutomizer took 417203.80 ms. Allocated memory was 1.7 GB in the beginning and 4.5 GB in the end (delta: 2.8 GB). Free memory was 1.1 GB in the beginning and 2.2 GB in the end (delta: -1.1 GB). Peak memory consumption was 1.7 GB. Max. memory is 15.3 GB.
[2020-05-30 20:46:20,899 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    15687 locations, 65222 edges
  - StatisticsResult: Encoded RCFG
    15463 locations, 63892 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.12 ms. Allocated memory is still 514.9 MB. Free memory is still 468.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 73.53 ms. Allocated memory is still 514.9 MB. Free memory was 457.5 MB in the beginning and 449.4 MB in the end (delta: 8.1 MB). Peak memory consumption was 8.1 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 45.90 ms. Allocated memory is still 514.9 MB. Free memory was 449.4 MB in the beginning and 444.0 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 12.22 ms. Allocated memory is still 514.9 MB. Free memory was 444.0 MB in the beginning and 441.3 MB in the end (delta: 2.7 MB). Peak memory consumption was 2.7 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 537.56 ms. Allocated memory is still 514.9 MB. Free memory was 441.3 MB in the beginning and 468.4 MB in the end (delta: -27.1 MB). Peak memory consumption was 99.0 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 46.01 ms. Allocated memory is still 514.9 MB. Free memory was 468.4 MB in the beginning and 463.5 MB in the end (delta: 4.9 MB). Peak memory consumption was 4.9 MB. Max. memory is 15.3 GB.
 * Büchi Program Product took 5669.42 ms. Allocated memory was 514.9 MB in the beginning and 1.3 GB in the end (delta: 768.1 MB). Free memory was 463.5 MB in the beginning and 277.0 MB in the end (delta: 186.4 MB). Peak memory consumption was 1.1 GB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 688.74 ms. Allocated memory was 1.3 GB in the beginning and 1.7 GB in the end (delta: 402.7 MB). Free memory was 277.0 MB in the beginning and 1.1 GB in the end (delta: -779.1 MB). Peak memory consumption was 164.4 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 417203.80 ms. Allocated memory was 1.7 GB in the beginning and 4.5 GB in the end (delta: 2.8 GB). Free memory was 1.1 GB in the beginning and 2.2 GB in the end (delta: -1.1 GB). Peak memory consumption was 1.7 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    8 locations, 27 edges
  - StatisticsResult: Initial RCFG
    1609 locations, 2228 edges
  - StatisticsResult: BuchiProgram size
    15687 locations, 65222 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 31 terminating modules (31 trivial, 0 deterministic, 0 nondeterministic). 31 modules have a trivial ranking function, the largest among these consists of 61 locations.
  - StatisticsResult: Timing statistics
    BüchiAutomizer plugin needed 417.1s and 32 iterations.  TraceHistogramMax:4. Analysis of lassos took 10.4s. Construction of modules took 337.4s. Büchi inclusion checks took 62.5s. Highest rank in rank-based complementation 0. Minimization of det autom 31. Minimization of nondet autom 0. Automata minimization 3.2s AutomataMinimizationTime, 30 MinimizatonAttempts, 27174 StatesRemovedByMinimization, 25 NontrivialMinimizations. Non-live state removal took 2.2s Buchi closure took 0.0s. Biggest automaton had 34994 states and ocurred in iteration 12.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 291687 SDtfs, 410893 SDslu, 666442 SDs, 0 SdLazy, 2386525 SolverSat, 89192 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 337.4s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU31 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ( ( <>(success_deposit_RefundEscrow0) ) && ( <>(success_withdraw_(success_enableRefunds_RefundEscrow0)onditionalEscrow0) ) )&& ! ( ( []( (success_enableRefunds_RefundEscrow0) ==> ( <>(success_send__success0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
